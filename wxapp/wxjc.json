{ "title": "微信小程序开发中 var that =this的用法 ", "author": "Rolan", "pub_time": "2020-2-6 00:52", "content": "在微信小程序开发中，var that =this的声明很常见。举个例子，代码如下！示例代码11  //index.js  \r\n2  Page({  \r\n3   \r\n4   data: {  \r\n5    toastHidden: true,  \r\n6   },  \r\n7   \r\n8   loadData: function () {  \r\n9      var that = this//这里声明了that；将this存在that里面  \r\n10     wx.request({  \r\n11       url: 'test.php',  \r\n12       data: {a: 'a', b: 'b'},  \r\n13       header: {  \r\n14        'content-type': 'application/json'  \r\n15       },  \r\n16       success(res) {  \r\n17           that.setData({ toastHidden: false }) //这里使用了that，这样就可以获取Page({})对象  \r\n18        },  \r\n19      })  \r\n20    }  \r\n21  \r\n22  })在代码中第9行声明了var that =this；第17行使用了that。如果不声明var that =this，且that改成this，代码如下！示例代码21  //index.js  \r\n2   Page({  \r\n3  \r\n4    data: {  \r\n5     toastHidden: true,  \r\n6   },  \r\n7  \r\n8    loadData: function () {  \r\n9      wx.request({  \r\n10      url: 'test.php',  \r\n11      data: {a: 'a', b: 'b'},  \r\n12      header: {  \r\n13       'content-type': 'application/json'  \r\n14      },  \r\n15      success(res) {  \r\n16        this.setData({ toastHidden: false })  \r\n17       },  \r\n18      })  \r\n19   }  \r\n20  \r\n21  })此时运行代码就会报以下错误！从报错中得知setData这个属性读不到，为何读不到？这跟this关键字的作用域有关！this作用域分析：1.在Page({})里面，this关键字指代Page({})整个对象2.因此可以通过this关键字访问或者重新设置Page({})里data的变量3.然而在loadData函数中使用了wx.request({})API这个方法导致在wx.request({})里没办法使用this来获取Page({})对象4.虽然在wx.request({})里没法使用this获取Page({})对象，但是可以在wx.request({})外面先把this存在某个变量中，所以就有了var that =this 这个声明。此时that指代Page({})整个对象，这样子就可以在wx.request({})里使用that访问或者重新设置Page({})里data的变量" } { "title": "小程序页面效果--如何实现滚动列表左右半透明 ", "author": "Rolan", "pub_time": "2020-2-6 00:56", "content": "为了更好的体验左右滑动，而且更加美观，我们常常会做如下效果：通过伪类+渐变实现左右半透明的滚动列表，微信小程序同样也适用，渐变的兼容性不太好，所以我们需要针对不同的浏览器写不同的代码。静态页面首先先写个静态页面<div class=\"my-list\">\r\n    <ul>\r\n        <li>左右半透明</li>\r\n                <li>滚动列表</li>\r\n                <li>左右半透明</li>\r\n                <li>滚动列表</li>\r\n                <li>伪类</li>\r\n                <li>渐变</li>\r\n                <li>内容</li>\r\n    </ul>\r\n</div>如果是微信小程序，类似的写一个<scroll-view class=\"my-list\" scroll-x=\"true\" enable-flex=\"true\">\r\n            <text>左右半透明</text>\r\n            <text>滚动列表</text>\r\n            <text>左右半透明</text>\r\n            <text>滚动列表</text>\r\n            <text>伪类</text>\r\n            <text>渐变</text>\r\n            <text>内容</text>\r\n</scroll-view>css然后写css.my-list:after,.my-list:before {\r\n    display: block;\r\n    content: \"\";\r\n    position: absolute;\r\n    z-index: 1;\r\n    top: 0;\r\n    height: 100%;\r\n    width: 20%\r\n}\r\n.my-list:before {\r\n    left: 0;\r\n    background: -webkit-gradient(linear,left top,right top,from(#fff),to(hsla(0,0%,100%,0)));\r\n    background:-webkit-linear-gradient(left,#fff,hsla(0,0%,100%,0));\r\n    background: -moz-linear-gradient(left,#fff,hsla(0,0%,100%,0));\r\n    background: linear-gradient(90deg,#fff,hsla(0,0%,100%,0));\r\n}\r\n\r\n.my-list:after {\r\n    right: 0;\r\n    background: -webkit-gradient(linear,right top,left top,from(#fff),to(hsla(0,0%,100%,0)));\r\n    background: -webkit-linear-gradient(right,#fff,hsla(0,0%,100%,0));\r\n    background: -moz-linear-gradient(right,#fff,hsla(0,0%,100%,0));\r\n    background: linear-gradient(270deg,#fff,hsla(0,0%,100%,0));\r\n}其中 .my-list:after,.my-list:before 中 width 控制左右半透明的长度，根据需求更改如此便通过伪类+渐变实现了左右半透明的滚动列表" } { "title": "小程序canvas开发水果老虎机 ", "author": "Rolan", "pub_time": "2020-2-8 00:53", "content": "在这个超长假期中，无聊。。。，所以动手做一个早就计划要做的小玩意， 水果老虎机 ，嗯，这是一个小程序而不是小游戏...使用结构还是canvas？使用模板结构(view)生成水果盘的好处一是用户可自定义产出 n x n 的定制化老虎机，二是容易通过算法样式生成布局，三是通过 wx.selectQueryAll 的方法能够很方便的抓到定位数据。但，问题是动画性能过于孱弱，如图构建一个 7x7 的水果盘，动画性能估计会惨不忍睹，而且纯粹模板结构无论使用 animation 动画方法还是 css 的keyframe的动画方法得到的动画效果都非常差(测试过的结论)，还有是已知的动画方法可控性很差使用canvas来生成水果盘好处是动画性能很好(canvas2d)，但是定制性和扩展性比较差so综上考虑，使用模板(view)布局，使用canvas来实现动画。既保证了组件的性能，同时定制型，扩展性也很好准备计时器方法动画的生成离不开计时器方法，settimeout/setinterval这两兄弟真的不够看啊，问题还多，做过web开发的一定都知道 window.requestAnimationFrame ，这货在小程序的计时器方法中不存在，好在 canvas2d 中可以使用 Canvas.requestAnimationFrame(function callback) 方法来实现准备运动算法在水果老虎机中，激活状态会沿着四方的水果盘做非线性运动(easeInOut比较好用)，需要基础的运动算法来计算实际的运动距离。在 animation 动画方法中，我们可以使用 ease-in/ease-out 等缓动算法来实现动画效果，但在这里必须要借助 tween.js 中的缓动算法来实现运动效果(因为需要控制运动节点)。你会不会想到用css的keyframe动画来做这个运动效果，经过我的测试，css的动画和animation的动画会在每一条边上实现一次(ease)缓动运动(很奇怪的效果)推荐这篇文章使用其中一个，节省代码量/*\r\n * Tween.js\r\n * t: current time（当前时间）；\r\n * b: beginning value（初始值）；\r\n * c: change in value（变化量）；\r\n * d: duration（持续时间）。\r\n */\r\n// Quart 四次方的缓动\r\nconst easeInOutQuart = function (t, b, c, d) {\r\n  if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\r\n  return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n}\r\n复制代码tween算法是以时间为基准(时间比率 = 距离比率)来计算单位时间的实际运动距离布局以上面的图为例，我们需要做一个 7 x 7 的水果盘，实际有效的奖品格子数为 7*4-4 共24个有效格子有效格子算法js// 0-6 第一行所有格子全部有效  \r\n// 21-27 最后一行所有格子全部有效  \r\n// 中间部分 i%7===0 和 i%7 === (7-1) 有效\r\n// 算法源码有点无聊，依据上述思路，即可遍历28个格子并标识奖品格子valide=true\r\n// 可以扩展想一想 6x6 5x5，思路是一样的\r\n复制代码wxml<view class=\"fruits-container\" >\r\n    <view class=\"fruits-table\" >\r\n        <block wx:for=\"{{ary}}\" wx:key=\"index\" >\r\n            <view wx:if=\"{{item.valide}}\" class=\"valide\">{{item.title}}</view>\r\n            <view wx:else class=\"in-valide\"></view>\r\n        </block>\r\n    </view>\r\n    <canvas type=\"2d\" .... />\r\n</view>\r\n复制代码样式只节选关键样式，目的是让canvas覆盖在水果盘上，长宽一致.fruits-container {\r\n    position: relative;\r\n    width: 400px;\r\n    height: 400px;\r\n    ...\r\n}\r\n\r\n.fruits-table {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n    top: 0;\r\n    left: 0;\r\n    ...\r\n}\r\n复制代码抓取位置信息canvas的绘制需要X轴, Y轴的精确信息，可以使用 wx.createSelectorQuery 方式抓取类名为‘valide’的 view (奖品格子)的位置信息let query = wx.createSelectorQuery().in(this)\r\nquery.selectAll(`.fruits-table .valide`).boundingClientRect(ret => {\r\n    ....\r\n    console.log(ret[0]) // top, left, right, bottom, width, height\r\n    console.log(ret[1]) // top, left, right, bottom, width, height\r\n    ...\r\n    ...\r\n    console.log(ret[23]) // top, left, right, bottom, width, height\r\n})\r\n复制代码得到每一个奖品格子的位置信息后，就可以使用canvas的 fillRect 方法来绘制激活状态了。绘制一个激活状态let query = wx.createSelectorQuery().in(this)\r\nquery.selectAll(`.fruits-table .valide`).boundingClientRect(ret => {\r\n    ....\r\n    let {top, left, right, bottom, width, height} = ret[0]\r\n    const canvasQuery = wx.createSelectorQuery()\r\n    canvasQuery.select('#fruit-canvas')\r\n    .fields({ node: true, size: true })\r\n    .exec((res) => {\r\n        const canvas = res[0].node\r\n        const ctx = canvas.getContext('2d') \r\n        let x = top\r\n        let y = left\r\n        let dx = width\r\n        let dy = height\r\n        ctx.shadowOffsetX = 2\r\n        ctx.shadowOffsetY = -2\r\n        ctx.shadowColor = 'red'\r\n        ctx.shadowBlur = 50\r\n        ctx.lineWidth = 5\r\n        ctx.strokeStyle = 'red'\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height)\r\n        ctx.strokeRect(x, y, dx, dy)\r\n    })\r\n})\r\n复制代码跑起来已经绘制了一个激活状态，接下来使它能够简单动起来// 抽象激活方法  \r\nfuncton rect(point, canvas){\r\n    let {x, y, dx, dy} = getPosition(point)\r\n    ctx.shadowOffsetX = 2\r\n    ctx.shadowOffsetY = -2\r\n    ...\r\n    ...\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height) // 擦除整个水果盘\r\n    ctx.strokeRect(x, y, dx, dy) // 绘制激活区域\r\n}\r\n\r\nfunction run(){\r\n    setTimeout(()=>{\r\n        if (ret.length) {\r\n            let point = ret.shift()\r\n            rect(point, canvas)\r\n            run()\r\n        }\r\n    }, 100)\r\n}\r\n复制代码执行run方法后可以看到水果盘的激活状态一步一步的往前走(100毫秒)，拖拉机终于可以启动了配上运动算法经过上面的试验我们终于可以看到基本的运动效果了，接下来配上运动算法和计时器方法// Quart 四次方的缓动\r\nconst easeInOutQuart = function (t, b, c, d) {\r\n  if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\r\n  return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n}\r\n\r\nlet start = 0  // 开始时间\r\nlet begin = 0  // 开始奖品位置\r\nlet end = 23  // 终点位置，这里跑一圈\r\nlet during = 5000 // 运动总时间\r\n\r\n// 1000/60 ≈ 17，\r\n// 17毫秒即表示屏幕60帧刷新率每秒 ≈ requestAnimationFrame计数频率(一般情况)  \r\nconst steper = () => {\r\n  // left为位移距离\r\n  // 老虎机的运动位移是节点位移，不是精确位移\r\n  // 所以这里用parseInt处理，只取整数部分\r\n  // 数据变化为 0,1,2,3,4,5...23\r\n  // 间隔时间/距离由easeInOutQuart算法计算\r\n  var left = easeInOutQuart(start, begin, end, during);\r\n  let idx = parseInt(left)\r\n  start = start + 17; \r\n  if (idx <= end) {\r\n    let point = this.ret[idx] // 取节点位置信息\r\n    this.rect(point) // 绘制\r\n  }\r\n  \r\n  // 时间递增\r\n  if (start <= during) {\r\n    this.ctx.requestAnimationFrame(steper); // 计时器\r\n  } else {\r\n    // 动画结束，这里可以插入回调...\r\n    // callback()...\r\n  }\r\n};\r\n\r\nsteper(); // 启动\r\n复制代码以上为我的小程序水果老虎机的基本开发思路" } { "title": "小程序后端 egg 框架开发记录 ", "author": "Rolan", "pub_time": "2020-2-16 00:21", "content": "内置对象Request & Response可以在 Context 的实例上获取到当前请求的 Request(\tctx.request ) 和 Response(\tctx.response ) 实例。ctx.response.body= 和\tctx.body= 是等价的。[!] 需要注意的是，获取 POST 的 body 应该使用\tctx.request.body ，而不是\tctx.bodyController框架提供了一个 Controller 基类，并推荐所有的\tController 都继承于该基类实现。这个 Controller 基类有下列属性:ctx - 当前请求的\tContext 实例。app - 应用的\tApplication 实例。config - 应用的\t配置 。service - 应用所有的\tservice 。logger - 为当前 controller 封装的 logger 对象。Service框架提供了一个 Service 基类，并推荐所有的\tService 都继承于该基类实现。\tService 基类的属性和 Controller 基类属性一致，访问方式也类似中间件编写中间件一个中间件是一个放置在\tapp/middleware 目录下的单独文件，它需要 exports 一个普通的 function，接受两个参数：options: 中间件的配置项，框架会将\tapp.config[${middlewareName}] 传递进来。app: 当前应用 Application 的实例。// app/middleware/error_handler.js\r\nmodule.exports = () => {\r\n  return async function errorHandler(ctx, next) {\r\n    try {\r\n      await next();\r\n    } catch (err) {\r\n      // 所有的异常都在 app 上触发一个 error 事件，框架会记录一条错误日志\r\n      ctx.app.emit('error', err, ctx);\r\n\r\n      const status = err.status || 500;\r\n      // 生产环境时 500 错误的详细错误内容不返回给客户端，因为可能包含敏感信息\r\n      const error = status === 500 && ctx.app.config.env === 'prod'\r\n        ? 'Internal Server Error'\r\n        : err.message;\r\n      // 从 error 对象上读出各个属性，设置到响应中\r\n\r\n      if (status === 422) {\r\n        ctx.body = { \r\n          code: ctx.ERROR_CODE, \r\n          data: error,\r\n          msg: '参数错误'+status\r\n         };\r\n      }\r\n      if (status === 500) {\r\n        ctx.body = { \r\n          code: 500, \r\n          data: '',\r\n          msg: '服务端错误-----'+error\r\n         };\r\n      }\r\n      ctx.status = 200;\r\n    }\r\n  };\r\n};复制代码使用在应用中使用中间件在应用中，我们可以完全通过配置来加载自定义的中间件，并决定它们的顺序。如果我们需要加载上面的 gzip 中间件，在\tconfig.default.js 中加入下面的配置就完成了中间件的开启和配置：// 加载 errorHandler 中间件\r\n  config.middleware = ['errorHandler']复制代码" } { "title": "小程序对文件及后缀名解析 ", "author": "Rolan", "pub_time": "2020-2-16 00:25", "content": "小程序对文件及后缀名解析引用微信开放平台文档1、后缀：1.1、WXSS：样式文件（类似CSS）WXSS 具有\tCSS 大部分的特性，小程序在\tWXSS 也做了一些扩充和修改。新增了尺寸单位。在写\tCSS 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。\tWXSS 在底层支持新的尺寸单位\trpx ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。提供了全局的样式和局部样式。和前边\tapp.json ,\tpage.json 的概念相同，你可以写一个\tapp.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式\tpage.wxss 仅对当前页面生效。此外\tWXSS 仅支持部分\tCSS 选择器更详细的文档可以参考\tWXSS 。1.2、WXML：模板文件（类似HTML）从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中\tHTML 是用来描述当前这个页面的结构，\tCSS 用来描述页面的样子，\tJS 通常是用来处理这个页面和用户的交互。和\tHTML 非常相似，\tWXML 由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：1.2.1、标签名字有点不一样往往写 HTML 的时候，经常会用到的标签是\tdiv ,\tp ,\tspan ，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。从上边的例子可以看到，小程序的\tWXML 用的标签是\tview ,\tbutton ,\ttext 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。1.2.2、多了一些\twx:if 这样的属性以及 {{ }} 这样的表达式在网页的一般开发流程中，我们通常会通过\tJS 操作\tDOM (对应\tHTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，\tJS 会记录一些状态到\tJS 变量里边，同时通过\tDOM API 操控\tDOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让\tJS 直接操控\tDOM ，\tJS 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。小程序的框架也是用到了这个思路，如果你需要把一个\tHello World 的字符串显示在界面上。WXML 是这么写 :<text>{{msg}}</text>JS 只需要管理状态即可:this.setData({ msg: \"Hello World\" })通过 {{ }} 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要\tif /\telse ,\tfor 等控制能力，在小程序里边，这些控制能力都用\twx: 开头的属性来表达。文档：\tWXML1.3、JS：一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写\tJS （JavaScript）脚本文件来处理用户的操作。<view>{{ msg }}</view>\r\n<button bindtap=\"clickMe\">点击我</button>点击\tbutton 按钮的时候，我们希望把界面上\tmsg 显示成\t\"Hello World\" ，于是我们在\tbutton 上声明一个属性:\tbindtap ，在 JS 文件里边声明了\tclickMe 方法来响应这次点击操作Page({\r\n  clickMe: function() {\r\n    this.setData({ msg: \"Hello World\" })\r\n  }\r\n})响应用户的操作就是这么简单，更详细的事件可以参考文档\tWXML - 事件 。此外你还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的 QuickStart 例子中，在\tpages/index/index.js 就调用了\twx.getUserInfo 获取微信用户的头像和昵称，最后通过\tsetData 把获取到的信息显示到界面上。更多 API 可以参考文档\t小程序的API 。1.4、json：json数据类型，用于静态配置2、文件：2.1、小程序配置app.json：是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。QuickStart 项目里边的\tapp.json 配置内容app.json的字段：pages字段—— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。window字段—— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。2.2、工具配置project.config.json：通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个\tproject.config.json ，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项参考文档：\t文档2.3、页面配置 page.json这里的\tpage.json 其实用来表示 pages/logs 目录下的\tlogs.json 这类和小程序页面相关的配置。如果你整个小程序的风格是蓝色调，那么你可以在\tapp.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了\tpage.json ，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。参考文档：\t文档" } { "title": "开发小程序折叠面板 ", "author": "Rolan", "pub_time": "2020-2-16 00:41", "content": "参考了一系列的小程序UI库。。。，最后参考了ant-design的折叠面板(collapse)组件设计，功能大致如下支持默认展开动态设置标签栏动态设置内容支持无效状态支持切换响应方法戳源码构思折叠面板组件由列表组件(ui-list)实现，列表项作为标签页，列表项子元素 content 作为弹出层，数据子项结构大致如下{\r\n    title: '标签标题',\r\n    content: '弹层内容'\r\n}\r\n复制代码列表组件构建一个动态组件 ui-list ，通过配置文件实现列表结构，将如下这段数据结构const mockData = [\r\n  {title: '列表项1', content: '弹层内容1'},\r\n  {title: '列表项2', content: '弹层内容2'},\r\n  {title: '列表项3', content: '弹层内容3'},\r\n]\r\n复制代码生成大致如下的wxml<view class=\"list-container\">\r\n    <view class=\"item\">\r\n      <view class=\"title\">列表项1</view>\r\n      <view class=\"content\">弹层内容1</view>\r\n    </view>\r\n    <view class=\"item\">\r\n      <view class=\"title\">列表项2</view>\r\n      <view class=\"content\">弹层内容2</view>\r\n    </view>\r\n    <view class=\"item\">\r\n      <view class=\"title\">列表项3</view>\r\n      <view class=\"content\">弹层内容3</view>\r\n    </view>\r\n</view>\r\n复制代码通过css样式，将弹层内容 <view class=\"content\"> 隐藏交互设计弹出设计<view class='title'> 作为展示标签，也作为点击事件的主体，当点击标签时为 <view class='item'> 的子容器添加 active 激活样式，此时弹层内容通过样式设计为 display: block 状态，即实现弹出显示<view class=\"item active\">\r\n  <view class=\"title\" bind:tap=\"change\">列表项1</view>\r\n  <view class=\"content\">弹层内容1</view> <!--css display block-->\r\n</view>\r\n复制代码更新设计为标签点击时提供 changeTitle，changeContent 方法，通过关键字段寻址，并更新数据，从而更新wxml结构，如下列的思路<view class=\"title\" bind:tap=\"change\" data-index=\"1\">列表项1</view>\r\n复制代码change(e){\r\n  const ds = e...dataset\r\n  this.toggleActive(e)\r\n  this.changeTitle(ds, ...) // 或者 this.changeContent(e, ...)\r\n}\r\nchangeTitle(ds, param) {\r\n  let index = ds.index\r\n  let $data = findIt(index)\r\n  $data.title = param\r\n  this.setData({config.data[index]: ....})\r\n}\r\nchangeContent(ds, param) {\r\n  // 思路同changeTitle\r\n}\r\n复制代码上面所述是简化逻辑，实现起来并不如此简单，尤其是寻址逻辑和更新逻辑实现及应用wxml<ui-list wx:if=\"{{collapsConfig}}\" list=\"{{collapsConfig}}\" />\r\n复制代码jslet config = {\r\n  listClass: 'collapse-pad',\r\n  data: [],\r\n  tap: function(param){ // 切换响应方法，样式操作封装在组件内部   \r\n    // this.title({...})  \r\n    // this.content({...}) \r\n    // this.disabled(true|false)\r\n  }  \r\n}\r\n\r\nPage({\r\n  data: {\r\n    collapsConfig: config \r\n  }\r\n})\r\n复制代码关于动态标签的一点想法动态标签的好处是可以将逻辑、寻址等在JS部分来实现，相较于 template 语法，动态标签的方式灵活太多了，能方便的实现组件化、模块化，规范化，和将公共部分抽离，且易于维护。当一个项目有多人维护时，碎片模板是一个地狱。" } { "title": "Taro 小程序开发大型实战：尝鲜微信小程序云 ", "author": "Rolan", "pub_time": "2020-2-19 00:37", "content": "欢迎继续阅读《Taro 小程序开发大型实战》系列，前情回顾：熟悉的 React，熟悉的 Hooks ：我们用 React 和 Hooks 实现了一个非常简单的添加帖子的原型多页面跳转和 Taro UI 组件库 ：我们用 Taro 自带的路由功能实现了多页面跳转，并用 Taro UI 组件库升级了应用界面实现微信和支付宝多端登录 ：实现了微信、支付宝以及普通登录和退出登录Hooks + Redux 双剑合璧 ：使用了 Hooks 版的 Redux 来重构应用的状态管理使用 Hooks 版的 Redux 实现大型应用状态管理（上篇） ：使用 Hooks 版的 Redux 实现了 user 逻辑的状态管理重构使用 Hooks 版的 Redux 实现大型应用状态管理（下篇） ：使用 Hooks 版的 Redux 实现了 post 逻辑的状态管理重构Taro 小程序开发大型实战（六）：尝鲜微信小程序云（上篇） ： user 逻辑接入微信小程序云在上一篇文章中，我们将我们两大逻辑之一 User 部分接入了 Redux 异步处理流程，接着接入了微信小程序云，使得 User 逻辑可以在云端永久保存，好不自在：），两兄弟一个得了好处，另外一个不能干瞪眼对吧？在这一篇教程中，我们想办法把 User 另外一个兄弟 Post 捞上来，也把 Redux 异步流程和微信小程序给它整上，这样就齐活了:laughing:。我们首先来看一看最终的完成效果：如果你不熟悉 Redux，推荐阅读我们的《Redux 包教包会》系列教程：Redux 包教包会（一）：解救 React 状态危机Redux 包教包会（二）：趁热打铁，完全重构Redux 包教包会（三）：各司其职，重拾初心如果你希望直接从这一步开始，请运行以下命令：git clone -b miniprogram-start https://github.com/tuture-dev/ultra-club.git\r\ncd ultra-club\r\n复制代码本文所涉及的源代码都放在了 Github 上，如果您觉得我们写得还不错，希望您能给 :heart:这篇文章点赞+Github仓库加星❤ ️哦~此教程属于 React 前端工程师学习路线 的一部分，欢迎来 Star 一波，鼓励我们继续创作出更好的教程，持续更新中~“六脉神剑” 搞定 createPost 异步逻辑不知道看到这里的读者有没有发现上篇文章其实打造了一套讲解模式，即按照如下的 “六步流程” 来讲解，我们也称为 “六脉神剑” 讲解法：sagas\r\nsagas\r\nsagas\r\nreducers\r\n可以看到我们上面的讲解顺序实际上是按照前端数据流的流动来进行的，我们对标上面的讲解逻辑来看一下前端数据流是如何流动的：从组件中通过对应的常量发起异步请求sagas 监听到对应的异步请求，开始处理流程在 sagas 调用对应的前端 API 文件向微信小程序云发起请求微信小程序云函数处理对应的 API 请求，返回数据sagas 中获取到对应的数据， dispatch action 到对应的 reducers 处理逻辑reducers 接收数据，开始更新本地 Redux Store 中的 state组件中重新渲染好的，了解了讲解逻辑和对应前端数据流动逻辑之后，我们马上来实践这套逻辑，把 User 逻辑的好兄弟 Post 逻辑搞定。第一剑： PostForm 组件中发起异步请求首先从创建帖子逻辑动刀子，我们将创建帖子接入异步逻辑并接通小程序云，让文章上云。打开 src/components/PostForm/index.jsx ，对其中的内容作出对应的修改如下：import { useDispatch, useSelector } from '@tarojs/redux'\r\n\r\nimport './index.scss'\r\nimport { CREATE_POST } from '../../constants'\r\n\r\nexport default function PostForm() {\r\n  const [formTitle, setFormTitle] = useState('')\r\n  const [formContent, setFormContent] = useState('')\r\n\r\n  const userId = useSelector(state => state.user.userId)\r\n\r\n  const dispatch = useDispatch()\r\n...    }\r\n\r\n    dispatch({\r\n      type: CREATE_POST,\r\n      payload: {\r\n        postData: {\r\n          title: formTitle,\r\n          content: formContent,\r\n        },\r\n        userId,\r\n      },\r\n    })\r\n\r\n    setFormTitle('')\r\n    setFormContent('')\r\n  }\r\n\r\n  return (\r\n复制代码可以看到，上面的内容做了如下四处修改：首先我们现在是接收用户的文章输入数据然后向小程序云发起创建文章的请求，所以我们将之前的 dispatch SET_POSTS Action 改为 CREATE_POST Action，并且将之前的 action payload 简化为 postData 和 userId ，因为我们可以通过小程序云数据库查询 userId 得到创建文章的用户信息，所以不需要再携带用户的数据。接着，因为我们不再需要用户的 avatar 和 nickName 数据，所以我们删掉了对应的 useSelector 语句。接着，因为请求是异步的，所以需要等待请求完成之后再设置对应的发表文章的状态以及发表文章弹出层状态，所以我们删掉了对应的 dispatch SET_POST_FORM_IS_OPENED Action 逻辑以及 Taro.atMessage 逻辑。最后我们删掉不需要的常量 SET_POSTS 和 SET_POST_FORM_IS_OPENED ，然后导入异步创建文章的常量 CREATE_POST 。增加 Action 常量我们在上一步中使用到了 CREATE_POST 常量，打开 src/constants/post.js ，在其中增加 CREATE_POST 常量：export const CREATE_POST = 'CREATE_POST'\r\n复制代码到这里，我们的 “六步流程” 讲解法就走完了第一步，即从组件中发起对应的异步请求，这里我们是发出的 action.type 为 CREATE_POST 的异步请求。第二剑： 声明和补充对应需要的异步 sagas 文件在 “第一剑” 中，我们从组件中 dispatch 了 action.type 为 CREATE_POST 的异步 Action，接下来我们要做的就是在对应的 sagas 文件中补齐响应这个异步 action 的 sagas。在 src/sagas/ 文件夹下面创建 post.js 文件，并在其中编写如下创建文章的逻辑：import Taro from '@tarojs/taro'\r\nimport { call, put, take, fork } from 'redux-saga/effects'\r\n\r\nimport { postApi } from '../api'\r\nimport {\r\n  CREATE_POST,\r\n  POST_SUCCESS,\r\n  POST_ERROR,\r\n  SET_POSTS,\r\n  SET_POST_FORM_IS_OPENED,\r\n} from '../constants'\r\n\r\nfunction* createPost(postData, userId) {\r\n  try {\r\n    const post = yield call(postApi.createPost, postData, userId)\r\n\r\n    // 其实以下三步可以合成一步，但是这里为了讲解清晰，将它们拆分成独立的单元\r\n\r\n    // 发起发帖成功的 action\r\n    yield put({ type: POST_SUCCESS })\r\n\r\n    // 关闭发帖框弹出层\r\n    yield put({ type: SET_POST_FORM_IS_OPENED, payload: { isOpened: false } })\r\n\r\n    // 更新 Redux store 数据\r\n    yield put({\r\n      type: SET_POSTS,\r\n      payload: {\r\n        posts: [post],\r\n      },\r\n    })\r\n\r\n    // 提示发帖成功\r\n    Taro.atMessage({\r\n      message: '发表文章成功',\r\n      type: 'success',\r\n    })\r\n  } catch (err) {\r\n    console.log('createPost ERR: ', err)\r\n\r\n    // 发帖失败，发起失败的 action\r\n    yield put({ type: POST_ERROR })\r\n\r\n    // 提示发帖失败\r\n    Taro.atMessage({\r\n      message: '发表文章失败',\r\n      type: 'error',\r\n    })\r\n  }\r\n}\r\n\r\nfunction* watchCreatePost() {\r\n  while (true) {\r\n    const { payload } = yield take(CREATE_POST)\r\n\r\n    console.log('payload', payload)\r\n\r\n    yield fork(createPost, payload.postData, payload.userId)\r\n  }\r\n}\r\n\r\nexport { watchCreatePost }\r\n复制代码可以看到，上面的改动主要是创建 watcherSaga 和 handlerSaga 。创建 watcherSaga我们创建了登录的 watcherSaga ： watchCreatePost ，它用来监听 action.type 为 CREATE_POST 的 action，并且当监听到 CREATE_POST action 之后，从这个 action 中获取必要的 postData 和 userId 数据，然后激活 handlerSaga ： createPost 去处理对应的创建帖子的逻辑。这里的 watcherSaga ： watchCreatePost 是一个生成器函数，它内部是一个 while 无限循环，表示在内部持续监听 CREATE_POST action。在循环内部，我们使用了 redux-saga 提供的 effects helper 函数： take ，它用于监听 CREATE_POST action，获取 action 中携带的数据。接着我们使用了另外一个 effects helper 函数： fork ，它表示非阻塞的执行 handlerSaga： createPost ，并将 payload.postData 和 payload.userId 作为参数传给 createPost 。创建 handlerSaga我们创建了创建帖子的 handlerSaga ： createPost ，它用来处理创建逻辑。createPost 也是一个生成器函数，在它内部是一个 try/catch 语句，用于处理创建帖子请求可能存在的错误情况。在 try 语句中，首先是使用了 redux-saga 提供给我们的 effects helper 函数： call 来调用登录的 API： postApi.createPost ，并把 postData 和 userId 作为参数传给这个 API。如果创建帖子成功，我们使用 redux-saga 提供的 effects helpers 函数： put ， put类似之前在 view 中的 dispatch 操作，，来 dispatch 了三个 action： POST_SUCCESS ， SET_POST_FORM_IS_OPENED ， SET_POSTS ，代表更新创建帖子成功的状态，关闭发帖框，设置最新创建的帖子信息到 Redux Store 中。最后我们使用了 Taro UI 提供给我们的消息框，来显示一个 success 消息。如果发帖失败，我们则使用 put 发起一个 POST_ERROR 的 action 来更新创建帖子失败的信息到 Redux Store，接着使用了 Taro UI 提供给我们的消息框，来显示一个 error 消息。一些额外的工作为了创建 watcherSaga 和 handlerSaga ，我们还导入了 postApi ，我们将在后面来创建这个 API。除此之外我们还导入了需要使用的 action 常量：POST_SUCCESS\r\nPOST_ERROR\r\nSET_POSTS\r\nCREATE_POST\r\nSET_POST_FORM_IS_OPENED\r\n这里的 POST_SUCCESS 和 POST_ERROR 我们还没有创建，我们将马上在 “下一剑” 中创建它。以及一些 redux-saga/effects 相关的 helper 函数，我们已经在之前的内容中详细讲过了，这里就不再赘述了。加入 saga 中心调度文件我们像之前将 watchLogin 等加入到 sagas 中心调度文件一样，将我们创建好的 watchCreatePost 也加入进去：// ...之前的逻辑\r\nimport { watchCreatePost } from './post'\r\nexport default function* rootSaga() {\r\n  yield all([\r\n   // ... 之前的逻辑\r\n    fork(watchCreatePost)\r\n  ])\r\n}\r\n复制代码第三剑：定义 sagas 需要的常量文件打开 src/constants/post.js 文件，定义我们之前创建的常量文件如下：export const POST_SUCCESS = 'POST_SUCCESS'\r\nexport const POST_ERROR = 'POST_ERROR'\r\n复制代码第四剑：定义 sagas 涉及到的前端 API 文件在之前的 post saga 文件里面，我们使用到了 postApi ，它里面封装了用于向后端（这里我们是小程序云）发起和帖子有关请求的逻辑，让我们马上来实现它吧。在 src/api/ 文件夹下添加 post.js 文件，并在文件中编写内容如下：import Taro from '@tarojs/taro'\r\n\r\nasync function createPost(postData, userId) {\r\n  const isWeapp = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n  const isAlipay = Taro.getEnv() === Taro.ENV_TYPE.ALIPAY\r\n\r\n  console.log('postData', postData, userId)\r\n\r\n  // 针对微信小程序使用小程序云函数，其他使用小程序 RESTful API\r\n  try {\r\n    if (isWeapp) {\r\n      const { result } = await Taro.cloud.callFunction({\r\n        name: 'createPost',\r\n        data: {\r\n          postData,\r\n          userId,\r\n        },\r\n      })\r\n\r\n      return result.post\r\n    }\r\n  } catch (err) {\r\n    console.error('createPost ERR: ', err)\r\n  }\r\n}\r\n\r\nconst postApi = {\r\n  createPost,\r\n}\r\nexport default postApi;\r\n复制代码在上面的代码中，我们定义了 createPost 函数，它是一个 async 函数，用来处理异步逻辑，在 createPost 函数中，我们对当前的环境进行了判断，且只在微信小程序，即 isWeapp 的条件下执行创建帖子的操作，对于支付宝小程序和 H5，我们则放在下一节使用 LeanCloud 的 Serverless 来解决。创建帖子逻辑是一个 try/catch 语句，用于捕捉可能存在的请求错误，在 try 代码块中，我们使用了 Taro 为我们提供的微信小程序云的云函数 API Taro.cloud.callFunction 来便捷的向小程序云发起云函数调用请求。这里我们调用了一个 createPost 云函数，并将 postData 和 userId 作为参数传给云函数，用于在云函数中使用用户 Id 和帖子数据来创建一个属于此用户的帖子并保存到数据库，我们将在下一节中实现这个云函数。如果调用成功，我们可以接收返回值，用于从后端返回数据，这里我们返回了 result.post 数据。如果调用失败，则打印错误。最后我们定义了一个 postApi 对象，用于存放所有和用户逻辑有个的函数，并添加 createPost API 属性然后将其导出，这样在 post saga 函数里面就可以导入 postApi 然后通过 postApi.createPost 的方式来调用 createPost API 处理创建帖子的逻辑了。在 API 默认文件统一导出在 src/api/index.js 文件中导入上面创建的 postApi 并进行统一导出如下：import postApi from './post'\r\nexport { postApi }\r\n复制代码第五剑：创建对应的微信小程序云函数创建 createPost 云函数按照和之前创建 login 云函数类似，我们创建 createPost 云函数。创建成功之后，我们可以得到两个文件，一个是 functions/createPost/package.json 文件，它和之前的类似。{\r\n  \"name\": \"createPost\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"wx-server-sdk\": \"latest\"\r\n  }\r\n}\r\n复制代码第二个文件就是我们需要编写创建帖子逻辑的 functions/createPost/index.js 文件，微信小程序开发者工具会默认为我们生成一段样板代码。我们在 function/createPost 文件夹下同样运行 npm install 安装对应的云函数依赖，这样我们才能运行它。编写 createPost 云函数打开 functions/createPost/index.js 文件，对其中的内容作出对应的修改如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init({\r\n  env: cloud.DYNAMIC_CURRENT_ENV,\r\n})\r\n\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const { postData, userId } = event\r\n\r\n  console.log('event', event)\r\n\r\n  try {\r\n    const user = await db\r\n      .collection('user')\r\n      .doc(userId)\r\n      .get()\r\n    const { _id } = await db.collection('post').add({\r\n      data: {\r\n        ...postData,\r\n        user: user.data,\r\n        createdAt: db.serverDate(),\r\n        updatedAt: db.serverDate(),\r\n      },\r\n    })\r\n\r\n    const newPost = await db\r\n      .collection('post')\r\n      .doc(_id)\r\n      .get()\r\n\r\n    return {\r\n      post: { ...newPost.data },\r\n    }\r\n  } catch (err) {\r\n    console.error(`createUser ERR: ${err}`)\r\n  }\r\n}\r\n复制代码可以看到上面的代码改动主要有以下七处：首先我们给 cloud.init() 传入了环境参数，我们使用了内置的 cloud.DYNAMIC_CURRENT_ENV，表示自动设置为当前的云环境，即在右键点击小程序开发者工具里 functions 文件夹时选择的环境。接着，我们通过 cloud.database() 生成了数据实例 db ，用于之后在函数体中便捷的操作云数据库。接着就是 main 函数体，我们首先从 event 对象中取到了在小程序的调用 Taro.cloud.callFunction 传过来的 postData 和 userId 数据。然后，跟着取数据的是一个 try/catch 语句块，用于捕获错误，在 try 语句块中，我们使用 db 的查询操作： db.collection('user').doc(userId).get() ，表示查询 id 为 userId 的 user 表数据，它查出来应该是个唯一值，如果不存在满足 where 条件的，那么是一个 null值，如果存在满足 条件的，那么返回一个 user 对象。接着，我们使用的 db.collection('post').add() 添加一个 post 数据，然后在 add 方法中传入 data 字段，这里我们不仅传入了 postData ，还将 user 也一同传入了，原因我们将在之后来讲解。除此之外，这里我们额外使用了 db.serverDate() 用于记录创建此帖子的时间和更新此帖子的时间，方便之后做条件查询。接着，因为向数据库添加一个记录之后只会返回此记录的 _id ，所以我们需要一个额外的操作 db.collection('post').doc() 来获取此条记录，这个 doc 用于获取指定的记录引用，返回的是这条数据，而不是一个数组。最后我们返回新创建的 post 。提示我们在上面创建 post 的时候，将 user 对象也添加到了 post 数据中，这里是因为小程序云数据库是 JSON 数据库,所以没有关系数据库的外键概念,导致建关系困难,所以为了之后查询 post 的时候方便展示 user 数据，我们才这样保存的. 当然更加科学的做法是在 post 里面保存 userId ，这样能减少数据冗余，但是因为做教学用，所以这些我们偷了一点懒。所以我们这里强烈建议,在正规的环境下，关系型数据库应该建外键，JSON 数据库也至少应该保存 userId 。:第六剑： 定义对应的 reducers 文件我们在前面处理创建帖子时，在组件内部 dispatch 了 CREATE_POST action，在处理异步 action 的 saga 函数中，使用 put 发起了一系列更新 store 中帖子状态的 action，现在我们马上来实现响应这些 action 的 reducers ，打开 src/reducers/post.js ，对其中的代码做出对应的修改如下：import {\r\n  SET_POST,\r\n  SET_POSTS,\r\n  SET_POST_FORM_IS_OPENED,\r\n  POST_ERROR,\r\n  CREATE_POST,\r\n  POST_NORMAL,\r\n  POST_SUCCESS,\r\n} from '../constants/'\r\n\r\nimport avatar from '../images/avatar.png'\r\n\r\nconst INITIAL_STATE = {\r\n  posts: [],\r\n  post: {},\r\n  isOpened: false,\r\n  isPost: false,\r\n  postStatus: POST_NORMAL,\r\n}\r\n\r\nexport default function post(state = INITIAL_STATE, action) {\r\n  switch (action.type) {\r\n    case SET_POST: {\r\n      const { post } = action.payload\r\n      return { ...state, post }\r\n    }\r\n\r\n    case SET_POSTS: {\r\n      const { posts } = action.payload\r\n      return { ...state, posts: state.posts.concat(...posts) }\r\n    }\r\n\r\n    case SET_POST_FORM_IS_OPENED: {...      return { ...state, isOpened }\r\n    }\r\n\r\n    case CREATE_POST: {\r\n      return { ...state, postStatus: CREATE_POST, isPost: true }\r\n    }\r\n\r\n    case POST_SUCCESS: {\r\n      return { ...state, postStatus: POST_SUCCESS, isPost: false }\r\n    }\r\n\r\n    case POST_ERROR: {\r\n      return { ...state, postStatus: POST_ERROR, isPost: false }\r\n    }\r\n\r\n    default:\r\n      return state\r\n  }\r\n复制代码看一看到上面的代码主要有三处改动：首先我们导入了必要的 action 常量接着我们给 INITIAL_STATE 增加了几个字段：posts\r\npost\r\nisPost ：用于标志帖子逻辑过程中是否在执行创帖逻辑， true 表示正在执行创帖中， false 表示登录逻辑执行完毕postStatus ：用于标志创帖过程中的状态：开始创帖（ CREATE_POST ）、创帖成功（ POST_SUCCESS ）、登录失败（ POST_ERROR ）最后就是 switch 语句中响应 action，更新相应的状态。“六脉神剑” 搞定 getPosts 异步逻辑在上一 “大” 节中，我们使用了图雀社区不传之术：“六脉神剑” 搞定了 createPost 的异步逻辑，现在我们马上趁热打铁来巩固我们的武功，搞定 getPosts 异步逻辑，它对应着我们小程序底部两个 tab 栏的第一个，也就是我们打开小程序的首屏渲染逻辑，也就是一个帖子列表。第一剑： index 组件中发起异步请求打开 src/pages/index/index.jsx 文件，对其中的内容作出对应的修改如下：import { PostCard, PostForm } from '../../components'\r\nimport './index.scss'\r\nimport {\r\n  SET_POST_FORM_IS_OPENED,\r\n  SET_LOGIN_INFO,\r\n  GET_POSTS,\r\n} from '../../constants'\r\n\r\nexport default function Index() {\r\n  const posts = useSelector(state => state.post.posts) || []...  const dispatch = useDispatch()\r\n\r\n  useEffect(() => {\r\n    const WeappEnv = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n\r\n    if (WeappEnv) {\r\n      Taro.cloud.init()\r\n    }\r\n\r\n    async function getStorage() {\r\n      try {\r\n        const { data } = await Taro.getStorage({ key: 'userInfo' })\r\n\r\n        const { nickName, avatar, _id } = data\r\n\r\n        // 更新 Redux Store 数据\r\n        dispatch({\r\n          type: SET_LOGIN_INFO,\r\n          payload: { nickName, avatar, userId: _id },\r\n        })\r\n      } catch (err) {\r\n        console.log('getStorage ERR: ', err)\r\n      }\r\n    }\r\n\r\n    if (!isLogged) {\r\n      getStorage()\r\n    }\r\n\r\n    async function getPosts() {\r\n      try {\r\n        // 更新 Redux Store 数据\r\n        dispatch({\r\n          type: GET_POSTS,\r\n        })\r\n      } catch (err) {\r\n        console.log('getPosts ERR: ', err)\r\n      }\r\n    }\r\n\r\n    if (!posts.length) {\r\n      getPosts()\r\n    }\r\n  }, [])\r\n\r\n  function setIsOpened(isOpened) {\r\n    dispatch({ type: SET_POST_FORM_IS_OPENED, payload: { isOpened } })...  return (\r\n    <View className=\"index\">\r\n      <AtMessage />\r\n      {posts.map(post => (\r\n        <PostCard key={post._id} postId={post._id} post={post} isList />\r\n      ))}\r\n      <AtFloatLayout\r\n        isOpened={isOpened}\r\n复制代码可以看到，上面的内容做了如下四处修改：首先我们对当前的开发环境做了判断，如果是微信小程序环境，我们就使用 Taro.cloud.init() 进行小程序环境的初始化。接着，我们在 useEffects Hooks 里面定义了 getPosts 函数，它是一个异步函数，用于 dispatch GET_POSTS 的异步请求，并且我们进行了判断，当此时 Redux Store 内部没有文章时，才进行数据的获取。接着，我们改进了 getStorage 获取缓存的函数，将其移动到 useEffects Hooks 里面，并额外增加了 _id 属性，它被赋值给 userId 一起设置 Redux Store 中关于用户的属性，这样做的目的主要是为了之后发帖标志用户，或者获取用户的个人信息用。并且，加了一层 if 判断，只有当没有登录时，即 isLogged 为 false 的时候，才进行获取缓存操作。最后我们导入了必要的 GET_POSTS 常量，并且将 return 语句里的 PostCard 接收的 key 和 postId 属性变成了真实的帖子 _id 。这样我们在帖子详情时可以直接拿 postId 向小程序云发起异步请求。注意在上一篇教程中，有同学提到没有使用 Taro.cloud.init() 初始化的问题，是因为分成了两篇文章，在这篇文章才初始化。要使用小程序云，初始化环境是必要的。第二剑：声明和补充对应需要的异步 sagas 文件在 “第一剑” 中，我们从组件中 dispatch 了 action.type 为 GET_POSTS 的异步 Action，接下来我们要做的就是在对应的 sagas 文件中补齐响应这个异步 action 的 sagas。打开 src/sagas/post.js 文件，在其中定义 getPosts sagas 逻辑如下：import {\r\n  GET_POSTS,\r\n} from '../constants'\r\n\r\nfunction* getPosts() {\r\n  try {\r\n    const posts = yield call(postApi.getPosts)\r\n\r\n    // 其实以下三步可以合成一步，但是这里为了讲解清晰，将它们拆分成独立的单元\r\n\r\n    // 发起获取帖子成功的 action\r\n    yield put({ type: POST_SUCCESS })\r\n\r\n    // 更新 Redux store 数据\r\n    yield put({\r\n      type: SET_POSTS,\r\n      payload: {\r\n        posts,\r\n      },\r\n    })\r\n  } catch (err) {\r\n    console.log('getPosts ERR: ', err)\r\n\r\n    // 获取帖子失败，发起失败的 action\r\n    yield put({ type: POST_ERROR })\r\n  }\r\n}\r\nfunction* watchGetPosts() {\r\n  while (true) {\r\n    yield take(GET_POSTS)\r\n\r\n    yield fork(getPosts)\r\n  }\r\n}\r\n\r\nexport { watchGetPosts }\r\n复制代码可以看到，上面的改动主要是创建 watcherSaga 和 handlerSaga 。创建 watcherSaga我们创建了登录的 watcherSaga ： watchGetPosts ，它用来监听 action.type 为 GET_POSTS的 action，并且当监听到 GET_POSTS action 之后，然后激活 handlerSaga ： getPosts 去处理对应的获取帖子列表的逻辑。这里的 watcherSaga ： watchGetPosts 是一个生成器函数，它内部是一个 while 无限循环，表示在内部持续监听 GET_POSTS action。在循环内部，我们使用了 redux-saga 提供的 effects helper 函数： take ，它用于监听 GET_POSTS action，获取 action 中携带的数据。接着我们使用了另外一个 effects helper 函数： fork ，它表示非阻塞的执行 handlerSaga： getPosts ，因为这里获取帖子列表不需要传数据，所以这里没有额外的数据传递逻辑。创建 handlerSaga我们创建了创建帖子的 handlerSaga ： getPosts ，它用来处理创建逻辑。getPosts 也是一个生成器函数，在它内部是一个 try/catch 语句，用于处理获取帖子列表请求可能存在的错误情况。在 try 语句中，首先是使用了 redux-saga 提供给我们的 effects helper 函数： call 来调用登录的 API： postApi. getPosts 。如果获取帖子列表成功，我们使用 redux-saga 提供的 effects helpers 函数： put ， put 类似之前在 view 中的 dispatch 操作，，来 dispatch 了两个 action： POST_SUCCESS ， SET_POSTS ，代表更新获取帖子列表成功的状态，设置最新获取的帖子列表到 Redux Store 中。如果获取帖子列表失败，我们则使用 put 发起一个 POST_ERROR 的 action 来更新获取帖子列表失败的信息到 Redux Store一些额外的工作为了创建 watcherSaga 和 handlerSaga ，我们还导入了 postApi. getPosts ，我们将在后面来创建这个 API。除此之外我们还导入了需要使用的 action 常量：GET_POSTS ：响应获取帖子列表的 ACTION 常量，我们将在 “第三剑” 中创建它。加入 saga 中心调度文件我们像之前将 watchCreatePost 等加入到 sagas 中心调度文件一样，将我们创建好的 watchGetPosts 也加入进去：// ...之前的逻辑\r\nimport { watchGetPosts } from './post'\r\nexport default function* rootSaga() {\r\n  yield all([\r\n   // ... 之前的逻辑\r\n    fork(watchGetPosts)\r\n  ])\r\n}\r\n复制代码第三剑：定义 sagas 需要的常量文件打开 src/constants/post.js 文件，定义我们之前创建的常量文件如下：export const GET_POSTS = 'GET_POSTS'\r\n复制代码第四剑：定义 sagas 涉及到的前端 API 文件在之前的 post saga 文件里面，我们使用到了 postApi.getPosts ，它里面封装了用于向后端（这里我们是小程序云）发起和获取帖子列表有关请求的逻辑，让我们马上来实现它吧。打开 src/api/post.js 文件，并在其中编写内容如下：// ... 其余逻辑一样\r\nasync function getPosts() {\r\n  const isWeapp = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n  const isAlipay = Taro.getEnv() === Taro.ENV_TYPE.ALIPAY\r\n\r\n  // 针对微信小程序使用小程序云函数，其他使用小程序 RESTful API\r\n  try {\r\n    if (isWeapp) {\r\n      const { result } = await Taro.cloud.callFunction({\r\n        name: 'getPosts',\r\n      })\r\n\r\n      return result.posts\r\n    }\r\n  } catch (err) {\r\n    console.error('getPosts ERR: ', err)\r\n  }\r\n}\r\n\r\nconst postApi = {\r\n  // ... 之前的 API\r\n  getPosts,\r\n}\r\n\r\n// ... 其余逻辑一样\r\n复制代码在上面的代码中，我们定义了 getPosts 函数，它是一个 async 函数，用来处理异步逻辑，在 getPosts 函数中，我们对当前的环境进行了判断，且只在微信小程序，即 isWeapp 的条件下执行获取帖子列表的操作，对于支付宝小程序和 H5，我们则放在下一节使用 LeanCloud 的 Serverless 来解决。创建帖子逻辑是一个 try/catch 语句，用于捕捉可能存在的请求错误，在 try 代码块中，我们使用了 Taro 为我们提供的微信小程序云的云函数 API Taro.cloud.callFunction 来便捷的向小程序云发起云函数调用请求。这里我们调用了一个 getPosts 云函数，我们将在下一节中实现这个云函数。如果调用成功，我们可以接收返回值，用于从后端返回数据，这里我们返回了 result.posts数据，即从小程序云返回的帖子列表。如果调用失败，则打印错误。最后我们在已经定义好的 postApi 对象里，添加 getPosts API 属性然后将其导出，这样在 post saga 函数里面就可以导入 postApi 然后通过 postApi. getPosts 的方式来调用 getPosts API 处理获取帖子列表的逻辑了。第五剑：创建对应的微信小程序云函数创建 getPosts 云函数按照和之前创建 createPost 云函数类似，我们创建 getPosts 云函数。创建成功之后，我们可以得到两个文件，一个是 functions/getPosts/package.json 文件，它和之前的类似。{\r\n  \"name\": \"getPosts\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"wx-server-sdk\": \"latest\"\r\n  }\r\n}\r\n复制代码第二个文件就是我们需要编写创建帖子逻辑的 functions/getPosts/index.js 文件，微信小程序开发者工具会默认为我们生成一段样板代码。我们在 function/getPosts 文件夹下同样运行 npm install 安装对应的云函数依赖，这样我们才能运行它。编写 getPosts 云函数打开 functions/getPosts/index.js 文件，对其中的内容作出对应的修改如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init({\r\n  env: cloud.DYNAMIC_CURRENT_ENV,\r\n})\r\n\r\nconst db = cloud.database()\r\nconst _ = db.command\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  try {\r\n    const { data } = await db.collection('post').get()\r\n\r\n    return {\r\n      posts: data,\r\n    }\r\n  } catch (e) {\r\n    console.error(`getPosts ERR: ${e}`)\r\n  }\r\n}\r\n复制代码可以看到上面的代码改动主要有以下处：首先我们给 cloud.init() 传入了环境参数，我们使用了内置的 cloud.DYNAMIC_CURRENT_ENV，表示自动设置为当前的云环境，即在右键点击小程序开发者工具里 functions 文件夹时选择的环境。接着，我们通过 cloud.database() 生成了数据实例 db ，用于之后在函数体中便捷的操作云数据库。接着就是 main 函数体，里面是一个 try/catch 语句块，用于捕获错误，在 try 语句块中，我们使用 db 的查询操作： db.collection('post').get() ，表示查询所有的 post 数据。最后我们返回查询到的 posts 数据。第六剑： 定义对应的 reducers 文件因为这里 SET_POSTS 的 Action 我们在上一 “大” 节中创建帖子时已经定义了，所有在 “这一剑” 中我们无需添加额外的代码，复用之前的逻辑就好。“六脉神剑” 搞定 getPost 异步逻辑在上面两 “大” 节中，我们连续用了两次 “六脉神剑”，相信跟到这里的同学应该对我们接下来要做的事情已经轻车熟路了吧:grin:。接下来，我们将收尾 Post 逻辑的最后一公里，即帖子详情的异步逻辑 “getPost” 接入，话不多说就是干！第一剑： post 组件中发起异步请求打开 src/pages/post/post.jsx 文件，对其中的内容作出对应的修改如下：import Taro, { useRouter, useEffect } from '@tarojs/taro'\r\nimport { View } from '@tarojs/components'\r\nimport { useDispatch, useSelector } from '@tarojs/redux'\r\n\r\nimport { PostCard } from '../../components'\r\nimport './post.scss'\r\nimport { GET_POST, SET_POST } from '../../constants'\r\n\r\nexport default function Post() {\r\n  const router = useRouter()\r\n  const { postId } = router.params\r\n\r\n  const dispatch = useDispatch()\r\n  const post = useSelector(state => state.post.post)\r\n\r\n  useEffect(() => {\r\n    dispatch({\r\n      type: GET_POST,\r\n      payload: {\r\n        postId,\r\n      },\r\n    })\r\n\r\n    return () => {\r\n      dispatch({ type: SET_POST, payload: { post: {} } })\r\n    }\r\n  }, [])\r\n\r\n  return (\r\n    <View className=\"post\">\r\n复制代码可以看到，上面的内容做了如下四处修改：首先我们使用 useDispatch Hooks 获取到了 dispatch 函数。接着，在 useEffects Hooks 里面定义了 dispatch 了 action.type 为 GET_POST 的 action，它是一个异步 Action，并且我们在 Hooks 最后返回了一个函数，其中的内容为将 post 设置为空对象，这里用到的 SET_POST 常量我们将在后面定义它。这个返回函数主要用于 post 组件卸载之后，Redux Store 数据的重置，避免下次打开帖子详情还会渲染之前获取到的帖子数据。接着，我们使用 useSelector Hooks 来获取异步请求到的 post 数据，并用于 return 语句中的数据渲染。最后我们删除了不必要的获取 posts 数据的 useSelector Hooks，以及删掉了不必要的调试 console.log 语句。第二剑： 声明和补充对应需要的异步 sagas 文件在 “第一剑” 中，我们从组件中 dispatch 了 action.type 为 GET_POST 的异步 Action，接下来我们要做的就是在对应的 sagas 文件中补齐响应这个异步 action 的 sagas。打开 src/sagas/post.js 文件，在其中定义 getPosts sagas 逻辑如下：// ... 和之前的逻辑一样\r\nimport {\r\n  // ... 和之前的逻辑一样\r\n  SET_POST,\r\n} from '../constants';\r\n\r\n  // ... 和之前的逻辑一样\r\n\r\nfunction* getPost(postId) {\r\n  try {\r\n    const post = yield call(postApi.getPost, postId)\r\n\r\n    // 其实以下三步可以合成一步，但是这里为了讲解清晰，将它们拆分成独立的单元\r\n\r\n    // 发起获取帖子成功的 action\r\n    yield put({ type: POST_SUCCESS })\r\n\r\n    // 更新 Redux store 数据\r\n    yield put({\r\n      type: SET_POST,\r\n      payload: {\r\n        post,\r\n      },\r\n    })\r\n  } catch (err) {\r\n    console.log('getPost ERR: ', err)\r\n\r\n    // 获取帖子失败，发起失败的 action\r\n    yield put({ type: POST_ERROR })\r\n  }\r\n}\r\nfunction* watchGetPost() {\r\n  while (true) {\r\n    const { payload } = yield take(GET_POST)\r\n\r\n    yield fork(getPost, payload.postId)\r\n  }\r\n}\r\n\r\nexport { watchGetPost }\r\n复制代码可以看到，上面的改动主要是创建 watcherSaga 和 handlerSaga 。创建 watcherSaga我们创建了登录的 watcherSaga ： watchGetPost ，它用来监听 action.type 为 GET_POST的 action，并且当监听到 GET_POST action 之后，然后激活 handlerSaga ： getPost 去处理对应的获取单个帖子的逻辑。这里的 watcherSaga ： watchGetPost 是一个生成器函数，它内部是一个 while 无限循环，表示在内部持续监听 GET_POST action。在循环内部，我们使用了 redux-saga 提供的 effects helper 函数： take ，它用于监听 GET_POST action，获取 action 中携带的数据，这里我们拿到了传过来的 payload 数据。接着我们使用了另外一个 effects helper 函数： fork ，它表示非阻塞的执行 handlerSaga： getPost ，并传入了获取到 payload.postId 参数。创建 handlerSaga我们创建了获取单个帖子的 handlerSaga ： getPost ，它用来处理获取帖子逻辑。getPost 也是一个生成器函数，在它内部是一个 try/catch 语句，用于处理获取单个帖子请求可能存在的错误情况。在 try 语句中，首先是使用了 redux-saga 提供给我们的 effects helper 函数： call 来调用登录的 API： postApi. getPost 。如果获取单个帖子成功，我们使用 redux-saga 提供的 effects helpers 函数： put ， put 类似之前在 view 中的 dispatch 操作，，来 dispatch 了两个 action： POST_SUCCESS ， SET_POSTS ，代表更新获取单个帖子成功的状态，设置最新获取的帖子到 Redux Store 中。如果获取单个帖子失败，我们则使用 put 发起一个 POST_ERROR 的 action 来更新获取单个帖子失败的信息到 Redux Store一些额外的工作为了创建 watcherSaga 和 handlerSaga ，我们还导入了 postApi.getPost ，我们将在后面来创建这个 API。除此之外我们还导入了需要使用的 action 常量：SET_POST ：响应获取帖子列表的 ACTION 常量，我们将在 “第三剑” 中创建它加入 saga 中心调度文件我们像之前将 watchGetPosts 等加入到 sagas 中心调度文件一样，将我们创建好的 watchGetPost 也加入进去：打开 src/sagas/index.js 文件，对其中的内容作出如下的修改：import { fork, all } from 'redux-saga/effects'\r\n\r\nimport { watchLogin } from './user'\r\nimport { watchCreatePost, watchGetPosts, watchGetPost } from './post'\r\n\r\nexport default function* rootSaga() {\r\n  yield all([\r\n    fork(watchLogin),\r\n    fork(watchCreatePost),\r\n    fork(watchGetPosts),\r\n    fork(watchGetPost),\r\n  ])\r\n}\r\n复制代码第三剑：定义 sagas 需要的常量文件打开 src/constants/post.js 文件，定义我们之前创建的常量文件 GET_POST ：export const SET_POST = 'SET_POST'\r\n复制代码第四剑：定义 sagas 涉及到的前端 API 文件在之前的 post saga 文件里面，我们使用到了 postApi.getPost ，它里面封装了用于向后端（这里我们是小程序云）发起和获取单个帖子有关请求的逻辑，让我们马上来实现它吧。打开 src/api/post.js 文件，并在其中编写内容如下：// ... 其他内容和之前一致\r\nasync function getPost(postId) {\r\n  const isWeapp = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n  const isAlipay = Taro.getEnv() === Taro.ENV_TYPE.ALIPAY\r\n\r\n  // 针对微信小程序使用小程序云函数，其他使用小程序 RESTful API\r\n  try {\r\n    if (isWeapp) {\r\n      const { result } = await Taro.cloud.callFunction({\r\n        name: 'getPost',\r\n        data: {\r\n          postId,\r\n        },\r\n      })\r\n\r\n      return result.post\r\n    }\r\n  } catch (err) {\r\n    console.error('getPost ERR: ', err)\r\n  }\r\n}\r\n\r\nconst postApi = {\r\n  getPost,\r\n}\r\nexport default postApi\r\n复制代码可以看到上面的代码有如下六处改动：在上面的代码中，我们定义了 getPost 函数，它是一个 async 函数，用来处理异步逻辑，在 getPost 函数中，我们对当前的环境进行了判断，且只在微信小程序，即 isWeapp 的条件下执行获取单个帖子的操作，对于支付宝小程序和 H5，我们则放在下一节使用 LeanCloud 的 Serverless 来解决。创建帖子逻辑是一个 try/catch 语句，用于捕捉可能存在的请求错误，在 try 代码块中，我们使用了 Taro 为我们提供的微信小程序云的云函数 API Taro.cloud.callFunction 来便捷的向小程序云发起云函数调用请求。这里我们调用了一个 getPost 云函数，并给它传递了对应要获取的帖子的 postId 我们将在下一节中实现这个云函数。如果调用成功，我们可以接收返回值，用于从后端返回数据，这里我们返回了 result.post数据，即从小程序云返回的单个帖子。如果调用失败，则打印错误。最后我们在已经定义好的 postApi 对象里，添加 getPost API 属性然后将其导出，这样在 post saga 函数里面就可以导入 postApi 然后通过 postApi. getPost 的方式来调用 getPostAPI 处理获取单个帖子的逻辑了。第五剑：创建对应的微信小程序云函数创建 getPost 云函数按照和之前创建 getPosts 云函数类似，我们创建 getPost 云函数。创建成功之后，我们可以得到两个文件，一个是 functions/getPost/package.json 文件，它和之前的类似。{\r\n  \"name\": \"getPost\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"wx-server-sdk\": \"latest\"\r\n  }\r\n}\r\n复制代码第二个文件就是我们需要编写创建帖子逻辑的 functions/getPost/index.js 文件，微信小程序开发者工具会默认为我们生成一段样板代码。我们在 function/getPost 文件夹下同样运行 npm install 安装对应的云函数依赖，这样我们才能运行它。编写 getPost 云函数打开 functions/getPost/index.js 文件，对其中的内容作出对应的修改如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init({\r\n  env: cloud.DYNAMIC_CURRENT_ENV,\r\n})\r\n\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const { postId } = event\r\n\r\n  try {\r\n    const { data } = await db\r\n      .collection('post')\r\n      .doc(postId)\r\n      .get()\r\n\r\n    return {\r\n      post: data,\r\n    }\r\n  } catch (e) {\r\n    console.error(`getPost ERR: ${e}`)\r\n  }\r\n}\r\n复制代码可以看到上面的代码改动主要有以下处：首先我们给 cloud.init() 传入了环境参数，我们使用了内置的 cloud.DYNAMIC_CURRENT_ENV，表示自动设置为当前的云环境，即在右键点击小程序开发者工具里 functions 文件夹时选择的环境。接着，我们通过 cloud.database() 生成了数据实例 db ，用于之后在函数体中便捷的操作云数据库。接着就是 main 函数体，里面是一个 try/catch 语句块，用于捕获错误，在 try 语句块中，我们首先从 event 对象里面获取到了 postId ，接着我们使用 db 的查询操作： db.collection('post').doc(postId).get() ，表示查询所有的对应 _id 为 postId 的单个帖子数据最后我们返回查询到的 post 数据。第六剑： 定义对应的 reducers 文件因为这里 SET_POST 的 Action 我们在上上 “大” 节中创建帖子时已经定义了，所有在 “这一剑” 中我们无需添加额外的代码，复用之前的逻辑就好。小结在这篇教程中，我们连续使用了三次 “六脉神剑” 讲完了我们的 Post 逻辑的异步流程，让我们再来复习一下我们开头提到的 “六脉神剑”：sagas\r\nsagas\r\nsagas\r\nreducers\r\n这是一套讲解模式，也是一套写代码的最佳实践方式之一，希望你能受用。" } { "title": "小程序跨页面交互的作用与方法 ", "author": "Rolan", "pub_time": "2020-1-7 00:24", "content": "去年年末，微信小程序的分包大小已经到达了 12M 大小,一方面说明小程序的确逐步为开发者放开更大的权限，另一方面也说明了对于某些小程序 8M 的大小已经不够用了。我个人今年也是在开发一个 to B 小程序应用。这里列举一些跨页面交互的场景。对于 B 端应用的业务需求来说，小程序开发的复杂度相对比网页开发要复杂一些。一个是双线程的处理机制问题，另一个是页面栈之间交互问题。注: 笔者目前只需要开发微信小程序，为了在小程序页面中可以使用 properties behaviors observers 等新功能，已经使用 Component 构造器来构造页面。具体可以参考\t微信小程序 Component 构造器 。如果你也没有多端开发的需求，建议尝试使用，可以得到不错的体验。性能优化类对于小程序在页面中点击触发 wx.navigateTo 跳转其他页面，中间会有一段时间的空白加载期(对于分包出去的页面，空白期则会更长)，但是这是小程序内部机制，没有办法进行优化。我们只能眼睁睁的等待这段没有意思的空白期过去。当考虑到跳转页面后的第一件事情便是取数逻辑，那么我们是否能够进行优化呢？答案是肯定的。我们没有办法直接在当前页面取得数据之后再进行跳转操作(这样操作更不好)，但是我们却可以利用缓存当前的请求，详情可以参考我之前的博客文章 ——\tPromise对象 3 种妙用 。代码如下:const promiseCache = new Map()\r\n\r\nexport function setCachePromise(key, promise) {\r\n  promiseCache.set(key, promise)\r\n}\r\n\r\nexport function getCachePromise(key) {\r\n  // 根据key获取当前的数据  \r\n  const promise = promiseCache.get(key)\r\n  // 用完删除，目前只做中转用途，也可以添加其他用途\r\n  promiseCache.delete(key)\r\n  return promise  \r\n}做一份全局的 Map,然后利用 Map 缓存 promise 对象，在跳转之前代码为:// 导入 setCachePromise 函数\r\n\r\nComponent({\r\n  methods: {\r\n    getBookData(id) {\r\n      const promise = // promise 请求\r\n        setCachePromise(`xxx:${id}`, promise)      \r\n    },  \r\n    handleBookDetailShow(e) {\r\n      const id = e.detail\r\n      this.getBookData(id)\r\n       wx.navigateTo({url: `xx/xx/x?id=${id}`})\r\n    }\r\n  }\r\n})而跳转之后的代码也如下所示:// 导入 getCachePromise 函数\r\n\r\nComponent({\r\n    properties: {\r\n      id: Number  \r\n    },\r\n    lifetimes: {\r\n      attached () {\r\n        const id = this.data.id  \r\n        // 取得全局缓存的promise\r\n        const bookPromise = getCachePromise(`xxx:${id}`)\r\n        bookPromise.then((res) => {\r\n          // 业务处理\r\n        }).catch(error => {\r\n          // 错误处理  \r\n        })\r\n      }\r\n    },\r\n    methods: {\r\n      getBook() {\r\n        // 获取数据，以便于 错误处理 上拉刷新 等操作  \r\n      }  \r\n    }\r\n})如此便可以同时处理取数和页面加载的逻辑，当然，这个对于页面有耦合性，不利于后续的删除与修改。但考虑如果仅仅加在分包跳转之间可能会有不错的效果。想要无侵入式，可以进一步学习研究\t微信小程序之提高应用速度小技巧 以及\twxpage 框架，同时考虑到无论是 ToC 还是 ToC 用户，都有可能存在硬件以及网络环境等问题，该优化还是非常值得的。当然微信小程序为了减少冷启动时间，提供了\t周期性更新 数据预拉取 功能。注: 上面的 promiseCache 只作为中转的用途，不作为缓存的用途，如果你考虑添加缓存，可以参考我之前的博客文章——\t前端 api 请求缓存方案 。通知类如果是 pc 端中进行交互，对于数据的 CRUD。例如在详情页面进行了数据的修改和删除，返回列表时候就直接调取之前存储的列表查询条件再次查询即可，而对于移动端这种下拉滚动的设计，就没有办法直接调用之前的查询条件来进行搜索。如果从列表页面进入详情页面后，在详情页面只会进行添加或者修改操作。然后返回列表页面。此时可以提示用户数据已经进行了修改，请用户自行决定是否进行刷新操作。如在编辑页面修改了数据:const app = getApp()\r\n\r\ncomponent({\r\n  methods: {\r\n    async handleSave() {\r\n      //...\r\n      app.globalData.xxxChanged = true\r\n      //...  \r\n    }\r\n  }\r\n})列表界面:const app = getApp()\r\n\r\ncomponent({\r\n  pageLifetimes: {\r\n    show() {\r\n      this.confirmThenRefresh()\r\n    }    \r\n  },\r\n  methods: {\r\n    confirmThenRefresh() {\r\n      // 检查 globalData，如果当前没有进行修改，直接返回 \r\n      if(!app.globalData.xxxChanged) return\r\n      wx.showModal({\r\n        // ...\r\n        complete: () => {\r\n          // 无论确认刷新与否，都把数据置为 false \r\n          app.globalData.xxxChanged = false  \r\n        }  \r\n      })  \r\n    }\r\n  }  \r\n})当然了，我们也可以利用 wx.setStorage 或者 getCurrentPage 获取前面的页面 setData 来进行数据通知,以便用户进行页面刷新。订阅发布类如果仅仅只涉及到修改数据的前提下，我们可以选择让用户进行刷新操作，但是如果针对于删除操作而言，如果用户选择不进行刷新，然后用户又不小心点击到了已经被删除的数据，就会发生错误。所以如果有删除的需求，我们最好在返回列表页面前就进行列表的修改，以免造成错误。mittgithub 上有很多的 pub/sub 开源库，如果没有什么特定的需求，找到代码量最少的就是\tmitt 这个库了,作者是喜欢开发微型库的\tdevelopit 大佬,著名的\tpreact 也是出于这位大佬之手。 这里就不做过多的介绍，非常简单。大家可能都能看明白，代码如下(除去 flow 工具的检查):export default function mitt(all) {\r\n  all = all || Object.create(null);\r\n\r\n  return {\r\n    on(type, handler) {\r\n      (all[type] || (all[type] = [])).push(handler);\r\n    },\r\n\r\n    off(type, handler) {\r\n      if (all[type]) {\r\n        all[type].splice(all[type].indexOf(handler) >>> 0, 1);\r\n      }\r\n    },\r\n    emit(type, evt) {\r\n      (all[type] || []).slice().map((handler) => { handler(evt); });\r\n      (all['*'] || []).slice().map((handler) => { handler(type, evt); });\r\n    }\r\n  };\r\n}仅仅只有3个方法，on emit以及 off。只要在多个页面导入 生成的 mitt() 函数生成的对象即可(或者直接放入 app.globalData 中也可)。Component({\r\n  lifetimes: {\r\n    attached: function() {\r\n      // 页面创建时执行\r\n      const changeData = (type, data) => {\r\n        // 处理传递过来的类型与数据\r\n      }\r\n      this._changed = changeData\r\n      bus.on('xxxchanged', this._changed)\r\n    },\r\n    detached: function() {\r\n      // 页面销毁时执行\r\n      bus.off('xxxchanged', this._changed)\r\n    }\r\n  }\r\n})这里mitt可以有多个页面进行绑定事件，如果需求仅仅只涉及到两个页面之间，我们就可以使用 wx.navigateTo 中的 EventChannel (页面间事件信息通道)。可以参考\t微信小程序wx.navigateTo方法里的events参数使用详情及场景 ,该方案的利好在于，传递到下一个页面的参数也可以通过 EventChannel 来通知，以便于解决 properties 传递数据不宜过大的问题。注: 一个页面展示很多信息的时候，会造成小程序页面的卡顿以及白屏。小程序官方也有长列表组件\trecycle-view 。有需求的情况下可以自行研究，这个不在这里详述。鼓励一下如果你觉得这篇文章不错，希望可以给与我一些鼓励，在我的 github 博客下帮忙 star 一下。博客地址参考文档微信小程序 Component 构造器微信小程序之提高应用速度小技巧wxpagemittPromise对象 3 种妙用前端 api 请求缓存方案" } { "title": "从客户端角度窥探小程序架构 ", "author": "Rolan", "pub_time": "2020-1-7 00:42", "content": "小程序自诞生以来。就以一种百家争鸣的姿态展现在开发者的面前。继2017年1月9日微信小程序诞生后，小程序市场又陆续出现了支付宝小程序、头条小程序、百度智能小程序等等，甚至平安内部，也在发展自己的小程序生态。各家都在微信小程序的基础上，面向自己的业务，对架构进行逐步优化调整，但是万变不离其宗，微信小程序终归为小程序鼻祖，也是得益于微信小程序的思想，才造就了如今这百花齐放的业态。说起微信小程序，在体验上的优化，让我很长一段时间认为，这是 Native 层渲染。事实并不完全是，至今不敢相信，webView 的渲染竟能带来如此体验。本篇主要以一个客户端开发者的角度，来对微信小程序、支付宝小程序一探究竟。本篇旨在原理分析，我并未有真实的小程序架构设计经验。说到小程序，不得不需要指出另外一个问题，苹果爸爸 对于 HTML5 app 的更新 的审核问题，目前会有开发者存在这样的疑问，Hybrid 和 H5 是不是要被苹果拒审了呢？其实从更新描述来看，不难发现苹果的主要目的是针对 “核心功能未在二进制文件内” 的 App ，实际上小程序无论是在设计理念上，还是核心技术上，都不存在这样的问题，小程序并非App，小程序是以 App 为载体，尽可能的对 web 页面进行优化而生成的产物。还有一点是 马甲包 日益猖獗，马甲包最后基本都转化成为了条款内描述的 “现金Bocai、彩票抽奖和慈善捐款” 类型，所以苹果想要尽可能的禁止它。而且从微信小程序开发文档来看，微信小程序是典型的 技术推动产品的结果 。关于RN类技术，更不存在这样的问题了，RN本质为 JS 通过 JSCore 调用 Native 组件。实际上它的核心仍然在 Native 端，当然对 code push 我还尚存疑问。关于 RN 的动态更新上，从 bang's 的描述也不难发现苹果爸爸的态度， 只要不是为了绕过审核去做动态更新就可以接受 。二、从微信小程序的发展史说起微信小程序是什么，微信把小程序定义为是 一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验 。便捷和出色有何而来？小程序技术最初来源于 H5 和 Native 间的简单调用，微信构建了一个 WeixinJSBridge 来为H5提供一些 Native 的功能，例如地图、播放器、定位、拍照、预览等功能。关于 Bridge 的具体实现可以参考之前的文章 写一个易于维护使用方便性能可靠的Hybrid框架 。但是微信逐渐的又遇到了另外一个问题，那就 H5 页面的体验问题，微信团队为了解决 H5 页面的白屏问题，他们引入了最近很火的 离线包 概念，当然微信称之为 微信 Web 资源离线存储 ，实际上是一个东西。Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页的加载时间。关于离线包的概念，不了解的话可以参考下我之前的文章 iOS 性能优化 -- H5离线秒开 。但是当页面加载大量 CSS 和 JS 时，依然会有白屏问题，包括 H5 页面点击事件的迟钝感和页面跳转的体验问题。那么基于此问题，应运而生的，小程序技术就诞生了。从微信小程序的发展史，不难看出，小程序实际上是近几年开发者对 H5 体验优化而来的，这也切合了前面所说的， 小程序实际上是典型的技术推动产品的结果 。三、微信小程序原理分析微信小程序自称能够解决以下问题：快速的加载。更强大的能力。原生的体验。易用且安全的微信数据开发。高效和简单的开发。快速加载和原生的体验，这其实都是在体验上的升级，更强大能力实际上源于微信小程序为开发者提供了大量的组件，这些组件有基于web技术，也有基于Native技术，在我看来这和 RN 技术不谋而合。后面我会举一个模仿 RN 实现的小例子来阐述一下它的原理。高效和简单的开发是因为微信小程序开发语言实质上还是基于 web 开发规范，这使得开发前端的人来开发小程序显得更容易。还有一点更重要的就是安全，为什么说小程序是安全的？后面会逐步展开，揭开小程序的神秘面纱。快速加载和原生的体验小程序的架构设计与 web 技术还是有一定的差别，吸取了 web 技术的一些优势，也摒弃了 web 技术中体验不好的地方。最主要的特点就是小程序采用双线程机制，即视图渲染和业务逻辑分别运行在不同的线程中。在传统的 web 开发中，网页开发渲染线程和脚本线程是互斥的，所以 H5 页面中长时间的脚本运行可能会导致页面失去响应或者白屏，体验糟糕。为了更好的体验，将页面渲染线程和脚本线程分开执行：渲染层：界面渲染相关的逻辑全部 在webView 线程内执行，一个小程序存在多个页面，一个页面对应一个 webView，微信小程序限制开发者最多只能创建五个页面。逻辑层：Android采用 JSCore ，iOS采用的 JavaScriptCore 框架运行 JS 脚本。怎么在 JavaScriptCore 运行脚本文件后面会讲。双线程模型是小程序框架与大多数前端 web 框架的不同之处，基于这个模型可以更好的管控以及提供更安全的环境。因为逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。客户端的开发者可能对 DOM 有些陌生，了解编译过程的同学应该知道在编译器编译代码的时候，会有一个语法分析的过程，生成抽象语法树 AST，编译器会根据语法树去检查表达式是否合法、括号是否匹配等。实际上DOM也是一种树结构，经过浏览器的解析，最终呈现在用户面前。通过 JavaScript 操纵 DOM 可以随意改变元素的位置，这对于小程序来说是极为不安全的。所以说逻辑层为小程序带来的另一个特点，易于管控和安全。线程通信基于前面提到的 WeixinJSBridge ：逻辑层把数据变化通知到视图层，触发视图层页面的更新，视图层把触发的事件通知到逻辑层进行业务处理。当我们对渲染层进行事件操作后，会通过 WeixinJSBridge 将数据传递到 Native 系统层。Native 系统层决定是否要用 Native 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 WeixinJSBridge 返给 View 层，View 渲染更新视图。渲染层根据 微信小程序开发者文档 描述， 在视图层内，小程序的每一个页面都独立运行在一个页面层级上。小程序启动时仅有一个页面层级，每次调用wx.navigateTo，都会创建一个新的页面层级；相对地，wx.navigateBack会销毁一个页面层级 。大概可以理解为，每个 web 页面都是运行在单独的 webView 里面，这样的好处就是让每个 webView 单纯的处理当前页面的渲染逻辑，不需要加载其他页面的逻辑代码，减轻负担能够加速页面渲染，使其能够尽可能的接近原生，这与小程序跳转页面的体验上也是一致的。实际上在小程序源码内有一个 index.html 文件的存在，这是小程序启动后的入口文件。初次加载的时候，主入口会加载相应的 webView ，这其中就会包括前面所提到的，视图层和逻辑层。逻辑层虽然也提供了 webView ，但是并不提供浏览器相关接口，而是单纯的为了获取当前的 JSCore ，执行相关的 JS 脚本文件，这也是开发小程序是没办法直接操作 DOM 的根本原因。当我们每打开一个新页面的时候，调用 navigateTo 都相当于打开了一个新的 webView ，这样一直打开，内存也会变得吃紧，这也是为什么小程序对页面打开数量有限制的原因了。预加载根据小程序开发文档描述： 对于每一个新的页面层级，视图层都需要进行一些额外的准备工作。在小程序启动前，微信会提前准备好一个页面层级用于展示小程序的首页。除此以外，每当一个页面层级被用于渲染页面，微信都会提前开始准备一个新的页面层级，使得每次调用wx.navigateTo都能够尽快展示一个新的页面 。这在客户端的角度来看，相当于打开新页面之后，对下一个页面的 webView 提前做了预加载，这个思路与当前比较流行的 webView 缓存池的思路不谋而合，原因是在 iOS 和 Android 系统上，操作系统启动 webView 都需要一小段时间，预加载会提升页面打开速度，优化白屏问题。基础库内部优化再往深层次来看，通过小程序开发工具的源码，能找到一个 pageframe.html 的模版文件，具体位置在 package.nw/html/pageframe.html ：看标题就应该很清楚了，这是渲染层的核心模块，它的作用就是为小程序准备一个新的页面，小程序每个视图层页面内容都是通过 pageframe.html 模板来生成的，包括小程序启动的首页。通过查看源码，里面定义了一个属性 var __webviewId__ ，我猜想这是每个 webView 页面的页面 ID ，逻辑层处理多个视图层间的业务逻辑可能就是通过这个ID来做的映射关系。在首次启动时，后台会缓存生成的 pageframe.html 模版，在后面的页面打开时，直接加载缓存的 pageframe.html 模版，页面引入的资源文件也可以直接在缓存中加载，包括小程序基础库视图层底层、页面的模版信息、配置信息以及样式等内容，这样避免重复生成，快速打开页面，提升页面渲染性能。注入小程序WXML结构和WXSS样式关于 pageframe.html 最后是怎么生成相应页面的归功于一个叫 nw.js 的框架，具体实现这里就不讲了，更多的偏向于前端的知识了。逻辑层上面了解了渲染层都做了什么之后，下面在窥探一下，小程序的逻辑层都做了什么。参考 eux.baidu.com/blog/fe/微信小… 不难发现，sevice 层的代码是由 WAService.js 实现的，逻辑层实际上主要提供了 Page， App，GetApp 接口和更为丰富 wx 接口模块，包括数据绑定、事件分发、生命周期管理、路由管理等等。关于视图层和逻辑层间的具体交互细节可以看下这张图：我们写的页面逻辑最后都被引入到了一个叫 appservice.html 的页面中，并且分别从 app.js 开始一一执行；小程序代码调用 Page 构造器的时候，小程序基础库会记录页面的基础信息，如初始数据（data）、方法等。需要注意的是，如果一个页面被多次创建，并不会使得这个页面所在的JS文件被执行多次，而仅仅是根据初始数据多生成了一个页面实例（this），在页面 JS 文件中直接定义的变量，在所有这个页面的实例间是共享的。对于逻辑层，从客户端的角度看，我们应该更关注于逻辑层的JS是怎么注入到JSCore中的。四、看看JavaScriptCore是怎么执行JS脚本的说到JavaScriptCore，我们先来讨论下Hybrid App 的构建思路，Hybird App是指混合模式移动应用，即其中既包含原生的结构又有内嵌有 Web 的组件。这种 App 不仅性能和用户体验可以达到和原生所差无几的程度，更大的优势在于 bug 修复快，版本迭代无需发版。Hybird App的实质并没有修改原 Native 的行为，而是将下发的资源进行加载和界面渲染，类似 WebView。下面通过一个例子来模拟一下 avaScriptCore 执行 JS 脚本来让 Native 和 JS 之间的通信。关于 JavaScriptCore 的具体使用可以参考下戴铭的 深入剖析 JavaScriptCore 。我们打算实现这样的功能：通过下发JS脚本创建原生的 UILabel 和 UIButton 控件并响应事件，首先编写 JS 代码如下：(function(){\r\n console.log(\"ProgectInit\");\r\n //JS脚本加载完成后 自动render界面\r\n return render();\r\n })();\r\n\r\n//JS标签类\r\nfunction Label(rect,text,color){\r\n    this.rect = rect;\r\n    this.text = text;\r\n    this.color = color;\r\n    this.typeName = \"Label\";\r\n}\r\n//JS按钮类\r\nfunction Button(rect,text,callFunc){\r\n    this.rect = rect;\r\n    this.text = text;\r\n    this.callFunc = callFunc;\r\n    this.typeName = \"Button\";\r\n}\r\n//JS Rect类\r\nfunction Rect(x,y,width,height){\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n}\r\n//JS颜色类\r\nfunction Color(r,g,b,a){\r\n    this.r = r;\r\n    this.g = g;\r\n    this.b = b;\r\n    this.a = a;\r\n}\r\n//渲染方法 界面的渲染写在这里面\r\nfunction render(){\r\n    var rect = new Rect(20,100,280,30);\r\n    var color = new Color(1,0,0,1);\r\n    var label = new Label(rect,\"这是一个原生的Label\",color);\r\n\r\n    var rect4 = new Rect(20,150,280,30);\r\n    var button = new Button(rect4,\"这是一个原生的Button\",function(){\r\n                            var randColor = new Color(Math.random(),Math.random(),Math.random(),1);\r\n                            TestBridge.changeBackgroundColor(randColor);\r\n                            });\r\n    //将控件以数组形式返回\r\n    return [label,button];\r\n}\r\n复制代码创建一个 OC 类 TestBridge 绑定到 JavaScriptCore 全局对象上：@protocol TestBridgeProtocol <JSExport>\r\n- (void)changeBackgroundColor:(JSValue *)value;\r\n@end\r\n\r\n@interface TestBridge : NSObject<TestBridgeProtocol>\r\n\r\n@property(nonatomic, weak) UIViewController *ownerController;\r\n\r\n@end\r\n复制代码#import \"TestBridge.h\"\r\n\r\n@implementation TestBridge\r\n\r\n- (void)changeBackgroundColor:(JSValue *)value{\r\n    self.ownerController.view.backgroundColor = [UIColor colorWithRed:value[@\"r\"].toDouble green:value[@\"g\"].toDouble blue:value[@\"b\"].toDouble alpha:value[@\"a\"].toDouble];\r\n}\r\n\r\n@end\r\n复制代码在 ViewController 中实现一个界面渲染的 render 解释方法：#import \"ViewController.h\"\r\n#import <JavaScriptCore/JavaScriptCore.h>\r\n#import \"TestBridge.h\"\r\n\r\n@interface ViewController ()\r\n\r\n@property(nonatomic, strong)JSContext *jsContext;\r\n@property(nonatomic, strong)NSMutableArray *actionArray;\r\n@property(nonatomic, strong)TestBridge *bridge;\r\n\r\n@end\r\n\r\n@implementation ViewController\r\n\r\n- (void)viewDidLoad {\r\n    [super viewDidLoad];\r\n    //创建JS运行环境\r\n    self.jsContext = [JSContext new];\r\n    //绑定桥接器\r\n    self.bridge =  [TestBridge new];\r\n    self.bridge.ownerController = self;\r\n    self.jsContext[@\"TestBridge\"] = self.bridge;\r\n    self.actionArray = [NSMutableArray array];\r\n    [self render];\r\n}\r\n\r\n-(void)render{\r\n    NSString * path = [[NSBundle mainBundle] pathForResource:@\"main\" ofType:@\"js\"];\r\n    NSData * jsData = [[NSData alloc]initWithContentsOfFile:path];\r\n    NSString * jsCode = [[NSString alloc]initWithData:jsData encoding:NSUTF8StringEncoding];\r\n    JSValue * jsVlaue = [self.jsContext evaluateScript:jsCode];\r\n    for (int i=0; i<jsVlaue.toArray.count; i++) {\r\n        JSValue * subValue = [jsVlaue objectAtIndexedSubscript:i];\r\n        if ([[subValue objectForKeyedSubscript:@\"typeName\"].toString isEqualToString:@\"Label\"]) {\r\n            UILabel * label = [UILabel new];\r\n            label.frame = CGRectMake(subValue[@\"rect\"][@\"x\"].toDouble, subValue[@\"rect\"][@\"y\"].toDouble, subValue[@\"rect\"][@\"width\"].toDouble, subValue[@\"rect\"][@\"height\"].toDouble);\r\n            label.text = subValue[@\"text\"].toString;\r\n            label.textColor = [UIColor colorWithRed:subValue[@\"color\"][@\"r\"].toDouble green:subValue[@\"color\"][@\"g\"].toDouble blue:subValue[@\"color\"][@\"b\"].toDouble alpha:subValue[@\"color\"][@\"a\"].toDouble];\r\n            label.textAlignment = NSTextAlignmentCenter;\r\n            [self.view addSubview:label];\r\n        }else if ([[subValue objectForKeyedSubscript:@\"typeName\"].toString isEqualToString:@\"Button\"]){\r\n            UIButton * button = [UIButton buttonWithType:UIButtonTypeSystem];\r\n            button.frame = CGRectMake(subValue[@\"rect\"][@\"x\"].toDouble, subValue[@\"rect\"][@\"y\"].toDouble, subValue[@\"rect\"][@\"width\"].toDouble, subValue[@\"rect\"][@\"height\"].toDouble);\r\n            [button setTitle:subValue[@\"text\"].toString forState:UIControlStateNormal];\r\n            button.tag = self.actionArray.count;\r\n            [button addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside];\r\n            [self.actionArray addObject:subValue[@\"callFunc\"]];\r\n            [self.view addSubview:button];\r\n            \r\n        }\r\n    }\r\n}\r\n\r\n-(void)buttonAction:(UIButton *)btn{\r\n    JSValue * action  = self.actionArray[btn.tag];\r\n    [action callWithArguments:nil];\r\n}\r\n\r\n@end\r\n复制代码这样就完成了一个简单的 JS 脚本注入，实际上执行后的样子是这样的：这就是一个简单的执行 JS 脚本的逻辑，实际上 ReactNative 的原理也是基于此，小程序逻辑层与微信客户端的交互逻辑也是基于此。到这里，关于微信小程序渲染层与逻辑层做了什么、怎么做的、优化了什么以及为什么要采用这样的架构来设计，基本都梳理完毕了。小程序这样的分层设计显然是有意为之的，它的中间层完全控制了程序对于界面进行的操作， 同时对于传递的数据和响应时间也做到的监控。一方面程序的行为受到了极大限制， 另一方面微信可以确保他们对于小程序内容和体验有绝对的控制。我们在小程序的 JS 代码里面是不能直接使用浏览器提供的 DOM 和 BOM 接口的，这一方面是因为 JS 代码外层使用了局部变量进行屏蔽，另一方面即便我们可以操作 DOM 和 BOM 接口，它们对应的也是逻辑层模块，并不会对页面产生影响。这样的结构也说明了小程序的动画和绘图 API 被设计成生成一个最终对象而不是一步一步执行的样子， 原因就是 json 格式的数据传递和解析相比与原生 API 都是损耗不菲的，如果频繁调用很可能损耗 过多性能，进而影响用户体验。总结一句话就是 webView渲染，JSCore处理逻辑，JSBridge做线程通信 。后面再简要的分析下支付宝小程序，支付宝小程序属于后起之秀，支付宝小程序在微信小程序的基础上，做了一些优化，单从技术角度来看，有点后来者居上的意思。目前支付宝技术通过官方的媒体账号对外暴漏的一些实现细节也在逐步增多。六、再说说支付宝小程序前端框架下面是小程序 native 引擎，包括了小程序容器、渲染引擎和 JavaScript 引擎，这块主要是把客户端 native 的能力和前端框架结合起来，给开发者提供系统底层能力的接口。在渲染引擎上面，支付宝小程序不仅提供 JavaScript+Webview 的方式，还提供 JavaScript+Native 的方式，在对性能要求较高的场景，可以选择 Native 的渲染模式，给用户更好的体验。这段文字来源于支付宝对外开放的技术博客的描述，从这段描述中，我们能够发现支付宝小程序在架构设计上同样采用的渲染引擎加 JavaScript 引擎两部分，包括页面间的切换实际上和微信小程序逻辑基本一致。下面这张是支付宝小程序应用框架的架构图：运行时架构单从这个运行时架构来看，它与微信小程序不同的地方是，webView 页面也就是渲染层通过消息服务直接与逻辑层进行通讯，而不需要像微信的 JSBridge 那样作为中间层，消息服务具体实现细节目前尚不得知。支付宝的JSBridge只会与逻辑层进行通讯，来给小程序提供一些 Native 能力。支付宝的这种架构主要目的是解决渲染层与逻辑层交互的对象较复杂、数据量较大时，交互的性能比较差的问题。支付宝小程序的设计思路比较值得借鉴，微信小程序线程间的通讯是通过 JSBridge ，序列化 json 进行传递的。支付宝小程序重新设计了V8虚拟机，让逻辑和渲染都有自己的 Local Runtime，存放私有的模块和数据。在渲染层和逻辑层交互时，setData 的 对象会直接创建在 Shared Heap 里面，因此渲染层的 Local Runtime 可以直接读到该对象，并且用于 render 层的渲染，保证了逻辑和渲染的隔离，又减少了序列化和传输成本。当然支付宝还有些其他的优化，包括首页离线缓存，缓存时机的处理以及闪屏处理等等问题，这里就不再延伸讨论了（因为很多细节我也不知道）。小程序SDK根据支付宝小程序对外开放的技术文章来看，架构设计还是非常巧妙的，也很值得我们学习，先看图：参考： 独家！支付宝小程序技术架构全解析小程序SDK在架构设计上把它分为了两部分，一部分是核心库基础引擎，一部分是基于基础库开发的插件功能。从上往下看：第一层小程序层，这是小程序开发者使用小程序 DSL 及各种组件开发的代码层。第二层和第三层架应该是小程序内部封装的一些组件和对外提供的相关API等。第四层和第五层是小程序的运行基础框架，主要包含小程序的逻辑处理引擎及渲染层。支付宝基于 ReactNative 增加了 Native 引擎，可以用原生来渲染 UI 。根据支付宝 mPaaS 的介绍来看，目前支付宝的小程序使用的是 React 版，蚂蚁内部的其他 App 有在使用 React Native 版的小程序。基础组件部分和扩展能力部分更像是基于 Bridge 调用的原生能力。六、最后差不多半年多没有写文章了，趁着公司年会时间稍显充裕，对当前的小程序架构进行了下分析和总结，当然，真正的小程序应该比这还要复杂的多，小程序实际上是多年来大前端融合的一个结果，是一套非常成体系的技术方案，看了这么多我想你对小程序也有了初步认识，小程序的核心实际上还是 渲染层 和 逻辑层 的构建，那么如果让你开发一套 小程序SDK ，你会怎样设计它们呢？" } { "title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。" } { "title": "如何实现微信小程序换头像？三步帮你搞定！ ", "author": "Rolan", "pub_time": "2019-10-17 00:52", "content": "背景\r\n2019年10月1日在祖国70周年大庆之际，微信朋友圈被大家纷纷@微信官方要国旗的景象给刷屏了，在为祖国庆生的同时，玩的不亦乐乎。\r\n在9月25日，我心血来潮决定在国庆前开发一个换头像的微信小程序为祖国70周年献礼！最终在国庆前夕上线发布了制作头像的小程序-【海豚趣图】，帮助10000多名小伙伴成功换上了国旗头像。\r\n小程序虽然已经上线，但在【海豚趣图】这个小程序开发过程中的一些有意思的技术点我希望能总结一下和大家进行分享。\r\n主要步骤\r\n\r\n获取用户头像\r\n图片模板\r\n图片合成\r\n\r\n获取用户头像\r\n制作自定义头像的第一步就是先选择图片。在【海豚趣图】的交互设计中，用户有三种选择图片的方式：微信头像、本地相册和相机拍摄。获取用户头像的产品设计如下图所示：\r\n\r\n\r\n由于微信官方不再支持通过 wx.getUserInfo 接口来获取用户信息，我们必须通过使用 button 组件并将 open-type 指定为 getUserInfo 类型来获取或展示用户信息。\r\n\r\n为优化用户体验，使用 wx.getUserInfo 接口直接弹出授权框的开发方式将逐步不再支持。从2018年4月30日开始，小程序与小游戏的体验版、开发版调用 wx.getUserInfo 接口，将无法弹出授权询问框，默认调用失败。正式版暂不受影响。\r\n\r\n上图中弹出底部菜单的交互方式无法通过 wx.showActionSheet 来实现（因为该接口只能指定字符串文本，不能使用 button, navigator 等组件）。\r\n因此，只能通过自定义 actionSheet 组件来实现以上功能。\r\nmmp-action-sheet 组件\r\n以下是 mmp-action-sheet 组件的代码。\r\nindex.wxml\r\n<view hidden=\"{{!actionShow}}\" class=\"mask {{mask}}\" bindtap=\"actionHide\">\r\n  <view class=\"actionSheet animated {{animation}}\">\r\n    <slot></slot>\r\n    <button class=\"close\" bindtap=\"actionHide\">{{closeText}}</button>\r\n  </view>\r\n</view>\r\n复制代码通过 slot 在 action-sheet 中插入自定义的内容，比如 button、navigator 等。\r\nindex.wxss\r\n.mask{\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width:100%;\r\n  height: 100%;\r\n  background: rgba(0, 0, 0, 0.5);\r\n  z-index: 999;\r\n}\r\n.actionSheet{\r\n  width: 100%;\r\n  position: absolute;\r\n  top: 100%;\r\n  z-index: 1000;\r\n  overflow: hidden;\r\n}\r\n.actionSheet button,\r\n.actionSheet navigator{\r\n  color: #000;\r\n  text-align: center;\r\n  background: #fff;\r\n  border-radius: 0;\r\n  line-height: 3.5;\r\n  font-size: 32rpx;\r\n  border-bottom: 1rpx solid rgb(236, 236, 236);\r\n  opacity: 1;\r\n}\r\n.actionSheet button:active,\r\n.actionSheet navigator:active{\r\n  color:#000;\r\n  background: rgb(236, 236, 236);\r\n}\r\n.actionSheet button::after,\r\n.actionSheet navigator::after\r\n{\r\n  border: none;\r\n  border-radius: 0;\r\n}\r\n.actionSheet .close{\r\n  border-bottom: none;\r\n  border-bottom: 50rpx solid #fff;\r\n  border-top: 16rpx solid rgb(236, 236, 236);\r\n}\r\n.animated {\r\n  animation-timing-function: ease-out;\r\n  animation-duration: 0.2s;\r\n  animation-fill-mode: both;\r\n}\r\n\r\n\r\n@keyframes fadeInBottom {\r\nfrom{\r\n   transform: translate3d(0, 0, 0);\r\n }\r\n  to {\r\n    transform: translate3d(0, -100%, 0);\r\n  }\r\n}\r\n.fadeInBottom {\r\n  animation-name: fadeInBottom;\r\n}\r\n\r\n@keyframes fadeOutBottom {\r\nfrom{\r\n   transform: translate3d(0, -100%, 0);\r\n }\r\n  to {\r\n    transform: translate3d(0, 0, 0);\r\n  }\r\n}\r\n.fadeOutBottom {\r\n  animation-name: fadeOutBottom;\r\n}\r\n\r\n@keyframes fadeIn {\r\nfrom{\r\n   opacity: 0;\r\n }\r\n  to {\r\n     opacity: 1;\r\n  }\r\n}\r\n.fadeIn {\r\n  animation-name: fadeIn;\r\n}\r\n\r\n@keyframes fadeOut {\r\nfrom{\r\n   opacity: 1;\r\n }\r\n  to {\r\n     opacity: 0;\r\n  }\r\n}\r\n.fadeOut {\r\n  animation-name: fadeOut;\r\n}\r\n复制代码index.js\r\nComponent({\r\n  properties: {\r\n    actionSheetStatus: {\r\n      type: Boolean,\r\n      value: false,\r\n      observer(newVal) {\r\n        if (newVal) {\r\n          this.setData({\r\n            actionSheetStatus: true,\r\n            animationMask: 'fadeIn',\r\n            animationSheet: 'fadeInBottom'\r\n          })\r\n        } else {\r\n          this.setData({\r\n            actionSheetStatus: false,\r\n            animationMask: 'fadeOut',\r\n            animationSheet: 'fadeOutBottom'\r\n          })\r\n        }\r\n      }\r\n    },\r\n    closeText: {\r\n      type: String,\r\n      value: '取消'\r\n    }\r\n  },\r\n\r\n  data: {\r\n    animationMask: 'fadeIn',\r\n    animationSheet: 'fadeInBottom'\r\n  },\r\n\r\n  methods: {\r\n    closeActionSheet() {\r\n      this.setData({\r\n        animationMask: 'fadeOut',\r\n        animationSheet: 'fadeOutBottom'\r\n      })\r\n      setTimeout(() => {\r\n        this.setData({actionSheetStatus: false})\r\n      }, 300)\r\n    }\r\n  }\r\n})\r\n复制代码组件只有两个参数：\r\n\r\nactionSheetStatus 指定组件的初始展示状态，默认为false，表示不显示组件。\r\ncloseText 指定关闭按钮的名字，默认为 取消。\r\n\r\nindex.json\r\n{\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}\r\n复制代码接下来在页面中调用组件，在组件中插入了3个 button 组件来实现来获取用户头像：\r\n<action-sheet actionSheetStatus=\"{{actionSheetStatus}}\">\r\n    <button open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\">使用微信头像</button>\r\n    <button bindtap=\"pickPic\" data-source-type=\"album\">使用本地相册</button>\r\n    <button bindtap=\"pickPic\" data-source-type=\"camera\">拍照</button>\r\n  </action-sheet>\r\n复制代码以上我们通过自定义组件 mmp-action-sheet 就解决了原生的 actionsheet 无法指定 button，从而无法获取用户微信头像的问题。\r\n该组件我已经发布到 npm 包，需要用到的同学可以通过 npm 安装，也可以在 github 上查看源码和使用文档。\r\n图片模板\r\n有了原图，接下来我们需要选择图片模板。如果模板数量不多或者模板变化不频繁，我们可以直接把模板放在本地。鉴于我提供的模板比较多，放在本地会增大小程序源码的大小，我把模板上传到了小程序的云存储中，通过云函数来动态获取图片模板，方便以后模板扩展。\r\n云函数 tpl 的代码如下：\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const wxContext = cloud.getWXContext()\r\n  // 1. 获取数据库引用\r\n  const db = cloud.database()\r\n  const MAX_LIMIT = 100\r\n  // 2. 构造查询语句\r\n  const countResult = await db.collection('template').count()\r\n  const total = countResult.total\r\n  // 计算需分几次取\r\n  const batchTimes = Math.ceil(total / 100)\r\n  const tasks = []\r\n  for (let i = 0; i < batchTimes; i++) {\r\n    const promise = db.collection('template').skip(i * MAX_LIMIT).limit(MAX_LIMIT).get()\r\n    tasks.push(promise)\r\n  }\r\n\r\n  return (await Promise.all(tasks)).reduce((acc, cur) => {\r\n    return {\r\n      data: acc.data.concat(cur.data),\r\n      errMsg: acc.errMsg,\r\n    }\r\n  })\r\n}\r\n复制代码页面中调用云函数拉取模板：\r\ngetTpl() {\r\n    const self = this\r\n    // 调用云函数获取图片模板\r\n    wx.cloud.callFunction({\r\n      name: 'tpl'\r\n    }).then(res => {\r\n      self.setData({\r\n        templates: res.result.data\r\n      })\r\n    })\r\n}\r\n复制代码问题\r\n到这里模板的获取逻辑已经没有问题了，但在开发过程中遇到了一个问题。模板图片的链接我使用的是云文件ID，当有大量图片并行加载的时候，只有部分图片能够显示，我看了一下dom节点其实都已经存在了，image的src的地址也都是正确的。\r\n\r\n微信官方自2.3.0开始已经支持在image中使用云文件ID。云文件ID的格式为： cloud://xxx.xxx/templates/01.png。\r\n\r\n我猜测可能是对微信云存储并发请求过多导致的（有知道的同学可以告知），因为我试了一下将云文件ID换成正常的HTTPS的链接是没问题的。\r\n由此可知，可以想到有三种可行的解决方案：\r\n\r\n将图片模板存储到外部OSS，使用https协议的链接。\r\n使用 wx.getTempFileURL 用云文件 ID 换取真实链接，也就是https形式的链接。\r\n控制图的并行加载数量。我的实践是将并行加载数量控制在20，当用户滚动的时候再发起下一次请求。\r\n\r\n总结\r\n以上主要分享了用户头像获取以及图片模板功能的实现及所遇到的一些问题。关于图片的合成是整个小程序的核心功能，下一篇单独拉出来说一下实现思路和潜在的问题。敬请期待！\r\n扫码体验\r\n读者可以扫码体验我们所讲述的两个功能点：\r\n\r\n自定义actionsheet组件\r\n图片模板加载" } { "title": "小小的支付完成页上，腾讯阿里打起来了 ", "author": "Rolan", "pub_time": "2019-10-31 00:02", "content": "表面看，支付宝似乎在这个页面上和微信越来越趋同，这实属意料之中，商家们津津乐道的一句流传语可以很好地说明问题：“付款的结束，是复购的开始”。作者： Miss豆教授来源：公众号：晓程序观察（ID：yinghoo-tech）支付完成页面，一夜之间成为香饽饽。近日，支付宝开放了「支付后推荐」能力，商家可在用户支付后的成功页添加收藏小程序/关注生活号的组件，并通过小程序收藏有礼/生活号关注有礼引导用户点击。收藏小程序有礼关注生活号有礼用大白话说，就是商家可在用户支付成功页面，通过优惠券，鼓励用户收藏小程序，或者关注生活号。由此一来，支付结果页就成为下一次交易的开始，最终形成“从支付到支付”的正向循环。是不是乍一听，着实有些似曾相识？因为微信很早之前就推出了类似功能，今年4月份微信支付合作伙伴大会上，「支付有礼」能力亮相，商家可以在“支付结果页发券”，最终在用户端的操作场景是，在某商家用微信支付完成支付后，支付结果页面会推荐该商家的优惠券，刺激用户复购。「店外附近发券」能力同时上线，而更早之前，微信支付在完成页上上线了关注服务号、获取立减金能力等。表面看，支付宝似乎在这个页面上和微信越来越趋同，这实属意料之中，商家们津津乐道的一句流传语可以很好地说明问题：“付款的结束，是复购的开始”。但两家平台属性不同，能力开放的程度也不相同，玩法自然也有不同处，所以决定做一次对比PK，帮助大家更好地选择。环节一：入驻门槛（线下、线下、线下！）对于开发者而言，入驻门槛永远是关注的第一要素。毕竟，即便功能被吹得天花乱坠，开发者想入驻却难如登天，久而久之也不会有太多人耐心地不厌其烦一遍又一遍地尝试接入。从微信的「支付有礼」和支付宝的「支付后推荐」能力门槛，也能看出两家想主攻的方向。1. 微信：微信支付商户的专享虽然没有明确规定线下商户才能接入，但从能力的选项可以看出 微信的「支付有礼」主要还是针对线下场景 。来看一段微信的官方介绍：支付有礼是面向符合条件的微信支付商户开放的营销能力，用户在商家使用微信支付后可以领取微信支付代金券，下次回店消费只要符合用券条件即可自动抵扣优惠，能有效帮助商户拉动顾客二次购买或完成线下门店－线上商城的连接。这段话里透露了两个信息：首先，适合有门店的线下商户，其次，想使用该能力就必须成为微信支付的商户。据我们了解， 该能力目前主要是餐饮和零售两个类目使用 。2. 支付宝：门槛太“鸡贼”支付宝对于「支付后推荐」的门槛规定则更为细化：必须是开通当面付功能的商户；7天内交易平均交易笔数大于300笔。这样的门槛透漏了三个信号：首先，由于当面付是针对于支付宝商户的能力，因此只有成为支付宝商户才能使用「支付后推荐」功能，而非小商贩都可以；其次，当面付是针对线下商户的场景能力，因此「支付后推荐」和微信一样，锁定的是线下场景。此外，300笔的周平均交易笔数并不算少，并且当面付很难刷量，有开发者对我们表示：“这是支付宝的鸡贼心理，想用它的能力，就必须得先推荐用户使用支付宝付款，帮它推广，这是支付宝在与相对佛系的微信支付竞争时的一个小伎俩”。截止发稿前，支付宝似乎将门槛下调，周日均300笔的限制要求下降至周均1笔（当面付or小程序支付笔数）。目前，该能力还没有看到类目限制。总的来说，两家的门槛限制都不算太高，都是必须成为两家的商户。另一个值得注意的门槛是，目前这些能力都是免费使用，并且代金券、立减金，都无需商户提前充值，支持免充值使用，商家使用多少代金券充多少即可，这对于商家而言，无疑是大大利好。环节二：留存、复购，哪家强？在支付页面的玩法上，微信起步早于支付宝。早在微信支付诞生不久，就上线了支付完成后一键关注商家服务号的能力。总的来看，在微信的支付完成页面上，目前共有这些工具可以为商家使用：关注服务号、立减金等，再加上今年推出了「支付有礼」、「附近发券」能力。而在支付宝的支付完成页面上，主要工具是生活号、小程序。从工具数量上看，微信支付明显多于支付宝。但工具数量不等于一切，用组合出对用户而言有意思，对商户而言有价值的玩法，才是王道。玩法上两家有什么迥异？1. 线下拉来的新客放到哪里沉淀？无论是微信还是支付宝，由于该能力基本对应线下，因此该页面的拉新基本都来源于线下场景，但将新客放到哪里去沉淀？微信和支付宝的打法有一些差异。微信支付页目前只能将用户留存到服务号上，引导用户一键关注服务号；支付宝则是生活号和小程序都可以沉淀，可以引导用户关注生活号、收藏小程序。值得注意的是， 虽然看上去支付宝给商户提供的服务更多，但关注生活号和收藏小程序，商户只能二选一，即要么使用「收藏有礼」、要么使用「关注有 礼」 。值得注意的是，对于商户而言，这两个“有礼”都要做。有些商家认为，反正在用户端只会显示一个“有礼”，那么在「支付后推荐」上就配置一个功能即可。但事实上，「支付后推荐」能力虽然只在用户侧显示其中一个功能，但是它会判断该用户是否已经关注过生活号或已收藏小程序。假如该用户已经收藏小程序，那么系统则会展示“关注有礼”，反之也一样。只有当用户两项“有礼”都已经领取后，才不会显示“支付后推荐”。2. 线上+线下的复购玩法在复购毫无疑问，对于商家而言，留存的目的就是复购。通过微信的支付完成页，复购有两个办法：线下二次复购： 在支付完成页直接向用户推送优惠券，领券落地页立即使用跳转至扫一扫／付款码，用户在门店核销；线上二次复购： 引导用户关注服务号，用服务号向用户推送优惠券，领券落地页跳转至小程序，用户可一键跳转至小程序核销代金券。值得注意的是，采用这种模式，小程序appid需要跟活动商户号进行绑定。具体使用哪种，由商户自行选择配置。支付宝的办法则更为直接，无论是关注生活号有礼，还是收藏小程序有礼，都是一个路数，用户点击关注或收藏后，弹出代金券。代金券分为两种，线上小程序使用或线下门店使用，具体到底是线上还是线下，由商户自己配置。在领券核销环节，微信是领券即可使用，支付宝则是收藏领券即可使用，对小程序而言，微信比较站在用户侧，支付宝比较在商家侧。对关注公号/生活号而言，微信只是单纯关注，优惠券得等到下一次推文，支付宝则是关注就有券，马上可以用。对比来看，线下复购，微信更为直接，只需一步操作，最大化激活用户立刻复购的可能，而支付宝则更为强调收藏小程序、关注公众号；线上复购，微信的流程多一环，用户关注服务号后，需要商户通过服务号再次触达用户发送优惠券，而支付宝是关注即送，少了后续触达的一步。三、线下微信胜，支付宝“竞争大”？通过以上，可以看到， 支付宝的「支付后推荐」目标鲜明，就是吸引客户进入生活号、小程序，以支付作为切入，为生态内其他工具引流，从而实现留存、复购的价值 。而微信能实现的场景更多，通过服务号+优惠券，可以实现线上留存、复购，而线下发券可以实现线下的立刻复购。在不少人看来， 相比于支付宝，微信还多了即时回馈消费者，聚焦二次消费的属性 。对于开发者和商户而言，巨头生态都至关重要，很少有人会二选一，多数还是会选择双线布局。在他们看来，两家的优点和缺点都很鲜明。微信方面，支付完成页的线下复购刺激非常直接有效。事实上，这种玩法此前就有很多小程序再玩了，多位小程序服务商对我们表示，过去，送给用户的优惠券会直接发送微信卡包，用户到店可以打开卡包进行核销。如若用户是在小程序上完成支付，那么就将优惠券发送到小程序账户里，之后通过模板消息提醒用户消费。现在通过微信支付完成页来刺激，步骤极少，对于复购刺激效率很高。但线上则显得薄弱很多，“如果能从优惠券一键进入小程序，那就非常棒了，不然服务号推送优惠券这个流程，可能会流失不少用户。”不少开发者对我们表示。支付宝的玩法对线上留存异常友好，但也存在一个问题，在支付宝的支付完成页上，福利过多，杂乱使用户体验并不太好：经常在商家的「支付后推荐」优惠券上方，还有口碑券、饿了么券、保险基金、优酷7天会员等阿里系其他App的福利。对于用户而言，选择了这些阿里“官方”福利后，就无法再选择商户的优惠券。“这就是商户和阿里系官方福利竞争，不像微信，页面干干净净的，商户优惠券非常显眼。”有开发者表示。据我们了解，由天猫支付宝联合推出，专为品牌商打造的「品牌轻店」，也将在双十一前接入「支付后推荐」能力，介入后，用户在品牌商的线下门店支付后，可一键收藏「品牌轻店」”程序，进而跳转至天猫品牌旗舰店，将线下流量导到线上，这对同时有线下门店和天猫店铺的品牌商而言，尤为重要。作者： Miss豆教授，公众号：晓程序观察（ID：yinghoo-tech）来源：https://mp.weixin.qq.com/s/SBuyJmVsGqce_ZklH6yrIA本文由 @晓程序观察 授权发布于人人都是产品经理，未经作者许可，禁止转载题图来自Unsplash，基于CC0协议" } { "title": "当微信小程序遇上filter~ ", "author": "Rolan", "pub_time": "2019-11-6 00:32", "content": "在微信小程序的开发过程中，当你想要实现不同页面间的数据绑定，却为此抓耳饶腮时，不妨让微信小程序与filter 来一场完美的邂逅，相信会给你带来别样的惊喜~前段时间被安利了一个很实用的公众号—前端早读课，它简洁、大方的页面和方便、实用的功能深深地吸引着我~(＾Ｕ＾)ノ 恰好这段时间学了小程序，就自己仿着写了个前端早读课的小程序。实现的功能不同页面间的数据绑定随机显示数组里的元素实时显示系统的日期鼠标点击和页面跳转等基本功能swiper组件和template样式模板的使用使用easy mock模拟后台数据并进行动态传参项目展示整个项目包括“每日一看”、“看看世界”、“情报局”和“介绍”四个主页面。完美邂逅~在开发“每日一看”页面的过程中，我遇到了一个难题，如何将“每日一看”页面中获取的数据与阅读详情页的数据绑定起来，也就是从这时起，微信小程序开始邂逅filter~下面简单介绍一下filter~filter华丽登场~filter 是一个基于数组的方法，通过一个回调函数对数组进行筛选，并返回数组中满足条件的元素，相当于过滤器的效果。filter的三要素数组对象(arry)每个filter 方法都有一个数组对象，通过该方法对数组里的元素进行筛选。 具体用法： arry.filter();\r\n回调函数(callbackfn)对于数组中的每个元素，filter 方法都会调用callbackfn 函数一次。 具体用法： function callbackfn(value, index, array);\r\n其中 value 表示数组元素的值，index 表示数组元素的下标， array 表示包含该元素的数组。返回值filter 方法的返回值是一个数组，包含所有满足回调函数条件的值。更多详情： filter文档别样的惊喜~filter的骚操作—实现数据的动态绑定敲黑板的重点来啦！！！在 dairy.wxml 页面中用 navigator 组件实现 ‘每日一看’ 页面和 ‘阅读详情’ 页的跳转，并传递一个 id 参数，每篇文章都有唯一的一个 id，这样就可以通过 js 使用 filter 过滤器筛选出两个 id 相等的文章数据，也就实现了数据的动态绑定。<navigator url=\"./detail/detail?id={{id}}\">\r\n    <button class=\"page_bd_motto_read\">阅读</button>\r\n</navigator>\r\n在 dairy.js 中，因为页面每次都是随机显示一篇文章，这时就需要获取该文章的id，并作为参数，当页面跳转时作为一个钩子把两个页面联系起来。that.setData({\r\n            headline: arr[index].headline,\r\n            from: arr[index].from,\r\n            // 设置id作为阅读详情页的一个钩子\r\n            id: arr[index].acticle_id\r\n          })\r\n        }\r\n      })\r\n当页面跳转到详情页时，在 detail.js 中使用 filter 把 acticle_id 等于上一页面文章 id 的数据赋值给 datas，再对其进行操作，就实现了数据的动态绑定。Page({\r\n  data: {\r\n    // 表示该篇文章\r\n    item: []\r\n  },\r\n  onLoad: function(params) {\r\n    // 检验id是否传递成功\r\n    console.log(params.id);\r\n    var that = this;\r\n    wx.request({\r\n      url: 'https://www.easy-mock.com/mock/5a2b5f76158e7b70032804d0/getActicleInfo/getActicleInfo',\r\n      success: function(res) {\r\n        // 使用过滤器把id等于上一页面id的数组赋值给datas\r\n        var datas = res.data.data.acticle_List.filter(item => {\r\n          return item.acticle_id == params.id;\r\n        });\r\n        that.setData({\r\n          item: datas\r\n        });\r\n        console.log(datas);\r\n      }\r\n    })\r\n\r\n  }\r\n})\r\n在 detail.wxml 中对传入的 item 数据进行调用，于是别样的惊喜就出现啦~<!--pages/dairy/detail/detail.wxml-->\r\n    <view class=\"page__hd\">\r\n        <view class=\"page__hd_title center\">{{item[0].headline}}</view>\r\n        <view class=\"page__hd_author\">作者：@{{item[0].author}}</view>\r\n    </view>\r\n    <view class=\"page__bd\">\r\n        <text class=\"page__bd_content center\">{{item[0].content}}</text>\r\n    </view>\r\n\r\n特别注意： 可能有细心的人儿已经发现为什么这里用的是 item[0]. 来调用，而不是 **item.**来调用，这是数据索引的问题。如下图所示，我的数据是个三级结构，item 表示的是最外层的文章数组元素，要获取文章的作者或标题等信息，必须使用 item[0]. 才能进行调用。只有理解数据索引的本质，才能准确地调用数据。于是，小程序在遇上filter后，就创造出了别样的惊喜 O(∩_∩)O~一起排坑~在开发过程中，遇到了一些坑，在此总结一下~1. 随机显示数组里的元素这个公众号一大亮点就是可以随机显示文章，每次点进去的文章都不一样，感受度极佳。这里采用随机函数来获取数组的下标，Math.random()函数是获取[0,1)之间的数，Math.floor()函数是向下取整，这样就可以随机获取相应的下标数。 onLoad: function () {\r\n    var that = this;\r\n      wx.request({\r\n        url: 'https://www.easy-mock.com/mock/5a2b5f76158e7b70032804d0/getActicleInfo/getActicleInfo',\r\n        method: 'GET',\r\n        data: {},\r\n        success: function(res) {\r\n          //获取文章数据的列表\r\n          var arr = res.data.data.acticle_List;\r\n          //用随机函数随机获取数组的下标\r\n          var index = Math.floor(Math.random()*arr.length);\r\n          // console.log(arr[index].acticle_id);\r\n          that.setData({\r\n            headline: arr[index].headline,\r\n            from: arr[index].from,\r\n            // 设置id作为阅读详情页的一个钩子\r\n            id: arr[index].acticle_id\r\n          })\r\n        }\r\n      })\r\n  },\r\n})\r\n2. 实时显示系统的日期之前开发的时候觉得这个方法如果自己写还蛮难的，后面百度了一下，发现js里面提供了相应的API，直接使用就好，特别方便。有关系统时间的API  //监听页面显示\r\n  // day：星期几\r\n  // date：某日\r\n  // month：月份\r\n  onShow: function () {\r\n      var myDate = new Date();\r\n      // setData设置或更新数据\r\n      this.setData({\r\n        date: myDate.getDate(),\r\n        month: myDate.getMonth() + 1,\r\n        day: week(),\r\n      });\r\n      function week(day) {\r\n          switch(myDate.getDay()) {\r\n            case 1: day=\"星期一\"; break;\r\n            case 2: day=\"星期二\"; break;\r\n            case 3: day=\"星期三\"; break;\r\n            case 4: day=\"星期四\"; break;\r\n            case 5: day=\"星期五\"; break;\r\n            case 6: day=\"星期六\"; break;\r\n            default: day=\"星期天\";\r\n          }\r\n          return day;\r\n        }\r\n  },\r\n3. 用hover实现鼠标点击效果在对首页进行鼠标点击效果的开发过程中，一开始想到的就是使用伪元素来添加点击按钮的样式效果，后面出现了一个bug，当我点击按钮跳转到另一个页面，再回退到原页面时，还是处于点击态的样式，这时百度就起了很大的作用，我上网百度了很久，才发现有hover属性中的hover-stay-time为动画持续的时间，hover-class 为定义点击按钮时的样式，于是这个bug就解决啦~<view class=\"page__bd\">\r\n    <view class=\"page__bd_tab\" hover-class=\"active\" hover-stay-time=\"2000\">\r\n      <view class=\"page__bd_tab_item\" hover-class=\"active1\" hover-stay-time=\"2000\" bindtap=\"dairyRead\">每日一看</view>\r\n      <view class=\"page__bd_tab_item\" hover-class=\"active1\" hover-stay-time=\"2000\" bindtap=\"lookWorld\">看看世界</view>\r\n      <view class=\"page__bd_tab_item\" hover-class=\"active1\" hover-stay-time=\"2000\" bindtap=\"intelligence\">情报局</view>\r\n      <view class=\"page__bd_tab_item\" hover-class=\"active1\" hover-stay-time=\"2000\" bindtap=\"introduction\">简介</view>\r\n    </view>\r\n  </view>\r\n4. 页面左右滑动的效果使用swiper组件实现对页面的左右滑动的效果。5. template 模板样式的使用当一串代码面临复制粘贴时，这时就应该考虑对其进行封装，这样直接在不同的地方调用就好了，也完成了代码的优化。小程序中的 template 模板就很好地帮我们解决了这个问题，并通过 is 属性来实现调用。template 模板的定义：<!--pages/common/list_intelligence/list_intelligence.wxml-->\r\n<template name = \"intelligence_list\">\r\n <view class=\"page__cell\">\r\n    <view class=\"page__cell_headline center\">\r\n        <view class=\"page__cell_headline_img\">\r\n            <image src=\"{{avatar}}\"/>\r\n        </view>\r\n\r\n        <view class=\"page__cell_headline_author\">{{author}}分享于</view>\r\n        <view class=\"page__cell_headline_time\">{{share_time}}</view>\r\n    </view>\r\n    <view class=\"page__cell_detail center\">{{content}}</view>\r\n </view>\r\n</template>\r\n\r\n\r\ntemplate 模板的调用：  <view class=\"page__bd\">\r\n    <block wx:for=\"{{intelligence_list}}\" wx:key=\"{{index}}\" center >\r\n        <template is=\"intelligence_list\" data=\"{{...item}}\"></template>\r\n    </block>\r\n  </view>\r\n  \r\n我有话要说~开发的过程中难免会出现各种各样的bug，记得一定要百度，百度，百度呀！！！这是个独立思考的过程，对能力的提高也非常有帮助~做这个项目最大的心得便是看太多不如干一场，肯定会干货满满，收获满满哟~这个小程序后续还会完善，感兴趣的可以持续关注哟(＾Ｕ＾)ノ~一波安利~微信小程序开发教程手册微信小程序官方开发文档使用 easy-mock 构造后台虚拟数据使用微信开发者工具进行开发" } { "title": "开始你的uniapp之旅:写出你的第一个微信小程序 ", "author": "Rolan", "pub_time": "2019-11-18 00:07", "content": "uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。引用官方介绍 , 为什么它可以做到这点 ? uniapp 内置了 Vue.js 如果你熟悉 Vue.js ,  就知道 Vue 的核心只是完成的只是在数据变更后 , 自动帮你把用到这个数据的 \" 对象 \" 中的数据进行更新 , 在浏览器器上它对应着浏览器 dom , 在不同的平台上它可以对应不同的东西 , 这就赋予了 Vue.js 的跨平台能力刚刚说的\"对象\"并不是 Javascript 中 的 Object , 理解成 面向对象编程中的对象更为合适 , 无论它是虚拟的还是现实中的东西 , 它都可以被描述为对象 . 你可以想象吗, 有人已经把 Vue 移植到了带有显示屏的底层硬件上 , 每当 Vue 代码中的数据更新时 , 显示屏上的数据也会被通知更新 .你知道这点就行了 : uniapp 编译时 , 把 Vue template中的基础组件对应不同平台上的基础组件 ,完成了跨平台的工作 .uniapp 跨平台是不是很多坑?你一定会怀疑 unipp 的能力 . 是的 , 必然是有坑的 . 但是坑的层面不是数据层面 , Javascript引擎在不同平台上的解析都是符合规范的  ,一般是 css 样式 或者 api 层面的 , 每个平台对 css和api 的支持不同 ,这个必须你自己去做兼容 , 再好的编译也不可能完全消除原生上带来的差距 . 因此 , 它的坑并不是因为自身的原因 , 而是你对这个平台本身不是很了解 , 写出了不兼容的代码 .如果你不考虑兼容的话 , 我可以说它写小程序是没有坑的 . 你最后写起来会感觉跟小程序差不多 , 但是写起来更爽 .为什么我一定推荐你用 uniapp 写微信小程序?微信小程序用它的语法写不好吗 ? 为什么一定要用 uniapp 呢 . uniapp有几大优势微信的所有api都可以用Vue 的几乎所有语法的支持内置 Vuex 和 Vue-router可以用浏览器调试其他类似于css动画 , vue单文件的优势就不一一说了 .  加粗的每一点都值得你去使用 uniapp .第一点:用 Vue 来写程序 , 你的 Vue 水平和了解程度也会上升不少 , 将来写网页或者其他东西时候 , 用 Vue 也是胸有成竹 .第二点: 微信小程序没有内置 类似 Vuex 的功能 , 导致跨页面 , 跨多级组件的共享数据会非常麻烦 .第三点: 如果你调试过微信小程序就知道 , 每次修改完后编译是多慢 ,展开 dom 是多么麻烦 , 查看数据只能一个 console.log 或者 debugger 来调试 . 但是用 chrome来调试就完全不同了 , 它编译很快 , 可以用 Vue 官方插件 dev-tool 来 查看 v-node 树 , 数据状态和 Vuex , 这个真的是在开发体验和效率上是**降维打击 . **版本较新的浏览器对 css 的支持是一个超集 , 在小程序中的能使用的样式在 chrome 完全兼容, 调试效率也会高一些 , 不过自定义组件要注意一下 , 它的宽高只能由内部撑起 .uniapp 来写小程序有没有缺点呢?有 .微信限制小程序包的大小为 2mb , 但是 uniapp 编译的小程序因为自带 Vue Vuex 等原因 , 会稍稍多几十kb不过不是特别大的问题 . 2. 首次渲染页面速度不如小程序 . 毕竟是要多一层 Vue 的传递所以, 首次加载不如原生 .但是后续的数值更新 , 特别是大量数据的更新 , 因为 Vue 中有 diff 算法使渲染的效率大大提升 .开启 uniapp 的学习第一步:首先下载安装 hbuiderx(标准版) 和 微信开发者工具第二步: hbuilderx 安装完后安装 uniapp 插件 , 其他的插件 比如 scss 编译 等等也可以安装一下 , 全装也没问题哈第三步:微信开发者工具和 uniapp 都安装完后打开微信开发者工具 , 登录账号等等操作设置服务端口 , 先打开你的微信开发者工具 -> 上栏 -> 设置 -> 安全设置 -> 服务端口 -> 开启接着 hbuilderx导航栏 工具 -> 设置 -> 源码视图 这里可以看到右边有设置的json 找到最后一行-> \"weApp.devTools.path\":\"\" 这里填上微信开发者工具的绝对路径 比如我的 : \"weApp.devTools.path\":\"E:/微信web开发者工具\"第四步:两个都设置完后 , hbuilderx 导航栏左上角:文件 -> 新建 -> 项目 -> 选择 uniapp ->选择模板 : Hello uniapp 演示模板 创建-> 导航栏中间:运行 -> 运行到小程序 , 你就可以啦~接下来的学习可以到官方的文档去学习哦~官方的文档" } { "title": "小程序顶部导航栏，可滑动，可动态选中放大效果 ", "author": "Rolan", "pub_time": "2019-11-25 00:36", "content": "老规矩，先看效果图可以看到我们实现了如下功能1，顶部导航栏 2，可以左右滑动的导航栏 3，选中条目放大 原理其实很简单，我这里把我研究后的源码发给大家吧。wxml文件如下<!-- 导航栏 --><scroll-view scroll-x class=\"navbar\" scroll-with-animation scroll-left=\"{{scrollLeft}}rpx\">  <view class=\"nav-item\" wx:for=\"{{tabs}}\" wx:key=\"id\" bindtap=\"tabSelect\" data-id=\"{{index}}\">    <view class=\"nav-text {{index==tabCur?'tab-on':''}}\">{{item.name}}</view>  </view></scroll-view>wxss文件如下/* 导航栏布局相关 */.navbar {  width: 100%;   height: 90rpx;  /* 文本不换行 */  white-space: nowrap;  display: flex;  box-sizing: border-box;  border-bottom: 1rpx solid #eee;  background: #fff;  align-items: center;  /* 固定在顶部 */  position: fixed;  left: 0rpx;  top: 0rpx;}.nav-item {  padding-left: 25rpx;  padding-right: 25rpx;  height: 100%;  display: inline-block;  /* 普通文字大小 */  font-size: 28rpx;}.nav-text {  width: 100%;  height: 100%;  display: flex;  align-items: center;  justify-content: center;  letter-spacing: 4rpx;  box-sizing: border-box;}.tab-on {  color: #fbbd08;  /* 选中放大 */  font-size: 38rpx !important;  font-weight: 600;  border-bottom: 4rpx solid #fbbd08 !important;}js文件如下// pages/test2/test2.jsPage({  data: {    tabCur: 0, //默认选中    tabs: [{        name: '等待支付',        id: 0      },      {        name: '待发货',        id: 1      },      {        name: '待收货',        id: 2      },      {        name: '待签字',        id: 3      },      {        name: '待评价',        id: 4      },      {        name: '五星好评',        id: 5      },      {        name: '差评订单',        id: 6      },      {        name: '编程小石头',        id: 8      },      {        name: '小石头',        id: 9      }    ]  },  //选择条目  tabSelect(e) {    this.setData({      tabCur: e.currentTarget.dataset.id,      scrollLeft: (e.currentTarget.dataset.id - 2) * 200    })  }})代码里注释很明白了，大家自己跟着多敲几遍就可以了。后面会更新更多小程序相关的知识，请持续关注。" } { "title": "最简单的小程序状态管理方案! - mobx-mini ", "author": "Rolan", "pub_time": "2019-12-2 09:15", "content": "写在前面\r\n状态管理可以说是现代前端开发中最核心的一环。为了解决前端应用的复杂度，生态圈里诞生了各式各样的状态管理方案，按编程范式分类有函数式（redux），响应式（rxjs），透明的函数响应式（mobx），按状态存储分类有单 store 和 多 store 的，有专门处理异步代码的（rxjs），还有连异步都不处理的（redux）.....，基本上可以满足各种场景的前端应用。\r\n然而受制于小程序封闭的生态，各种状态方案的绑定库都无法在小程序内使用。已有的绑定库不能用？那就写一个呗。\r\n\r\n状态管理的目标\r\n在迈入正文前，先说一下我们对状态管理方案的一些诉求：\r\n\r\n基于已有的状态管理方案，redux, mobx, rxjs，最大程度复用现有生态\r\nTypescript 友好（ts 真香）\r\nAPI 简单清晰，性能基线高，无需手动优化就能达到不错的性能。\r\n少模板代码，代码敲多了手疼（说的就是 redux）\r\n\r\nrxjs 学习曲线过于陡峭，也没定义状态如何存储，划掉；redux 概念挺多，模板代码和概念一样多，不要。那就剩下 mobx 了。\r\n\r\nAPI\r\n首先定义 store，并连接到页面。\r\n\r\nobserver(context, mapState)\r\nimport { observable } from 'mobx';\r\nimport { observer } from 'mobx-mini';\r\nconst rootStore = observable({\r\n  title: 'mobx-app'\r\n});\r\nconst store = observable({\r\n  count: 0,\r\n  get isOdd() {\r\n    return this.seconds % 2 === 1;\r\n  },\r\n  tick() {\r\n    this.count += 1;\r\n  }\r\n});\r\nconst mapState = () => ({\r\n  count: store.count,\r\n  seconds: store.isOdd,\r\n  title: rootStore.title,\r\n});\r\n// page\r\nPage({\r\n  add() {\r\n    store.tick();\r\n  },\r\n  onLoad() {\r\n    observer(this, mapState);\r\n  },\r\n});\r\n复制代码直接在 axml 中使用吧\r\n<view>count</view>\r\n复制代码\r\n实现原理\r\n如果你还没有对 mobx 有所了解，建议看一下它的中文文档 了解一下前置知识。原理就是 observer  APi 会对参数 mapState 中的 observable 对象注册 autorun 函数，在 autorun 内部，监听到 observable 变动后，直接对页面  setData 。小程序的 data 就会动态更新了。\r\n\r\n总结\r\n提醒一下，暂时只支持支付宝小程序，且未在生产环境中使用过。源码在这里，只有100行不到。github.com/luv-sic/mob…\r\n\r\n参考\r\ncn.mobx.js.org/github.com/b5156/mobx-…" } { "title": "Kbone原理解析 & 小程序技术选型 ", "author": "Rolan", "pub_time": "2019-12-12 00:24", "content": "转载自微信开放社区： https://developers.weixin.qq.com/community/develop/article/doc/0006a6326b8d38e56b998833456813官方介绍“Kbone 是一个致力于微信小程序和 Web 端同构的解决方案。”Web端框架基本原理首先我们来看下普通Web端框架，以Vue框架为例，一份Vue模板对应一个组件，在代码构建阶段编译成调用Dom接口的JS函数，执行此JS函数就会创建出组件对应的Dom树，从而渲染到浏览器页面上。然而，小程序是双线程的，并没有Dom树的概念，逻辑层和视图层完全分离，逻辑层是一个纯粹的JSCore,开发者可以编写JS脚本，但是无法直接调用Dom/Bom的api, 没有任何浏览器相关的实现。在小程序中，视图层和逻辑层的交互是通过数据和时间驱动的。因此，要实现跨端同构，问题是：怎么将web端代码转为小程序代码？业界常规做法目前业界流行的第三方跨端框架们，常规做法都是：静态编译兼容。原理是把代码语法分析一遍，然后将其中的模板部分翻译成对应的跨端需求的模板（微信小程序、支付宝小程序、H5、APP等）。静态编译最大的局限性是无法保证转换的完整性，因为Vue模板和WXML模板的语法并不是直接对等的，Vue的特性设计也和小程序的设计无法划等号，这自然就导致了部分Vue特性的丢失。比如像Vue中的v-html指令、ref获取Dom节点、过滤器等就通通用不了。除了Vue自身的特性外，一些原本依赖Dom/Bom接口的Vue插件页无法使用，例如Vue-Router。Kbone的做法Kbone是通过提供 适配器 的方式来实现同构，即运行时兼容，而非静态编译。Kbone的适配器核心包含两个部分：miniprogram-render： 仿造Dom/Bom接口，构造仿造Dom树；miniprogram-element: 监听仿造Dom树变化，渲染到页面，同时监听用户行为，触发事件。仿造Dom树和浏览器的运行时对比：仿造Dom树：利用内置组件和自定义组件的自引用来进行递归，创建组件树。如图，自定义custom-dom为递归自引用组件：递归的终止条件是遇到特定节点、文本节点或者children空节点。在创建出组件树猴，将Dom节点和自定义组件实例进行绑定，以便后续的Dom更新和操作。kbone这里还对节点数进行了优化：如果一个dom节点对应一个自定义组件的话，就会创建很多自定义组件，这样会很浪费开销，这里做了子树的合并，也就是说3层才创建一个自定义组件，节省开销。优化前：17个dom=17个自定义组件； 优化后：17个dom=4个自定义组件，蓝色那个是单节点，会合并到上面的树；dom 子树作为自定义组件渲染的层级数是可以通过配置传入，理论上层级越多，使用自定义组件数量越少，性能也就越好。一棵很大的 Dom 树，一次性 setData 到视图层，可能会超过 setData 的大小限制（1024kB），拆分成多棵子 Dom 树，然后分批的 setData 到视图层，可以节省开销。事件监听小程序的事件是视图层到逻辑层的通讯方式，事件绑定在组件上，当被触发时，就会执行逻辑层中对应的事件处理函数。小程序的捕获冒泡是在视图层view端，因此逻辑层在整个捕获冒泡流程中各个节点接收到的事件不是同一个对象，小程序事件的捕获冒泡和阻止冒泡等操作必须在WXML模板中生命，无法使用接口实现。为了能够让web端和小程序端的事件系统行为一致，kbone除了仿造了一份Dom树外，也把整个事件系统仿造了一份，即在仿造Dom树上进行捕获冒泡。当自定义组件监听到用户的操作后，就将事件发往仿造Dom树，后续自定义组件监听到的同一个事件的冒泡就直接忽略。当触发改节点，仿造Dom树接收到事件后，再进行捕获和冒泡，让事件在各个节点触发。Kbone的优势支持多个前端框架：Vue、React、Preact 等支持更为完整的前端框架特性： Vue 中的 v-html 指令、Vue-router 插件等提供了常用的 dom/bom 接口可以使用小程序本身的特性： live-player 内置组件、分包功能等提供一些 Dom 扩展接口：getComputedStyle 接口等Kbone实践脚手架kbone-cli官方已经提供了kbone-cli可以用来快速开发：用npm全局安装kbone-cli可以根据自己的技术栈选择不同的开发模板：React/Vue/Omi/Preact然后就可以愉快的进行开发啦~生成的demo项目结构如下：demo中包含了多页跳转、vue-router、vuex等的使用示例，以及mp-webpack-plugin的配置示例。对于多页面的应用，在 Web 端可以直接通过 a 标签或者 location 对象进行跳转，但是在小程序中则行不通。同时 Web 端的页面 url 实现和小程序页面路由也是完全不一样的。Demo示例对比其中，有一部分两端差异的业务逻辑功能，也给出了3中不同的解决方案：利用vue-improve-loader，在构建时对dom树节点进行删减，在需要提出的节点加上check-reduce属性 利用reduce-loader，将业务中不需要被打包的代码进行去除，使用行内loader和环境变量来判断 使用样式隐藏，即设置不需要显示的节点样式为 display:none其他问题在实际开发中，还会碰到一些细节，例如：多页面开发：修改webpack和mp-webpack-plugin配置小程序内置组件： 部分用html标签代替，其他用wx-component + behavior标签小程序自定义组件：修改mp-webpack-plugin配置，补充wxCustomComponents字段，将自定义组件放入组件根目录，使用自定义组件自定义app.js和app.wxss：监听app的生命周期，修改webpack配置补充app.js的构建入口，修改插件配置的generate.app字段，补充app.js扩展dom/bom对象和API：使用 window.$$extend追加方法代码优化：用reduce-loader做体积精简，dom树精简用vue-improve-loader区分环境实现不同功能：process.env.isMiniprogram更新迭代kbone由于目前在快速发展期，更新迭代非常迅速，以下特性是对比了8月份的版本和11月份版本，可以看出已经解决了近2/3的问题。小程序技术选型详细了解了kbone之后，我们来分析下小程序技术框架到底应该怎么选？kbone & 小程序原生已有web版，需要小程序版：kbone跨平台需求（web + 小程序）：kbone对性能特别苛刻 or 追求稳定 or 要用最新功能：小程序原生页面节点数量特别多（ 1000 节点以上），且对渲染性能要求高：静态模板转义方案（第三方框架：mpvue/taro等）第三方框架MpVue ：不推荐再用了，坑越来越多，内部也表示之后不会投入太多维护WePY 1.7.x ：不推荐再用了：1.7.x 的版本在最初的设计上的缺陷导致遗留了很多比较严重的问题WePY 2.0：现在还是 alpha 阶段，内外部有一些小程序在跑，体验和反馈还可以。但依然 issue 比较多。害怕踩坑的也不推荐使用Taro: 也还是有不少问题，但相对来说应该是比 mpVue 和 WePY 更稳定一点Uni-app：mpvue的衍生版，跨端 (官方示例有6端) 支持的很好，在H5端实现了一套微信模拟器，可以尝试，是目前唯一支持app端的商用方案，有独立的编辑器HBuildXChameleon: 统一的多态协议，渐进式跨端，提供脚手架命令工具，规划比较宏大Omi ：基于Taro完成的框架，kbone有支持omi的模板Nanachi: 基于react的编译期间的转义框架总结没有跨端需求，只需要微信小程序 ==> 小程序原生web端转小程序 or 两端 or 想要尝鲜 ==> kbone多端 or Vue 技术栈 ==> uni-app多端 or React 技术栈 ==> taro不介意学习新技术栈 ==> wepy 2.0 or chaemeleon写在最后小程序在非常快速的更新迭代，就算是原生框架也还是有一些坑的，因此没有哪种框架是百分之百完美，需要根据业务具体需求以及自身技术栈偏好来进行选择。文章中提及到的部分第三方框架只是参考了官方文档，没有逐个一一尝试，有问题麻烦指出，鞠躬~~" } { "title": "纯CSS实现圆环型进度条 ", "author": "Rolan", "pub_time": "2019-12-27 00:07", "content": "以下内容来自于去年的一次案例，随着微信小程序的不断改版，部分条件可能已不再适用，请谨慎参考。内容比较短，主要都在代码片段里。案例某个项目中需要用到如下图这样的一个圆环行的进度条。一开始的想法是使用canvas来实现，但是canvas是原生组件，层级最高（当时的情况），实际使用时不方便使用。所以决定尝试用纯CSS来实现这一效果。实现原理先上代码：https://developers.weixin.qq....这里主要用到的是CSS中的clip属性，将一个正方形裁剪后只显示右侧一半，但是仍然以正方形中心为圆心来旋转，来实现需要的角度。clip: rect(0rpx, 46rpx, 92rpx, 0rpx);这样最上面那个进度条就可以由以下三部分叠加，在最上面再叠加一个小一号的白色圆形，最外层加上圆角后就可以实现。（下图中红线示例了最外层的圆角以及最上层叠加的白色圆形位置）叠加效果用到蓝色圆环小于180度的情况下，需要把背景色和前景色对调。" } { "title": "小程序标签展开收起功能实现 ", "author": "Rolan", "pub_time": "2019-12-27 00:41", "content": "先看效果主要结构我用的mpvue，如用原生标签直接转换成原生即可<div id=\"labelBox\">\r\n    <div class=\"label userLabel\" v-for=\"(label,inx) in labelList\" :key=\"inx\">{{label}}</div>\r\n    <div class=\"more\" v-show=\"showLabel===1\" id=\"moreLabel\" @click=\"openMore\">\r\n        <div>全部{{allLabel.length}}个</div>\r\n        <img class=\"icon ml5\" src=\"/static/img/i_label_down.png\" />\r\n    </div>\r\n    <div class=\"more\" v-show=\"showLabel===2\" @click=\"closeMore\">\r\n        <div>收起</div>\r\n        <img class=\"icon ml5\" src=\"/static/img/i_label_up.png\" />\r\n    </div>\r\n</div>export default {\r\n    data() {\r\n        return {        \r\n            labelList: [],  // 视图显示的标签集合\r\n            allLabel: [],   // 所有的标签集合\r\n            firstLabel: [], // 默认显示的标签集合\r\n            showLabel: 1,   // 0 两个按钮都不显示，1 显示展开，2 显示收起\r\n        }\r\n    },\r\n    ...\r\n}思路利用小程序api NodesRef.boundingClientRect 获取节点的位置与大小信息，主要用到 width,left,right循环所有标签(.userLabel)，看是否有多行，通过所有节点的 left 去判断，如果 left 相同的有多个，就证明有多行获取标签父级(#labelBox)的宽度 width获取到按钮(#moreLabel)的宽度过滤第一行节点的 right，如果与按钮的width相加小于等于父级盒子的width就保留 具体的代码\r\n wxp为微信接口Promise化，会在之后列出用到的\r\n\r\n export default {\r\n    data() {\r\n        return {        \r\n            labelList: [],  // 视图显示的标签集合\r\n            allLabel: [],   // 所有的标签集合\r\n            firstLabel: [], // 默认显示的标签集合\r\n            showLabel: 1,   // 0 两个按钮都不显示，1 显示展开，2 显示收起\r\n        }\r\n    },\r\n    methods: {\r\n        async loadPageData(){\r\n            // 请求后台数据\r\n            const res = ...\r\n\r\n            // 设置\r\n            this.allLabel = res.labes;          // 记录所有的标签\r\n            this.labelList = this.allLabel;     // 先插入所有表情\r\n            // 设置状态\r\n            if(this.allLabel.length>0){\r\n                await wxp.timeout(300); // 插入视图之后不会马上获取到节点信息，延迟获取\r\n                this.setLabelStauts();\r\n            }\r\n            \r\n        },\r\n\r\n        // 设置标签状态\r\n        async setLabelStauts(){\r\n            const boxDom = await wxp.getElementById('#labelBox');\r\n            const labelDoms = await wxp.getElementsByClassName('.userLabel');\r\n            const btnDom = await wxp.getElementById('#moreLabel');\r\n            const left = labelDoms[0].left;\r\n\r\n            // 分行转为二维数组\r\n            let lineArr = [];       \r\n            let lineIndex = -1;\r\n            labelDoms.forEach(v => {\r\n                if(v.left==left){\r\n                    lineIndex++;\r\n                    lineArr[lineIndex] = [];\r\n                }\r\n                lineArr[lineIndex].push(v);\r\n            })\r\n\r\n            // 超过一行\r\n            if(lineArr.length>1){\r\n                // 默认显示加载更多按钮\r\n                this.showLabel = 1;\r\n                const firstTr = lineArr[0].filter(v => (v.right+btnDom.width+(left/15*15)) <= boxDom.width);\r\n                this.firstLabel = this.allLabel.slice(0,firstTr.length);\r\n                this.labelList = this.firstLabel;\r\n            }else{\r\n                this.showLabel = 0;\r\n            }\r\n        },\r\n\r\n        // 展开\r\n        openMore(){\r\n            this.showLabel = 2;\r\n            this.labelList = this.allLabel;\r\n        },\r\n        // 收起\r\n        closeMore(){\r\n            this.showLabel = 1;\r\n            this.labelList = this.firstLabel;\r\n        }\r\n    }\r\n}wxp.js相关代码/**\r\n * 延时\r\n * @param {*} delay \r\n */\r\nexport const timeout = delay => new Promise(resolve => setTimeout(resolve, delay));\r\n\r\n/**\r\n * 根据ID获取dom的盒模型信息\r\n * @param {*} id \r\n */\r\nexport const getElementById = (id='') => {\r\n    return new Promise((resolve, reject) => {\r\n        if ((typeof id).toLowerCase() !=='string'){\r\n            const err = {\r\n                errMsg: '请输入字符串，例如 #box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else if (id.indexOf('#') < 0) {\r\n            const err = {\r\n                errMsg: '请输入ID，例如 #box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        }else{\r\n            var query = wx.createSelectorQuery()\r\n            query.select(id).boundingClientRect();\r\n            query.selectViewport().scrollOffset();\r\n            query.exec(rect => {\r\n                if (rect[0]){\r\n                    let info = rect[0];\r\n                    info.position = {\r\n                        left: rect[1].scrollLeft + info.left,\r\n                        top: rect[1].scrollTop + info.top\r\n                    };\r\n                    resolve(info);\r\n                }else{\r\n                    const err = {\r\n                        errMsg: '没有获取到信息'\r\n                    }\r\n                    reject(error(err.errMsg,err));\r\n                }\r\n            })\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * 根据类名获取dom信息\r\n * @param {*} className \r\n */\r\nexport const getElementsByClassName = (className = '') => {\r\n    return new Promise((resolve, reject) => {\r\n        if ((typeof className).toLowerCase() !== 'string') {\r\n            const err = {\r\n                errMsg: '请输入字符串，例如 .box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else if (className.indexOf('.') < 0) {\r\n            const err = {\r\n                errMsg: '请输入类名，例如 .box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else {\r\n            wx.createSelectorQuery().selectAll(className).boundingClientRect(rects => {\r\n                resolve(rects);\r\n            }).exec();\r\n        }\r\n    })\r\n}作者：不二很纯洁链接：https://www.jianshu.com/p/87f3c14038a6" } { "title": "xquery小程序简易步进器 ", "author": "Rolan", "pub_time": "2019-12-30 00:29", "content": "这样一个简单的组件，翻了ant.design才知道这种组件叫做步进器(steper)，步进器常用于购物车等需要增减数量的场景，最近的旅游项目中用于增减房间数和人数，从产品的角度来理解步进器很简单，但在开发角度来说需要适应多种场景及控制一些状态边界值(最大值，最小值)，初始值，步进值(一次增减数量)需要可控边界状态，即超出后显示为什么状态可供外部设置边界状态的api方法内部加减方法可供外部调用的加减方法(一些场景中，外部有一个总量约束，比如sku场景)加减回调方法，比如当数量超出时提示用户相关信息多实例模式，实例之间即隔离又能交互大致需求如上，demo及实现部分如下GITHUB源码小程序代码片段wxml<view class=\"container\">\r\n  <ui-item item=\"{{steperConfig}}\" />\r\n</view>\r\n复制代码Page因为是直接使用Item组件实现，所以组件写在Page页面中，当然独立成组件看需求了const Pager = require('../components/aotoo/core/index')\r\nlet lib = Pager.lib\r\n\r\nfunction mkSteper(id=lib.suid('step_'), min, max, step=1) {\r\n  return {\r\n    $$id: id,\r\n    itemClass: 'steper-class',\r\n    title: [\r\n      {title: '-', aim: 'reduce', itemClass: 'steper-reduce'},\r\n      {title: '0', aim: 'custom', itemClass: 'steper-counter'},\r\n      {title: '+', aim: 'plus', itemClass: 'steper-plus'},\r\n    ],\r\n    methods: {\r\n      __ready(){\r\n        this.count = 0\r\n        this.min = min||0\r\n        this.max = max||10\r\n        this.step = step||1\r\n        this.stat = {\r\n          reduce: true,\r\n          plus: true,\r\n          count: true\r\n        }\r\n      },\r\n      reduce(e, param, inst){\r\n        let step = this.step\r\n\r\n        if (!inst) {\r\n          inst = this.children[0]\r\n        }\r\n\r\n        if (e === false) {\r\n          this.stat.reduce = false\r\n          inst.addClass('disable')\r\n        }\r\n\r\n        if (e === true) {\r\n          this.stat.reduce = true\r\n          inst.removeClass('disable')\r\n        }\r\n\r\n        if (typeof e === 'number') {\r\n          step = e\r\n        }\r\n\r\n        this.count -= step\r\n        if (this.count <= this.min) {\r\n          this.count = this.min\r\n          this.stat.reduce = false\r\n          inst.addClass('disable')\r\n        }\r\n\r\n        if (this.count < this.max && !this.stat.plus) {\r\n          this.stat.plus = true\r\n          let $plus = inst.siblings('steper-plus')\r\n          $plus.removeClass('disable')\r\n        }\r\n        this.changeNum(inst)\r\n        this.hooks.emit('reduce', {count: this.count}, this)\r\n\r\n      },\r\n      plus(e, param, inst){\r\n        let step = this.step\r\n\r\n        if (!inst) {\r\n          inst = this.children[2]\r\n        }\r\n\r\n        if (e === false) {\r\n          this.stat.plus = false\r\n          inst.addClass('disable')\r\n        }\r\n        if (e === true) {\r\n          this.stat.plus = true\r\n          inst.removeClass('disable')\r\n        }\r\n        if (typeof e === 'number') {\r\n          step = e\r\n        }\r\n\r\n        this.count += step\r\n        if (this.count >= this.max) {\r\n          this.count = this.max\r\n          this.stat.plus = false\r\n          inst.addClass('disable')\r\n        }\r\n        if (this.count > this.min && !this.stat.reduce) {\r\n          this.stat.reduce = true\r\n          let $reduce = inst.siblings('steper-reduce')\r\n          $reduce.removeClass('disable')\r\n        }\r\n        this.changeNum(inst)\r\n        this.hooks.emit('plus', {count: this.count}, this)\r\n      },\r\n      changeNum(inst){\r\n        let count = this.count\r\n        if (typeof inst === 'number') {\r\n          count = inst\r\n          inst = undefined\r\n        }\r\n\r\n        if (!inst) {\r\n          inst = this.children[1]\r\n        }\r\n\r\n        let $counter = inst.siblings('steper-counter')\r\n        $counter.update({\r\n          title: count\r\n        })\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nPager({\r\n  data: {\r\n    steperConfig: mkSteper('steper'),\r\n  },\r\n  onReady(){\r\n    let $steper = this.getElementsById('steper')\r\n    $steper.hooks.on('plus', function(param) {\r\n      if (this.count === 10) {\r\n        Pager.alert('不能再多了，仓库没货了')\r\n      }\r\n    })\r\n    $steper.hooks.on('reduce', function(param) {\r\n      if (param.count <= 0) {\r\n        Pager.alert('大哥，买点啊')\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码" } { "title": "红包小程序小结 ", "author": "Rolan", "pub_time": "2019-12-30 00:33", "content": "最近做了一个红包兑换小程序，遇到了一些问题这里做一下总结。1、需求：回流用户在游戏客户端获取到口令，然后在小程序这边输入口令兑换红包，成功之后钱会发到用户微信账户里。2、流程：若未授权，显示授权按钮。点击授权登录，授权成功后获取到私密字段iv和encryptedData，调取登陆接口，错误则提示相关信息，正确则跳转校验姓名和身份证的页面，校验通过就调取提现接口，成功则提示提现成功，同时显示生成分享图按钮。分享图由用户昵称，头像，二维码，提现金额等等组成。3、框架：uniapp分享图的问题1、 measureText 获取宽度的时候，传入的参数如果是数字，则会返回0。let money = 10;  //这里需要把数字转成字符串\r\nctx.measureText(money).width;\r\n2、绘制图片的时候不要忘了先使用 getImageInfo 转成临时地址，再 drawImage ，如果不经过这步，虽然开发者工具上看到是正常的，但是真机是显示不了。3、需要绘制微信头像的时候，要在后台配置downloadFile合法域名 https://wx.qlogo.cn 4、最初背景图大概170KB，尺寸750*1334，最终绘制出来的分享图太大了。解决方法：把背景图片尽量再压缩，最终是60多KB。调 canvasToTempFilePath 的时候，设置 fileType 为jpg，quality范围是(0,1]，取个合适的值。 5、小程序里面的保存图片并不是长按保存的，需要点击按钮授权。<button  open-type=\"getUserInfo\"  @getuserinfo=\"onGotUserInfo\"></button>、\r\n...\r\nonGotUserInfo(e){\r\n\tuni.saveImageToPhotosAlbum({\r\n\t\tfilePath: this.tempPath,\r\n\t\tsuccess(res) {\r\n\t\t\tuni.showToast({\r\n\t\t\t  title: '保存成功',\r\n\t\t\t  icon: 'success',\r\n\t\t\t  duration: 1500\r\n\t\t\t})\r\n\t\t},\r\n\t\tfail(err){\r\n\t\r\n\t\t}\r\n\t})\r\n}\r\n...\r\n如图：如果用户点击确定，就会正常保存图片到本地相册了。如果用户点击取消，不授权呢？那还能怎么样，点击再弹出原来的弹窗重新授权呗。很遗憾，这里并不能像授权登录弹窗一样点了取消之后，再次点击授权按钮还会唤起那个弹窗。解决方法：在 saveImageToPhotosAlbum 的fail回调函数里面操作，再次获取保存到相册权限。if (err.errMsg === \"saveImageToPhotosAlbum:fail:auth denied\" || err.errMsg === \"saveImageToPhotosAlbum:fail authorize no response\" || err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n  uni.showModal({\r\n\ttitle: '提示',\r\n\tcontent: '需要您授权保存相册',\r\n\tshowCancel: false,\r\n\tsuccess:res=>{\r\n\t  uni.openSetting({\r\n\t\tsuccess(settingdata) {\r\n\t\t  if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n\t\t\tuni.showModal({\r\n\t\t\t  title: '提示',\r\n\t\t\t  content: '获取权限成功,再次点击保存图片按钮即可保存',\r\n\t\t\t  showCancel: false,\r\n\t\t\t})\r\n\t\t  } else {\r\n\t\t\tuni.showModal({\r\n\t\t\t  title: '提示',\r\n\t\t\t  content: '获取权限失败，将无法保存到相册哦~',\r\n\t\t\t  showCancel: false,\r\n\t\t\t})\r\n\t\t  }\r\n\t\t},\r\n\t\tfail(failData) {\r\n\t\t  console.log(\"failData\",failData)\r\n\t\t},\r\n\t\tcomplete(finishData) {\r\n\t\t  console.log(\"finishData\", finishData)\r\n\t\t}\r\n\t  })\r\n\t}\r\n  })\r\n}\r\n点击取消按钮之后，会跳转到这里。打开设置里的“保存到相册”的开关即可。原生微信小程序和uniapp框架的一些对比针对此次项目，这里挑两点来写。全局变量的管理1、原生微信小程序可以在app.js的globalData对象中对全局变量进行管理app.jsApp({\r\n    globalData: {\r\n        session:\"\"\r\n    }\r\n})\r\npages/index/index.js...\r\nconst app = getApp()//获取应用实例\r\napp.globalData.session = \"xxxx\" //设置\r\napp.globalData.session  //读取\r\n...\r\n2、uniapp用的是vue的那套，所以可以用vuex来管理状态import Vue from 'vue'\r\nimport Vuex from 'vuex'\r\nVue.use(Vuex);\r\nconst store = new Vuex.Store({\r\n\t state : {\r\n\t\tsession:\"\"\r\n\t },\r\n\t mutations : {\r\n\t\tgetSession(state, res){\r\n\t\t\tstate.session = res;\r\n\t\t},\r\n\t }\r\n});\r\nexport default store\r\n设置this.$store.commit('getSession',res.session) //接口返回res.session\r\n获取this.$store.state.session\r\n页面获取全局函数返回的值1、原生微信小程序，比如在app.js中获取用户信息保存在 globalData 中userInfo字段，然后页面在onload的时候获取全局的userInfo，你会发现有时候拿不到。由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回，所以需要加入 callback 以防止这种情况。app.jsApp({\r\n  onLaunch: function() {\r\n    this.init()\r\n  },\r\n  init: function() {\r\n    // 获取用户授权结果\r\n    wx.getSetting({\r\n      success: (res) => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          wx.getUserInfo({ // 获取用户信息\r\n            success: res => {\r\n              this.globalData.userInfo = res.userInfo;\r\n              if (this.userInfoReadyCallback) {\r\n                this.userInfoReadyCallback(res)\r\n              }\r\n            },\r\n            //拒绝授权\r\n            fail: res => {\r\n\r\n            }\r\n          })\r\n        } else {\r\n\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    userInfo: \"\"\r\n  }\r\n})\r\npages/index/index.jsconst app = getApp()\r\nPage({\r\n  data: {\r\n\tuserInfo:\"\"\r\n  },\r\n  onLoad: function() {\r\n    if (app.globalData.userInfo) {\r\n      this.setData({\r\n        userInfo: app.globalData.userInfo,\r\n      })\r\n    } else{\r\n      app.userInfoReadyCallback = res => {\r\n        this.setData({\r\n          userInfo: res.userInfo,\r\n        })\r\n      }\r\n    } \r\n  },\r\n})\r\n2、uniapp是配合vuex和计算属性computed来处理的APP.vueexport default {\r\n\tonLaunch: function() {\r\n\t\tthis.getUserInfo();\r\n\t},\r\n\tmethods:{\r\n\t\tgetUserInfo() {\r\n\t\t\tuni.getSetting({\r\n\t\t\t  success: (res) => {\r\n\t\t\t\tif (res.authSetting['scope.userInfo']) {\r\n\t\t\t\t  uni.getUserInfo({ // 获取用户信息 \r\n\t\t\t\t\tsuccess: res => {\r\n\t\t\t\t\t\tthis.$store.commit('userInfo',{\r\n\t\t\t\t\t\t\tavatarUrl:res.userInfo.avatarUrl,\r\n\t\t\t\t\t\t\tnickName:res.userInfo.nickName\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t},\r\n\t\t\t\t\tfail: res => {\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t  })\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t})\r\n\t\t},\t\r\n\t}\r\n}\r\npages/index/index.vue获取到 userInfo 便可以使用了，如果需要，还可以使用watch监听。export default {\r\n\tdata() {\r\n\t\treturn {\r\n\r\n\t\t} \r\n\t},\r\n\tonLoad(){\r\n\t\t\r\n\t},\r\n\tcomputed: {\r\n\t\tuserInfo() {\r\n\t\t\treturn this.$store.state.hasUserInfo\r\n\t\t}\r\n\t},\r\n\twatch:{\r\n\t\tuserInfo(val){\r\n\t\t\tif(val){\r\n\t \t\t \t\r\n\t \t\t}\r\n\t \t}\r\n\t},\r\n\tcreated() {\r\n\r\n\t},\r\n\tmethods: {\r\n\t\t\r\n\t}\r\n}" } { "title": "从CSS角度来做一个模态框 ", "author": "Rolan", "pub_time": "2019-12-30 00:42", "content": "今天我们从CSS角度来做一个下图这种模态框。先上代码： https://developers.weixin.qq....模态框背后的背景是一个fixed定位，四个方向都为0的view，主要是怎么实现中间弹窗的垂直水平居中，这里提供两个方案。1、定位这种方案是将弹窗设置绝对定位后，左边（上边）距设为50%，就是弹窗左上角距父级左上角的距离正好是父级的宽度（高度）的50%，就是在正中间，同时使用 transform 属性，将弹窗向左（上）移动自身宽度（高度）的50%，来实现弹窗正好在水平（垂直）方向都能居中。position: absolute;\r\ntop: 50%;\r\nleft: 50%;\r\ntransform: translateX(-50%) translateY(-50%);2、flex布局这种方案更简单，只需要将父级设置为flex布局的同时设置 justify-content 和 align-items都是 center 就可以了。display: flex;\r\njustify-content: center;\r\nalign-items: center;彩蛋模态框弹出后，在父级上加上 catchtouchmove=\"ture\" 就可以阻止背后页面的上下滚动。" } { "title": "小程序中解决网络请求缓存 ", "author": "Rolan", "pub_time": "2019-12-30 00:45", "content": "需求\r\n提交小程序审核时，有一个体验测评，产品让我们根据小程序的体验测评报告去优化小程序。\r\n其中有一项是网络请求的优化，给我们出了很大的难题。\r\n文档中是这样解释的：3分钟以内同一个url请求不出现两次回包大于128KB且一模一样的内容\r\n看到这个问题的时候，首先想到的是在响应头上加上cache-control，经过测试发现小程序并不支持网路请求缓存。搜索发现官方明确答复，小程序不支持网络请求缓存：wx.request不支持http缓存\r\n既然官方不支持网络请求缓存，那只能自己想办法解决这个问题了。\r\n先来看一下需求：3分钟内，同一请求只能请求一次。\r\n分析\r\n分析：\r\n\r\n只需做GET请求的网络缓存。\r\n缓存时间如何控制。\r\n做了缓存之后，如何知道3分钟，这个请求在服务端数据有没更新。\r\n提交GET请求前，先检查本地有没有缓存\r\n\r\n前两点比较好实现，虽然小程序不支持网络请求缓存，但我们还是可以利用cache-control来实现这个功能。\r\n首先网络请求需不需要情缓存统一交给服务端去做，服务端在处理GET请求时，统一加上响应头cache-control，如果需要缓存就用max-age=180，如果不需要做网络请求就用no-cache。前端根据响应头信息自己做前端缓存。\r\n其中的难点是前端如何知道服务端数据有没更新，如果服务端数据更新了，前端还是使用缓存这是有问题的。\r\n经过一番思考后发现，前端提交数据后，相应的GET请求数据会更新，也就是说前端只要有数据提交，就应该把缓存清空。\r\n这有一个难点，当前端提交数据时，前端是不知道哪些GET请求会因此更新数据，所以这个问题我们没有解决，我的方法比较粗暴：只要前端提交了数据，就将所有缓存清空。这是一个治标不治本的问题。\r\n实现\r\n公司项目封装了HTTP请求\r\n\r\n拦截请求，如果是GET请求，检查缓存，\r\n\r\n如果缓存没过期，将缓存返回出去，不再发请求\r\n如果缓存过期，发请求\r\n\r\n\r\n\r\nif (request.method.toLowerCase() === \"get\"){\r\n  // param 请求信息\r\n  const cache = this.handleCatchControl(request)\r\n  if (!cache.isRequest)\r\n    return this.listener.onApiResponse(request, 200, cache.data), sequence;   //将缓存返回给对应的请求\r\n}\r\n复制代码\r\n缓存网络请求\r\n\r\n// param 响应头，上下文，响应数据\r\nthis.setCatchControl(headers, context, response.data)\r\n复制代码\r\n两个工具函数\r\n\r\n处理网络缓存\r\n设置网络缓存\r\n\r\n\r\n\r\n\r\n设置网络请求\r\n\r\nGET请求缓存数据，其他请求清空数据\r\n数据格式：\r\n\r\n//如果同时发起多个`GET`请求，需要拼接之前缓存数据\r\nApiAgent.cacheData = Object.assign(ApiAgent.cacheData,{\r\n  [context.request.url]: {    //api\r\n    data,   //响应数据\r\n    expireTime: Number(cacheControl.split(\"=\")[1] + '000'),   //过期时间\r\n    cacheTime: new Date().getTime(),    //缓存时间\r\n  }\r\n})\r\n复制代码\r\n\r\n// param 响应头，上下文，响应数据\r\nsetCatchControl(responseHeader: any, context: any, data: any) {\r\n  if (context.request.method.toLowerCase() === \"get\") {\r\n    const headers = HandleHeaders.get(responseHeader)\r\n    const cacheControl = headers[\"cache-control\"]\r\n    if (cacheControl && cacheControl !== \"no-cache\") {\r\n      ApiAgent.cacheData = Object.assign(ApiAgent.cacheData,{\r\n        [context.request.url]: {\r\n          data,\r\n          expireTime: Number(cacheControl.split(\"=\")[1] + '000'),\r\n          cacheTime: new Date().getTime(),\r\n        }\r\n      })\r\n    }\r\n  } else {\r\n    ApiAgent.cacheData = {}\r\n  }\r\n}\r\n复制代码\r\n处理网络缓存\r\n\r\n判断缓存是否存在\r\n判断缓存有没过期，在设置缓存时，比对当前时间和缓存时间，是否小于失效时间\r\n\r\n\r\n\r\n// param 请求信息\r\nhandleCatchControl(request): any {\r\n  const cacheArr = ApiAgent.cacheData\r\n  if (Object.keys(cacheArr).length === 0)\r\n    return { isRequest: true }\r\n  let cache = {}\r\n  Object.keys(cacheArr).forEach(cacheArrKey => {\r\n    if (cacheArrKey === request.url) {\r\n      cache = cacheArr[cacheArrKey]\r\n    }\r\n  })\r\n  const newDate = new Date().getTime()\r\n  if (newDate - cache.cacheTime < expireTime){\r\n    return { isRequest: false, data: cache.data }\r\n  }\r\n  return { isRequest: true}\r\n}\r\n复制代码\r\n响应头全部变成小写，在小程序中，无法确定响应头的大小写会导致报错，所以统一处理响应头\r\n\r\nclass HandleHeaders {\r\n  static get(headers: { [key: string]: string }) {\r\n    const headersData: any = {}\r\n    Object.keys(headers).forEach(key => {\r\n      headersData[key.toLowerCase()] = headers[key]\r\n    })\r\n    return headersData\r\n  }\r\n}\r\n复制代码总结\r\n有一点没有说，就是这个缓存是保存在哪里的？\r\n既没有用localStorage，也没有用globalapp，用的是类的静态属性。\r\n这样做有3个好处：\r\n\r\n使用localStorage数据不好清除，后期可维护性也较差\r\n缓存挂在globalapp和请求无直接联系\r\n无需在退出小程序时手动清理缓存\r\n\r\n我在使用时遇到一个坑，是因为自己没有理解：类能保存数据的，不能保存状态，但类的对象是既可以保存数据，也可以保存状态的。\r\n最后，此方法还是有很大的优化空间。\r\n另外可添加微信ttxbg180218交流" } { "title": "小程序初实践总结 ", "author": "Rolan", "pub_time": "2019-12-31 00:05", "content": "近期组内接了小程序项目，也是有幸能够加入到项目中，做一些简单的开发。之前对小程序有所接触，但是仅限于自己了解和书写demo，真正项目开发还是第一次~开发过程中也是遇到了一些不熟悉和自己觉得是小坑的地方，做个简单总结，给自己做个记录，同时给需要的小伙伴一些小小参考。一、添加一个新组建，控制台报错“Component is not found in path '../../components/xx/xx'”。答：这个问题开始是很迷茫的，仔细检查了文件名称、引用路径以及父组件usingComponents，都没有发现有问题，但是控制台依旧提示找不到对应组件。后面经过大老提示： 对于一个新的组件，必须在对应的js里添加Component({})，json文件里也要写上component:true。加上相关配置后，控制台就不会飘红了。二、text组件，默认会出现上内边距。答：使用text组件展示文字内容，看上去并没有什么技术而言，直接引用就好了（心里默默开森）<text>\r\n  this is component\r\n</text>复制代码但是，看到效果之后，显然有点蒙圈，为什么上边会出现那么大的距离啊？！第一个想法是去看css，是否有默认内边距样式，然而并没有；通过padding、margin去设置值，也没什么用；然后。。然后。。。我就不知道怎么办了，只好请教度娘。网上有小伙伴给出了答案，其实并不是样式问题，而是text组件本身问题，要修改这个问题，只需要把text标签和内容写在一行就可以了。<text>this is component</text>\r\n复制代码三、小程序分享功能，页面分享和按钮分享功能。答：众所周知，小程序是可以进行分享的，有两种方式，一个是自带的分享功能，另一个是页面上按钮点击分享。本质上他们调用的是同一个方法，即onShareAppMessage，可以通过options参数的options.from区分是来自按钮还是原生分享，可以通过设置对应字段修改分享展示的内容，不设置则默认分享当前页。onShareAppMessage (res) {\r\n  // 来自页面内转发按钮    \r\n  if (res.from === 'button') {\r\n     return {\r\n        title: `标题`,      //分享标题        \r\n        path: shareUrl,    //分享的链接        \r\n        imageUrl:‘’        //分享展示的图片           \r\n     };    \r\n   } else {      \r\n     return {        \r\n       title: `分享标题`,        \r\n       imageUrl:''    \r\n     };\r\n   }\r\n}复制代码按钮分享，只需要给button添加一个open-type即可，<button open-type=\"share\"></button>。但是此时按钮会有默认样式，可以通过控制台查看，进行css修复样式，分享回调同样调用上边方法。四、小程序内获取某个元素或者组件距离顶部初始高度答：实际开发中，我们基本会遇到需要获取某个元素位置信息的需求，早在jq一把梭的时代，获取这些属性值是很容易的，直接一个api就可以了。同样的小程序里也有比较实用的方法，我们可以给需要获取位置的元素/组件一个id，然后通过下面方法即可获取：let query = wx.createSelectorQuery().in(this);\r\nquery.select('#testId').boundingClientRect(function(rect){\r\n    //rect即包含了所需要的各种位置信息，如top、left、right、bottom等\r\n})复制代码如果在页面初始化时需要获取到位置，可以在onLoad方法里使用（最好使用setTimeout，否则可能会取不到），获取对应值之后就可以进行后续的处理了。五、scroll-view组件使用答：滚动组件的使用，在开发中可以说很普遍了。小程序也封装了scroll-view组件，并提供了一些封装好的方法，使用起来可以说很方便了，但是也不可避免的有一些需要注意的地方。1、scroll-view的绑定scroll事件不触发当页面组件按照文档方法书写完成后，去滚动页面发现页面滚动事件并没有触发，后面经过仔细查看，确定问题原因是scroll-view没有设置高度，而且必须是精准高度，不能用百分比。2、scroll-view滚动到某一位置我们开发时可能需要用到点击后滚动到某一位置或者初始化时滚动到对应位置，过去通常是通过锚点方式进行触发，同样的scroll-view为我们封装了一个很好用的方法scroll-into-view，对应的值也是一个id值，具体使用方法及注意事项可以参考文档（ scroll-view ）。3、scroll-view中包含fixed定位元素，滚动时fixed定位元素闪动这个问题算是比较坑了，在scroll-view里面，我们设置某个元素或者组件为fixed定位，在滚动页面时，会发现定位的元素会消失一下然后再出现，虽然不是什么严重问题，但是很影响用户体验。这个问题我看到社区里也有很多人在问，但是目前官方还没有给出合理方法。目前简单的应对方法我总结了两点：一是把定位元素放到scroll-view外部，此类方法可以完美避开上述问题，但是某些场景下可能不太适用；二是，在使用scroll-view时我们通常会设置scroll-with-animation=true即开启滚动过度动画效果，当我们把这个值设置为false时，上述问题也能很好的解决，即使定位元素在scroll-view内部也不会有闪现问题。但是此方法牺牲的也是用户体验，如果有短距离的页面滚动可以使用此类方法。欢迎遇到此类问题的小伙伴进行补充，在官方给出完美方案之前，我们也能有自己的应对方案。六、小程序checkbox样式这个就不得不吐槽一下UI了，其他的都还好，但是对于表单相对应的样式，真的是丑爆了！而且，当你想通过css样式覆盖方法修改的时候，会发现，你的修改根本就是不起作用的！！根本原因就是你所看见的wxml结构与内容和样式所定义的根本不是一个样子！！！当然也有机智的小伙伴探究出了方案（以checkbox为例）：//wxml\r\n<label>\r\n    <checkbox>aaa</checkbox>\r\n</label>\r\n\r\n//wxss\r\n//修改checkbox大小\r\ncheckbox .wx-checkbox-input{}\r\n//修改checkbox选中后的样式\r\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked{}\r\n//修改checkbox选中图标样式\r\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked::before{}复制代码当然，如果你不喜欢原组件，不想去修改css，完全可以自己仿写一个checkbox，样式自己写，切换效果通过点击事件（参数e，获取data）自己控制就好。关于表单内容，后面会再总结一个自定义表单及自定义校验方法及自己进行的优化。七、小程序页面跳转，跳转到其他域名页面小程序页面跳转，我们可以通过wx.navigateTo()方法进行，但是当需要跳转到不同域页面时，直接跳转链接的方式就不好用了。小程序也为我们提供了方法，即webb-view( 使用方法见文档)。以上就是在初次开发中遇到的问题及总结的使用方法，后面随着使用的增多，肯定还会有更多的问题出现，随时进行添加吧，算是对小程序使用自己的一个总结，有不足和错误之处，还希望各位大大提出宝贵意见。ps：前期初次接触小程序书写demo时，也遇到了一些小问题，付个传送门：初试微信小程序遇到的问题总结" } { "title": "如何一人五天开发完复杂小程序（前端必看） ", "author": "Rolan", "pub_time": "2019-12-31 00:21", "content": "随着业务需求的不断累加、小程序追求快速产出。在人手不足且开发周期较短的情况下，我们需要找到一个最大化开发效率的方法。而高效率的开发离不开规范化、工程化、组件化。为此整理写下总结，细数小程序中的坑与实践。介绍我们对小程序高效率开发的思考与探索。布局方案导航栏TabBarBasicPage用户系统登录方案初始化登录鉴权优化及 Bug 追踪日志收集数据分析常用优化方案preLoad独立分包加载布局方案我们首先思考的是，在小程序中如何快速且高还原产出页面。为此我们封装了一套页面组件。导航栏目前小程序有如下两种导航栏：常规、自定义导航栏自定义导航栏布局下，我们可以完全控制导航栏样式，赋予导航栏更多交互及 UI 设计上的可能。如上图所示，Readhub 在导航栏中加入了设置按钮，喜茶在个人页中标题渐隐及沉浸式导航栏效果。常规布局下，顶部导航栏部分直接使用小程序提供导航栏。可根据具体业务选择具体布局方案，在我们小程序中，我们选择了全部使用自定义导航栏的方式并对其进行了一定封装。在确定使用自定义导航栏方案后，我们对导航栏进行了拆解拆解后，我们发现可以将自定义导航栏分为两个部分：StatusBar 及 NavigationBar 。通过查阅微信 API ，我们分别通过 wx.getSystemInfoSync 及 wx.getMenuButtonBoundingClientRect 获取到 StatusBarHeight 及 MenuButton 的布局信息。由拆解图可知1 NavigationBarPaddingTop = MenuButtonTop - StatusBarHeight\r\n3 NavigationBarPaddingBottom = NavigationBarPaddingTop\r\n5 NavigationBar = StatusBarHeight + NavigationBarPaddingTop + NavigationBarPaddingBottom + MenuButtonHeight复制代码得到上述数据后，结果简单封装， 我们得到如下方案StatusBar 部分， 我们使用 PaddingTop 填充。可在此基础上可再进一步封装一些通用 NavigationBar 组件。我们封装了一些常用 NavigationBar 组件， 如下所示：沉浸式导航栏自定义 TabBar目前小程序 TabBar 中也存在两种方案。常规 TabBar ：微信提供方案，可修改 icon 、 文字及其对应选中状态。自定义 TabBar ：小程序基础库 2.5.0 开始支持。可通过其实现异形 TabBar 或各种自定义样式。在我们小程序中，我们选择全部使用自定义 TabBar 来实现业务。由于小程序基础库 2.5.0 之后官方才开始支持自定义 TabBar 。我们此处不直接选择使用 custom-tab-bar 方案。选择结合 custom-tab-bar 、 自定义组件及 wx.hideTabBar 的方案实现。具体方案为放置空节点 custom-tab-bar 文件。在页面中按需引入自定义 TabBar 组件。在页面初始化完成后调用 wx.hideTabBar 隐藏原 TabBar 。这样做的好处在于，在基础库 2.5.0 及更高版本时正常显示，在低版本时以最小代价兼容。在 iPhone X 系列下的底部安全区兼容方案如下 1@mixin media-style() { 2  .tab { 3    padding-bottom: 84px; 4  } 5} 6// 适配iPhone X系列下巴 7@media screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) { 8    @include media-style(); 9}1011@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio:3) {12    @include media-style();13}1415@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio:2) {16    @include media-style();17}18// 下面代码只为适配iPhone X在微信调试模拟器中为724px19@media screen and (device-width: 375px) and (device-height: 724px) and (-webkit-device-pixel-ratio: 3) {20    @include media-style();21}复制代码推荐如无特殊需求，建议直接使用微信提供方案，在自定义 TabBar 方案中 安卓手机下拉刷新时， TabBar 会被拉出可视区域。需自定义下拉刷新组件解决方案整合 BasicPage以上方案在线上运行一段时间后稳定后。对自定义导航栏及自定义 TabBar 方案进行了整合。封装了 BasicPage 组件。以我们线上典型页面为例，我们可以将页面分为两大类。基于以上分析结合线上需求，我们对此基础组件进行封装。Taro 框架伪代码，可根据各自使用框架进行封装，思路一致 1class BasicPage extends Taro.Component { 2 3  state = { 4    menuButtonHeight: 32, 5    menuButtonTop: 48, 6    statusBarHeight: 44, 7  }; 8 9  componentDidMount() {10        // ...获取并设置 menuButtonHeight 、 menuButtonTop 、 statusBarHeight11  }1213  render() {14    return (15      <View className='basic-page'>16        {17          this.props.header && <View className={`basic-page-header${this.props.fixed ? ' fixed' : ''}`} style={{18            paddingTop: `${this.state.statusBarHeight}px`,19            height: `${(this.state.menuButtonTop - this.state.statusBarHeight) * 2 + this.state.menuButtonHeight}px`,20          }}21          >22            {this.props.renderHeader}23          </View>24        }25        <View className={`basic-page-body${this.props.tab ? ' tab' : ''}`}>26          {this.props.renderBody}27        </View>28        {this.props.tab && <TabBar active={this.props.tabActive} />}29      </View>30    );31  }32}3334BasicPage.defaultProps = {35  fixed: false, // header 是否浮动36  tab: false,37  header: false,38  tabActive: 'template',39};40复制代码使用中会经常用到 自定义 TabBar 、 自定义 NavigationBar 布局数据。再封装一个工具类获取。 1import Taro from \"@tarojs/taro\"; 2 3function rpx2px(rpx, windowWidth) { 4  return rpx / 750 * windowWidth; 5} 6 7export default class customConfig { 8 9  static fetchAllConfig() {10    const menuButton = Taro.getMenuButtonBoundingClientRect();11    const systemInfo = Taro.getSystemInfoSync();1213    const statusBarHeight = systemInfo.statusBarHeight;14    const headerHeight = (menuButton.top - systemInfo.statusBarHeight) * 2 + menuButton.height;15    const footerHeight = systemInfo.model.indexOf('iPhone X') === -116      ?17      rpx2px(100, systemInfo.windowWidth)18      :19      rpx2px(168, systemInfo.windowWidth);  // 50  8420    const bodyHeight = systemInfo.windowHeight - statusBarHeight - headerHeight - footerHeight;21    const noTabBodyHeight = systemInfo.windowHeight - statusBarHeight - headerHeight;2223    let data = {24      source: {25        menu: menuButton,26        system: systemInfo,27      },28      height: {29        statusBar: statusBarHeight,30        header: headerHeight,31        body: bodyHeight,32        noTabBody: noTabBodyHeight,33        footer: footerHeight,34      },35    };36    Taro.setStorageSync('customConfig', data);37    return data;38  }3940  static get config() {41    let storageInfoSync = Taro.getStorageSync('customConfig');42    if(!storageInfoSync) {43      storageInfoSync = this.fetchAllConfig();44    }45    return storageInfoSync;46  }47}复制代码到此，我们完成对基础页面组件的封装。目前线上运行小程序所有页面都基于该组件进行开发。开发新页面时只需要引用该组件即可。1<BasicPage header tab tabActive='index' 2        renderHeader={ 3          <View 4            className='my-index-header' 5          > 6            <Text>Title</Text> 7          </View> 8        } 9        renderBody={10          <View className='my-index-header'>11            Body12          </View>13        }14/>复制代码用户系统在一个应用中，用户系统是至关重要的。我们通过数个小程序的开发，整理了一套我们目前正在使用的用户系统实践。登录、获取用户信息如上图所示，我们将小程序登录及获取用户信息拆分为两部分。主要有如下考虑：降低用户使用门槛，可先让用户体验部分功能。后续分享或互动时提示授权完善用户信息保证始终持有用户登录态，方便程序处理。如把用户登录及完善用户信息放置一起，在未授权时无法获取自定义登录态。判断变得复杂且无法提前收集 formId同一开发者账号下，多小程序互通时，如有一小程序用户授权过，可通过返回 unionid 直接同步信息，无需再授权，提升用户体验。处理注意点授权获取用户信息时，如果服务端未记录用户 sessionKey ，在 Button type = getUserInfo 回调事件中使用 wx.login 方法获取 code 的话，会导致 sessionKey 变化。从而导致 getUserInfo 时使用 sessionKey 与新 sessionKey 不匹配。从而导致解密用户信息失败。解决方案有如下两种：Button type = getUserInfo 回调事件中使用 wx.login 方法后，再次调用 wx.getUserInfo 方法重新获取加密用户信息。服务端记录 sessionKey ，Button type = getUserInfo 回调后无需调用 wx.login ，直接提交供服务端处理。第一种方案适合简单改造旧项目、快速开发，但强烈建议使用服务端处理方式解决。完善用户信息时，解密用户信息部分请查看官方文档，这里不叙述具体流程https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.htmlunionid 机制另外，在登录流程中服务端向微信换取 sessionKey 过程中，如果满足一定条件，会直接返回 unionid 。同开发者账号下多个小程序时可用 unionid 做用户信息同步，无需再授权。提升用户体验。unionid 机制: https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html小程序初始化及页面初始化处理在日常开发中，我们通常会把登录获取 token 操作放置在小程序初始化中即 app.js 定义的 onLaunch 中。而该生命周期与页面初始化生命周期为同步进行。此时，如果在页面初始化中，需要携带用户登录态请求接口获取信息时，可能出现如下情况因为小程序初始化及页面初始化是同步进行的。若页面初始化时，小程序初始化中登录请求仍未完成。会导致未携带 token 或其他鉴权信息，鉴权失败。最开始我们通过在组件中挂载一个特殊事件 componentDidInit ，待小程序初始化登录请求后获取当前页面实例进行调用。但该方案对代码侵入性太强，最终我们选择维护一个登录请求队列。用上队列的原因在于，在产品需求上经常会有先跳入首页，再从首页跳入二级页的需求，这样能让用户回退一次后，仍然能回到首页。但会导致在不同页面中近乎同时调用 login 方法。在第一种方案中，解决该问题需要获得所有页面实例进行调用。而引入队列后只需要轮询消费队列中函数执行即可。上述流程可解决此问题。伪代码如下：代码仅供理解思路 1let loginDoing = false; 2const loginEvent = []; 3 4const userProfile = observable({ 5  user: { 6    avatar: '', 7    isCompleted: false, 8    nickname: '', 9    uid: 0,10    token: '',11  },12  async loginProcess() {13    if(this.user.token) {14      return this.user;15    }16    loginDoing = true;17    let code;18    try {19      const codeResult = await Taro.login();20      if(codeResult.errMsg !== 'login:ok') {21        throw new Error('Taro.login 失败');22      }23      code = codeResult.code;24    } catch (e) {25      loginDoing = false;26      throw e;27    }28    const result = await post(URL().user.login, {29      code,30    });31    let user = {32      ...result.user,33      token: result.token,34    };35    this.user = user;36    loginDoing = false;37    setTimeout(() => {38      let length = loginEvent.length;39      for(let i = 0; i < length; i++) {40        loginEvent.pop()(user);41      }42    });43    return user;44  },45  login() {46    if(loginDoing) {47      return new Promise((resolve) => {48        loginEvent.push(resolve);49      });50    } else {51      return this.loginProcess()52    }53  },54});复制代码鉴权业务需求中，通常存在某些操作需要 【 用户授权完善信息 】 后才能继续进行，早期项目中都是各自页面中写鉴权代码。因而会涉及大量重复代码，也不利于快速开发。为此我们封装了一套鉴权方案。BasePage通过所有页面基础一个基类 BasePage 。在 BasePage 中写入鉴权逻辑来实现。配合在主页面中使用 AuthorizationModal 组件实现鉴权。代码仅供理解思路1 export default class BasePage extends Component { 2 3    state = { 4        // 鉴权相关 5        showAuthorizationModal: false, 6    }; 7 8    /** 9     * 鉴权相关10     */11    // 授权成功事件12    authSuccessEvent() {13    }1415    // 取消授权事件16    authFailEvent() {17    }1819    async checkAuthorization() {20        // 当前是否有已验证21        let globalData = getGlobalData(STORAGE_KEY.VERIFY);22        if(globalData) {23            return {24                isNew: false,25            };26        } else {27            Taro.showLoading({28                title: '检查授权中...',29                mask: true,30                showTicketModal: false,31            });32            // 如果本地不存在时，先请求接口33            // 未登录过，或新机器34            // 请求token及授权状态35            let res;36            try {37                res = await Taro.login();38            } catch() {39                Toast.fail('登录失败~');40                Taro.hideLoading();41                throw new Error('Taro.login 失败');42            }43            // 请求授权接口44            const result = {};45            if(result.errno === 0) {46                resolve({47                    isNew: false,48                });49            } else {50                // 未授权过51                // 弹窗提示授权52                this.setState({53                    showAuthorizationModal: true,54                });55                this.authSuccessEvent = () => {56                    this.setState({57                        showAuthorizationModal: false,58                    });59                    resolve({60                        isNew: true,61                    });62                };63                this.authFailEvent = () => {64                    this.setState({65                        showAuthorizationModal: false,66                    });67                    reject();68                };69            }70        }71    }72}复制代码页面继承该基类1 class LaunchIndex extends BasePage {}复制代码在页面中置入组件1 {this.state.showAuthorizationModal &&2 <AuthorizationModal onSuccess={this.authSuccessEvent} onFail={this.authFailEvent}/>}3复制代码AuthorizationModal 组件接下来，我们只需要在需要鉴权的操作中如下使用即可1this.checkAuthorization()2  .then((res) => {3   // 授权成功逻辑4       console.log('是否新用户', res.isNew);5   })6   .catch(() => {7    // 授权失败逻辑8    })复制代码该方案好处在于，授权由状态驱动，只需在代码中调用 checkAuthorization 方法即可。AuthorizationView后来，由于第一种方案过于重，对页面代码侵入性较强。为此我们又封装了一套较轻的组件。大部分逻辑中，需要用户主动点击时才进行鉴权，我们基于此思路封装了 AuthorizationView 。对外暴露 onAgree 、 onDeny 方法实现对部分区域的点击鉴权操作。代码仅供理解思路1 class AuthorizationView extends Taro.Component { 2 3  state = { 4    showLoginPanel: false, 5  }; 6 7  /** 8   * 登录 9   */10  click() {11    const { userProfile: { user, }, } = this.props;12    if(user.isCompleted) {13      this.props.onAgree(user);14    } else {15      // 显示登录框16      this.setState({17        showLoginPanel: true,18      });19    }20  }2122  /**23   * 授权登录24   * @param e25   */26  async bindGetUserInfo(e) {27    if(e.detail.errMsg === 'getUserInfo:ok') {28      const { userProfile, } = this.props;29      const userResult = await userProfile.login(true);30      this.setState({31        showLoginPanel: false,32      });33      this.props.onAgree(userResult);34    } else {35      this.props.onDeny();36    }37  }3839  cancel() {40    this.setState({41      showLoginPanel: false,42    });43  }4445  render() {46    return (47      <Block>48        <View onClick={this.click}>{this.props.children}</View>49        {50          this.state.showLoginPanel && <View className='login-panel'>51            <View className='login-panel-main'>52              <View className='login-panel-main-title'>您还未登录</View>53              <View className='login-panel-main-subtitle'>请先登录再进行操作</View>54              <Image className='login-panel-main-image' src='https://p0.ssl.qhimg.com/t01a1e495cc2be1e651.png' />55              <View className='login-panel-main-footer'>56                <View className='login-panel-main-footer-button cancel' onClick={this.cancel.bind(this)}>暂不登录</View>57                <Button className='btn-reset' openType='getUserInfo' onGetUserInfo={this.bindGetUserInfo}>58                  <View className='login-panel-main-footer-button confirm'>立即登录</View>59                </Button>60              </View>61            </View>62          </View>63        }64      </Block>65    );66  }67}6869AuthorizationView.defaultProps = {70  onAgree: () => {71  },72  onDeny: () => {73  },74};7576export default AuthorizationView;77复制代码代码中只需要使用该组件包裹子组件即可使用1 <AuthorizationView onAgree={this.onAgree.bind(this)} onDeny={this.onDeny.bind(this)}>2  <View>生成海报</View>3</AuthorizationView>4复制代码以上两种方案都有在线上业务中使用，具体选型看业务决定优化及Bug追踪在维护阶段，我们会更加关注于用户反馈 bug 时如何复现场景及数据分析。日志收集在小程序基础库版本 2.1.0 后，微信提供了一套日志相关接口：LogManager 。在用户反馈时，通过该接口记录的日志会同步上传至微信后台，可下载查看追踪 Bug。我们通过简单的对其封装，实现一套日志收集机制。1 const _logger = Taro.getLogManager({ level: 0, }); 2 3const Logger = { 4  debug(...args) { 5    _logger.debug(`${dayjs().format('YYYY-MM-DD HH:mm:ss')}" } { "title": "给你的头像加个圣诞帽吧 ", "author": "Rolan", "pub_time": "2019-12-31 00:43", "content": "看着大伙都在弄这个，我自己也来试一哈，我分别用了两种方式来实现，一种是普通的方式，一种是wxs方式\r\n普通方式\r\n效果图如下：\r\n\r\n思路\r\n\r\n获取头像\r\n选择素材\r\n缩放，移动，旋转素材\r\n生成canvas\r\n生成图片，保存图片\r\n\r\n实现方式\r\n\r\n首先是获取头像，这个不用说，大家应该都会的。\r\n选择素材这里我准备了三张圣诞帽的素材，这个网上有很多，可以自己找下，然后我还做了一个选择手机相册的功能，如果你自己有素材的话也可以直接选择这个功能。\r\n缩放，移动，旋转素材都是通过触摸函数去实现的，这里是先将布局做好，然后在标签上面绑定各个触摸事件，通过返回的值在标签的style里设置实现各个效果。\r\n调整好了之后点击保存头像会获取所有参数并将头像画出来，再通过 wx.canvasToTempFilePath() 将canvas生成图片最后通过 wx.saveImageToPhotosAlbum() 保存图片。\r\n主要代码\r\n主要的函数就是下面这几个，代码片段我会放在文末，没有什么比较难的地方，就是要注意下计算的时候不要算错就行。\r\n\r\n需要注意的点\r\n由于素材的大小可能会有不同，所以在重新选择素材的时候高度要重新设置一下，这里我用了一个方法来重置高度，主要是每次重新选择素材的时候就用 wx.getImageInfo() 这个api去获取图片素材的宽高，再计算出宽高比。\r\n\r\nwxs实现方式\r\n实现方式\r\n思路跟普通方式是一样的，不同的是这里将绑定事件通过 wxs 去实现，直接设置标签的参数而不通过逻辑层去处理，在性能上会比较好一点，不过这种实现方式在进行旋转的时候最后生成的图片会有不准，后面会说到。\r\n参数的获取是通过在标签上设置style，然后点击保存的时候用  wx.createSelectorQuery() 获取各个参数的\r\n\r\n获取旋转的值\r\n由于 wx.createSelectorQuery() 并不能获取到 rotate 这个参数，所以我是通过下面这种方式来拿到旋转的值的，将旋转值以宽度的形式赋值给 .vo-ro\r\n\r\n但是我发现旋转之后生成的图片不是正确的，原因是旋转之后通过 wx.createSelectorQuery() 拿到的宽高并不是图片大小的宽高，而是旋转之后的宽高，按理来说不应该是这样的，即使通过样式旋转，它的宽高应该保持不变才对，这样就造成了参数上的错误，所以画出来的图片是不准确的。\r\n因为加了旋转之后画出来的图片会不准确，暂时想不出别的方法，我把旋转的按钮先注释掉了，只支持缩放跟拖拽。\r\n总结\r\n两种方式，wxs性能要更好，但是效果没第一种的好，看你要哪种了，最后祝大家圣诞节快乐，祝你生活愉快\r\ndevelopers.weixin.qq.com/s/Cizd1RmY7…" } { "title": "微信小程序使用自定义组件导航实现当前页面高亮 ", "author": "Rolan", "pub_time": "2020-1-2 00:18", "content": "最近开发小程序，需要做一个导航，导航可以通过template写出来，但是这个项目需要在导航中处理一些逻辑，做成组件更方便些。首先新建header文件夹，里面新建对应的js、json、wxml、wxss文件。<!-- 公共头部组件 -->\r\n<view class='headers'>\r\n     <navigator open-type=\"redirectTo\" class='logo' url=\"../index/index\" hover-class=\"none\">\r\n        <image src=\"../../assets/img/logo2.png\" mode=\"widthFix\"></image>\r\n     </navigator>\r\n    <view class=\"phone_nav_switch\" bindtap=\"controlNav\">\r\n        <view class=\"iconfont icon-daohang\" hidden=\"{{navIsShow}}\"></view>\r\n        <view class=\"iconfont icon-guanbi\" hidden=\"{{!navIsShow}}\"></view>\r\n    </view>\r\n    <view class=\"nav\">\r\n        <view class=\"shadow {{navIsShow ? 'active':''}}\" bindtap=\"controlNav\"></view>\r\n        <view class=\"bg {{navIsShow ? 'active':''}}\">\r\n            <view class='con' wx:for=\"{{navs}}\" wx:key=\"item.url\">\r\n                 <navigator open-type=\"redirect\" data-index=\"{{index}}\" class=\"{{index === navActive ? 'active' : ''}}\" url=\"{{item.url}}\" hover-class=\"none\">\r\n                    {{item.text}}\r\n                 </navigator>\r\n            </view>\r\n        </view>\r\n    </view>\r\n    <!-- 返回顶部 -->\r\n    <view class=\"backTop\" bindtap=\"goTop\" hidden='{{floorstatus}}'>\r\n        <text class=\"icon iconfont icon-iconfonticontrianglecopy\"></text>\r\n    </view>\r\n\r\n</view>header.js里的导航数据/**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    // 当前导航高亮\r\n    navActive: {\r\n      // 类型\r\n      type: Number,\r\n      // 默认值\r\n      value: 0\r\n    }\r\n  },\r\n\r\n  data: { \r\n    // 导航开关 \r\n    navIsShow: false,\r\n    currentIndexNav: 0,\r\n    // floorstatus: false,\r\n    navs: [\r\n      {\r\n        text: '网站首页',\r\n        url: '../index/index'\r\n      },\r\n      {\r\n        text: '招商加盟',\r\n        url: '../join/join'\r\n      },\r\n      {\r\n        text: '关于煮田',\r\n        url: '../about/about'\r\n      },\r\n      {\r\n        text: '煮田美食',\r\n        url: '../food/food'\r\n      },\r\n      {\r\n        text: '最新资讯',\r\n        url: '../news/news'\r\n      },\r\n      {\r\n        text: '门店查询',\r\n        url: '../search/search'\r\n      },\r\n      {\r\n        text: '联系我们',\r\n        url: '../contact/contact'\r\n      },\r\n      {\r\n        text: '视频列表',\r\n        url: '../videoItem/videoItem'\r\n      }\r\n\r\n    ]\r\n  },导航放在class=\"nav\"中，header.json文件中写入{\r\n  \"component\": true\r\n}需要引入组件的页面的json文件写入，比如index.json{\r\n  \"component\": true,\r\n  \"usingComponents\": {\r\n    \"header\":\"../header/header\"\r\n  }\r\n}然后在index.wxml引入组件,navActive是传给组件的值，目的是为了对应导航组件内的导航每一项的index，比如首页的index为0，那我在首页内定义的navActive就是0，<!-- 头部组件 -->\r\n    <view class='header'> \r\n        <!-- 导航高亮传值 -->\r\n         <header navActive='0'></header>\r\n    </view>如果相等当前页面就会高亮需要在在heaer.js设置navActive的类型，通过上面的操作，我是能够实现当前页面导航高亮的，希望能帮到需要的人，如果觉得我上面写的不清楚的话，这是我的githubhttps://github.com/mazixiao/w...,这个是我做好了的" } { "title": "微信小程序canvas生成海报 文字自动换行 canvas高度动态设置 ", "author": "Rolan", "pub_time": "2020-1-2 00:24", "content": "在微信小程序中分享，官网只提供分享给好友和群聊的能力，未提供分享到朋友圈的api。因此小程序分享到朋友圈通常做法就是利用canvas生成一张动态海报，上面贴一个小程序码图片，分享到朋友圈，长按识别小程序码进入小程序，以达到在朋友圈推广小程序的功能。初始化canvas1.在.wxml中 创建一个canvas, canvasWidth 和 canvasWidth 分别为创建的canvas的宽高。比如我们需要保存的海报尺寸为750px * 1350px; 我们就可以设置canvasWidth = 750；canvasWidth = 1350；这样导出来的图片比较清晰。<view class=\"canvas-box\">\r\n    <canvas canvas-id=\"canvas\" class=\"canvas\" style=\"width: {{canvasWidth}}px; height: {{canvasHeight}}px;\"></canvas>\r\n<view>2.在小程序中canvas层级最高。因此我们需要隐藏canvas,在窗口中不可见。.canvas-box{  \r\n  position: fixed;  \r\n  top: 1000px;  \r\n  left: 1000px;  \r\n  z-index: -10;  \r\n}在js中获得canvas上下文const ctx = wx.createCanvasContext('canvas'); // canvas-id绘制图片小程序绘制图片的api比较简单，一般可直接使用下面的方式const img = '/assets/images/bg.png';\r\nconst imgX = 0;      // 绘制图片在canvas中起点X坐标\r\nconst imgY = 0;      // 绘制图片在canvas中起点Y坐标\r\nconst imgWidth = 0;  // 绘制图片在canvas中宽度\r\nconst imgHeight = 0; // 绘制图片在canvas中高度\r\nctx.drawImage(img, imgX, imgY, canvasWidth, canvasHeight);本地图片小程序绘制本地图片可直接使用，例如上面的 /assets/images/bg.png' 可直接绘制到canvas上面。网络图片小程序不能直接绘制网络图片到canvas中。1.需要通过 wx.getImageInfo 获取图片信息或 wx.downloadFile 下载到本地。2.获取图片信息。网络图片需先配置download域名才能生效。如果需要绘制微信用户头像，也需要将腾讯的域名加入到白名单。这里使用wx.getImageInfo，在页面初始化的时候就请求所有需要绘制到canvas的网络图片.const localImgInfo = {}; // 存储所有网络图片请求到本地的对象\r\nconst imgList = [  \r\n  img1,\r\n  avatar,\r\n];  \r\nimgList.forEach((item, index) => {  \r\n  wx.getImageInfo({  \r\n    src: item,  \r\n  success: function (res) {  \r\n      // 保存到本地数组  \r\n  localImgInfo[item] = res.path;  \r\n  }  \r\n  })  \r\n})\r\n\r\n... (确保网络图片加载完毕后)绘制网络图片\r\n\r\nctx.drawImage(localImgInfo[avatar], imgX, imgY, canvasWidth, canvasHeight);绘制文字ctx.setFontSize(30);          // 文本字体大小\r\nctx.setFillStyle(\"#E1E6F0\");  // 颜色\r\nconst text = '我是文字';\r\nconst textX = 0;  \r\nconst textY = 0;\r\n\r\nctx.fillText(text, textStartX, textY);绘制文字和图片有一个小区别需要注意一下，起始的x,y坐标不一致。绘制图片的x,y坐标是从图片的 左上角 开始计算位置的。绘制文字的x,y坐标是从文字的 右下角 开始计算位置的。文字自动换行ctx.measureText() 能够获取canvas中文字的宽度，可通过此方法手动给文字换行// 将文字绘制到行 长文本自动换行 并返回行数  \r\n/\\*  \r\n\\* params  \r\n\\* @text 需要绘制的文本字符  \r\n\\* @startX 第一行文本的起始X坐标  \r\n\\* @startY 第一行文本的起始Y坐标  \r\n\\* @lineHeight 文本行高  \r\n\\* @MAX\\_WIDTH 单行文字最大宽度，超过临界值自动换行  \r\n\\*  \r\n\\* return rowLength 返回绘制文本的行数  \r\n\\* \\*/\r\nfunction drawText(text, startX, startY, lineHeight, MAX\\_WIDTH) {  \r\n  let allAtr \\= text.split('');  \r\n  let rowArr \\= \\[\\]; // 拆分出来的每一行  \r\n  let rowStrArr \\= \\[\\]; // 每一行的文字数组  \r\n  for (let i \\= 0; i < allAtr.length; i++) {  \r\n    const currentStr \\= allAtr\\[i\\];  \r\n  rowStrArr.push(currentStr);  \r\n  const rowStr \\= rowStrArr.join('');  \r\n  if (ctx.measureText(rowStr).width \\> MAX\\_WIDTH) {  \r\n      rowStrArr.pop(); // 删除最后一个  \r\n  rowArr.push(rowStrArr.join('')); // 完成一行  \r\n  rowStrArr \\= \\[currentStr\\];  \r\n  continue;  \r\n  }  \r\n    // 最后一个字母 直接添加到一行  \r\n  if (i \\=== allAtr.length \\- 1) {  \r\n      rowArr.push(rowStr); // 完成一行  \r\n  }  \r\n  }  \r\n  \r\n  for (let i \\= 0; i < rowArr.length; i++) {  \r\n    ctx.fillText(rowArr\\[i\\], startX, startY \\+ i \\* lineHeight);  \r\n  }  \r\n  return rowArr.length;  \r\n}drawText() 函数主要的作用就是绘制传入的文本，使用 ctx.measureText() 判断单行文字的宽度是否超过单行最大宽度，如果超过就将ctx绘制文本的startY坐标设置为当前startY+文本行高，实现切换到下一行的效果canvas高度动态设置由于项目中生成的海报图片高度随内容变化，导致不同的内容生成的海报高度不一致，所以这边只需要将canvas的高度放在data中，然后根据不同的内容动态计算最终海报的高度，然后设置data中canvas的高度即刻。下面是项目中的实际效果，在这里，海报由三个部分组成，头部，内容，底部。其中头部和底部高度固定，中间的内容高度由后台返回的书籍数量决定，其中可能需要换行的就是书籍的名称和副标题。这里简单的将每一本书作为一块区域，高度固定，因此 内容区域的高度 = 书籍数量 * 书籍高度，通过此方法简单计算出中间内容区的高度，然后动态设置canvas的高度。源码https://github.com/zhaosheng808/canvasPoster提供简单的微信小程序测试号demo，包含请求用户保存canvas图片的授权逻辑。测试号需要将不校验合法域名打开，不然无法下微信头像和外部图片。正式号需要在微信公众平台配置下载域名" } { "title": "微信小程序长按保存图片 ", "author": "Rolan", "pub_time": "2020-1-2 00:43", "content": "微信浏览器打开h5页面如果是img标签的话，长按会弹出保存图片的选项。但是微信小程序里面不可以，需要自己写这个功能。这个功能有两个点，一个是长按，一个是保存图片到本地。1. 微信小程序关于图片长按的解释，有两种：因此我们选用 bindlongpress 事件2. 微信小程序同样提供了保存图片的接口，是wx.saveImageToPhotosAlbum()3. 值得说的是，保存的接口，两个需要注意的地方：1、需要先授权，调用 wx.getSetting()方法2、保存的图片路径参数，不支持网络路径，而在我们渲染页面时，用到的图片有很大可能是网络路径，这时候我们需要先把网络路径转为可用的本地路径，wx.getImageInfo()方法可以满足需要4. 最后再走个心吧，毕竟我这么可爱1、长按后直接保存未免潦草了些，考虑到用户体验，加入 wx.showActionSheet()2、如果用户拒绝授权 或者 以前拒绝过授权，这时候也应该给他提示，或者展示再次打开授权的入口将将！然后就可以开始写代码了：<image src=\"{{url}}\" data-url=\"{{url}}\" bindlongpress=\"saveImage\"></image>// 长按保存功能--授权部分\r\nsaveImage (e) {\r\n    let _this = this\r\n    wx.showActionSheet({\r\n        itemList: ['保存到相册'],\r\n        success(res) {\r\n            let url = e.currentTarget.dataset.url;\r\n            wx.getSetting({\r\n                success: (res) => {\r\n                    if (!res.authSetting['scope.writePhotosAlbum']) {\r\n                        wx.authorize({\r\n                            scope: 'scope.writePhotosAlbum',\r\n                            success: () => {\r\n                                // 同意授权\r\n                                _this.saveImgInner(url);\r\n                            },\r\n                            fail: (res) => {\r\n                                console.log(res);\r\n                                wx.showModal({\r\n                                    title: '保存失败',\r\n                                    content: '请开启访问手机相册权限',\r\n                                    success(res) {\r\n                                        wx.openSetting()\r\n                                    }\r\n                                })\r\n                            }\r\n                        })\r\n                    } else {\r\n                        // 已经授权了\r\n                        _this.saveImgInner(url);\r\n                    }\r\n                },\r\n                fail: (res) => {\r\n                    console.log(res);\r\n                }\r\n            })   \r\n        },\r\n        fail(res) {\r\n            console.log(res.errMsg)\r\n        }\r\n    })\r\n},\r\n// 长按保存功能--保存部分\r\nsaveImgInner (url) {\r\n    wx.getImageInfo({\r\n        src: url,\r\n        success: (res) => {\r\n            let path = res.path;\r\n            wx.saveImageToPhotosAlbum({\r\n                filePath: path,\r\n                success: (res) => {\r\n                    console.log(res);\r\n                    wx.showToast({\r\n                        title: '已保存到相册',\r\n                    })\r\n                },\r\n                fail: (res) => {\r\n                    console.log(res);\r\n                }\r\n            })\r\n        },\r\n        fail: (res) => {\r\n            console.log(res);\r\n        }\r\n    })\r\n},文章写的比较正序，参考的是这篇倒序文章，喜欢倒序的筒子们可以去看下这篇： https://www.jianshu.com/p/e59...（虽然很痛恨没有视频效果的文章，可是录好了视频的我 实在找不到上传视频的按钮！我好难！！！）" } { "title": "小程序wifi能力解读与实践 ", "author": "Rolan", "pub_time": "2020-1-3 00:28", "content": "背景\r\n小程序wifi系列接口为系统原生能力。早在2015年，微信就推出了「微信连Wi-Fi」，微信连Wi-Fi是为商家的线下场所提供一套完整和便捷的微信连Wi-Fi的方案。现在已经是一套完整的，便捷的解决方案。顾客通过扫码的方式连接wifi，同时微信还可以向用户下发消息。方案在官方文档已经阐述得很详细，本文就不再赘述。本文重点在于讲解小程序中使用wifi能力遇到的问题和心得。\r\n【微信连wifi】传送门\r\nwifi能力解读\r\nwifi能力简介\r\n在小程序中，使用wifi模块都需要先调用wx.startWifi()来初始化wifi模块。以下能力的使用均需要在wx.startWifi的success回调中使用。\r\n连接wifi\r\nwx.connectWifi({\r\n    SSID: 'mx 的iphone', // Wi-Fi 设备 SSID\r\n    BSSID: '', // Wi-Fi 设备 BSSID\r\n    password: 'xxxxxxxx',\r\n    success(){},\r\n    fail(){},\r\n    complete(){}\r\n})\r\n复制代码connectWifi为我们提供了直连wifi的能力， 仅 Android 与 iOS 11 以上版本支持，需要基础库1.6.0以上。这个一般是我们使用wifi功能的核心API了。在ios中，会出现系统弹框，询问用户是否要连接wifi，只有用户点击确定，connectWifi才会继续进行，否则就走fail回调了。在安卓（以小米note3为例，Anroid9）中则会出现微信连一连的toast。\r\n获取当前已经连接的wifi\r\nwx.getConnectedWifi({\r\n    success(WifiInfo){\r\n        // WifiInfo\r\n    }\r\n})\r\n复制代码从社区中获取的信息得知：signalStrength表示信号强度，iOS 是系统返回的，取值 0-1，安卓经过转换，取值 0-100。数值与信号强度为正比例关系。\r\n获取wifi列表\r\nwx.getWifiList({\r\n    success(e) {\r\n        wx.onGetWifiList((res) {\r\n            // res.wifiList:wifiInfo[]\r\n        })\r\n    }\r\n})\r\n复制代码获取周围的wifi列表，需要先使用getWifiList后使用onGetWifiList进行监听。在ios中，getWifiList会跳到ios系统界面，这是由于ios系统的限制， 目前是无法避免的（其实这么做也无可厚非，wifi信息本来就是敏感的，但是对用户体验有一定的影响）。在安卓中，getWifiList需要获取用户的位置信息，因为可以利用小程序嗅探周边Wi-Fi热点来推断用户所在的位置信息。为了确保用户的隐私不受侵犯，自微信android客户端 7.0.4 起，需要先获取用户地理位置（scope.userLocation）。详情请见wx.getWifiList接口需获取用户位置信息授权后使用\r\n设置AP相关信息\r\nwx.onGetWifiList(function(res) {\r\n    wx.setWifiList({\r\n      wifiList: [{\r\n        SSID: res.wifiList[0].SSID,\r\n        BSSID: res.wifiList[0].BSSID,\r\n        password: '123456'\r\n      }]\r\n    })\r\n})\r\n复制代码\r\n这个接口也挺牛逼，ios特有的。通过设置wifiList，我们在系统页可以直接看到已设置的wifi列表，点了就直接连上了。\r\n其他\r\n\r\nwx.stopWifi 关闭wifi模块\r\nwx.onWifiConnected(function callback)监听连接上 Wi-Fi 的事件\r\nwx.offWifiConnected 取消监听连接上 Wi-Fi 的事件\r\nwx.offGetWifiList(function callback) 取消监听获取到 Wi-Fi 列表数据事件。\r\n\r\n安卓连接wifi\r\n连接指定 Wi-Fi 接口调用时序：\r\nAndroid：startWifi —> connectWifi —> onWifiConnected\r\n复制代码连周边 Wi-Fi 接口调用时序：\r\nAndroid：startWifi —> getWifiList —> onGetWifiList —> connectWifi —> onWifiConnected\r\n复制代码IOS连接wifi\r\n连接指定 Wi-Fi 接口调用时序：(与安卓一致)\r\niOS（仅iOS 11及以上版本支持）：startWifi —> connectWifi —> onWifiConnected\r\n复制代码连周边 Wi-Fi 接口调用时序：\r\niOS（iOS 11.0及11.1版本因系统原因暂不支持）：\r\nstartWifi —> getWifiList —> onGetWifiList —> setWifiList —> onWifiConnected\r\n复制代码实践\r\n笔者在项目中接触到了使用小程序提供的硬件（wifi）能力的场景。利用wifi与socket的能力，我们可以为物联网设备连接wifi。流程如下:\r\n\r\n刚好在开发者社区找到类似的代码片段：\r\n\r\n小程序跟设备数据传输(websocket);\r\n小程序跟设备数据传输(udpsocket);\r\n\r\n\r\nwx.request/wx.connectSocket/wx.uploadFile/wx.downloadFile 的 url 参数允许为 {PORT}/${PATH} 的格式，当且仅当 IP 与手机 IP 处在同一网段且不与本机 IP 相同（一般来说，就是同一局域网，如连接在同一个 wifi 下）时，请求/连接才会成功。\r\n在这种情况下，不会进行安全域的校验，不要求必须使用 https/wss，也可以使用 http/ws。\r\n\r\n局域网通信中，不会进行安全域校验，因此，无需在mp后台添加安全域域名。\r\n总结\r\n借助小程序提供的硬件能力(wifi,蓝牙，NFC)，小程序有了更加广阔的场景。比如【摩拜单车】小程序，有的车需要用户开一下蓝牙，小程序提供的操作原生系统的蓝牙功能便为我们赋能。通过小程序，我们也可以实现与物联网设备通信，通过连接设备热点，利用http/wss/udp传输数据。当然，现在wifi能力还是存在着问题，比如兼容问题，可能有部分安卓手机在连接时会莫名其妙的报错。此时需要对着官方提供的errcode查看具体的原因。\r\n踩过的坑\r\n\r\n安卓部分机型，已经连接wifi，使用connectWifi重新连接，即使传错密码，还是能连上。\r\nA：这个问题目前还没有解决的办法。\r\nios在getWifiList会跳到系统设置页，在connectWifi会出现modal确认是否连接。\r\nA：无法避免。ios系统的限制\r\n调试wifi功能时，无法在开发者工具中调试wifi能力。\r\nA: 目前开发者工具无法进行模拟。并且真机调试时，连接设备热点后会报错。（毕竟真机调试时需要能够访问网络，一般设备热点都不具备访问网络的能力）。目前可以通过 预览+ vconsole解决，还是比较麻烦。\r\n可以主动断开wifi吗？\r\nA: 从文档上看，没有提供这个能力。但是可以尝试连接一个不存在的wifi。\r\n来自文档的注意事项：\r\n\r\n\r\nReference\r\n\r\n微信开放文档 - wifi\r\n微信开放文档 - 局域网通信\r\n小程序WIFI接口和WebSocket创建局域网数据通讯" } { "title": "探索小程序实现 ", "author": "Rolan", "pub_time": "2020-1-6 00:15", "content": "随着小程序的发展与功能的逐步完善，越来越多的产品需要小程序与 APP 的功能能有一些共性，社区跨平台的解决方案越来越多，比如 taro 等为代表的把一套代码编译成多端运行的机制，本文会使用 Swift 作为原生语言，在 iOS 应用上运行一个小程序 Demo， 使用 Android && React Native 也可以采用同样的思路实现。相关代码仓库： https://github.com/taixw2/rmini编译层编译的目的是为了抹平小程序的与 H5 的差异，利用 Vue 实现数据绑定，利用 Web Component 实现小程序的组件功能。从官网文档中可以看出来，运行一个小程序需要框架（数据绑定渲染）、组件（小程序渲染单元）、api（与原始交互的能力）。框架实现转换成单页应用（一种可行的方案）把所有页面打包成一个 js， 再由 js 管理所有的路由和状态，这种方案适合在 web 端运行，并且是单引擎的方案，在模拟原生的右滑返回等效果也会不尽人意。转换成多页面众所周知，小程序是一个双引擎的框架，上面的方案显然不能达到要求, 双引擎的特点是在运行 javascript 的黑盒子中，无法访问到 DOM && BOM 等。将所有的逻辑代码在原生的 JavascriptCore 中运行，WebView 中的 Javascript 引擎负责数据绑定，需要解决的难点是 JavascriptCore 中的 setData 怎么通知 WebView 渲染， WebView 的事件怎么执行 JavascriptCore，接着往下看。抹平WXMLwxml 是一种类 html 标记语言，他负责所有的渲染规则，包括条件渲染、列表渲染、数据绑定等，与其再实现一种框架，还不如直接利用 Vue 实现同样的功能，再利用各种转换库将 wxml 中的事件转换成 Vue 能够识别的事件，如利用 post-html 可以做到如下的转换:每一个事件绑定的方法全都在原生的 JSContext 中运行，所以此时的事件只需要传递给 JSContext 的作用。抹平WXSSwxss 作为小程序的样式语言，其余 css 的主要区别就是多了一个 rpx 单位，以下是官网的换算表：根据上表可得知， rpx = (750 / 屏幕宽度) * px ;在传统的移动端页面，我们的高清方案，一般需要获取 dpr， 然后修改动态修改 viewport 和 html 上的 font-size，但是小程序的代码因为是放在了设备本地，所以可以在下载小程序页面之后，我们还有一次编译机会，这时就可以把 rpx 根据当前设备的屏幕宽度替换成对应的 px。还有一个 @import ，则利用 scss 或 less 就可以合并到同一个 css 文件中,而全局样式则可以在构建 WXML 的时候再植入进入抹平组件组件具有独特的功能和自己的渲染规则，比如 scroll-view 具有 scroll-x 和 scroll-y 等属性控制滚动条。在 HTML5 中有一个重大的功能 web-component ，它能够自定义 html 元素，并且能够监控属性的变化，非常适合实现小程序组件。如：（使用了 lit-element 框架）这里用了 lit-element 这个框架，能够简化一些操作。抹平 Page 和 AppApp 负责整个应用的生命周期以及存一些全局的数据， getApp 能获取到 app 的信息。 所以类似的结构可能是这样的：getApp 能够直接访问到内部对象，并且在最顶层声明，这样每一个的地方都能访问到 getApp。初始化一个页面都需要是实例化 PageClass, 即使再次进入（不是返回到这个页面）这个页面页需要再次重新实例化，每次实例化都需要关联一个 webviewId, 这个 ID 与原始的 webview 关联，这样每个 PageClass 中的 setData 都能找到对应的 webview 进行再次渲染，所以对应的代码可能是这样的：抹平 API通过 API 能够直接调用原生的功能，比如 wx.request ， 如果直接在 webview 中的 JSContext 中运行的话，则可能存在跨域，但是放在原生就不会存在这个问题。实现JSContext 调用原生代码的功能，需要给 JSContext 中植入一个 JSBridge，如： JSBridge.invoke 和 JSBridge.on , invoke 负责同步任务，on 负责异步任务，原生再利用反射（原生的反射真麻烦）调用对应的原生方法，原生可以利用 while(true) 挂起 JSContext，既可以达到同步和异步的方法。打包 JavascriptJavascript 代码打包后被放在 JavascriptCore 中运行，唯一与 Webview 中的 JSContext 打交道的只有 setData , 先看一下打包流程：利用 App.json 构建入口文件利用 rollup 等工具将所有 Javascript 打包成一个文件（目前没有分包）打包流程及其简单，接下来看一下两个 Javascript 引擎的交互过程。打通 JSContext 到 WebView JavascriptCore每次进入一个页面的时候都需要为这个页面的 webview 分配一个 id, 这个 id 至关重要，作为 native 与 JSContext (原生运行 javascript 的上下文对象) 与 webview 交互的唯一标识，JSContext 中需要实例化一个新的 PageClass 关联这个 id， native 中通过 id 保留 webview 的引用。在 JSContext 中植入一个 JSBridge 用于与原生交互，如： JSBridge.setData(webviewId, appId, data), 当 JSBridge 的 setData 被调用后，通过 appId + webviewId 就能找到对应的 webview, 再将 setData 传入 webview 中，在 Vue 接收到 data 后进行渲染， 整个过程如图：打通 Webview JavascriptCore 到 JSContext有了前面的铺垫，接下来再看 webview 如何调用 JSContext 的方法， Webview 唯一能与 JSContext 交互的方式只有事件，事件触发后，需要通过某种方式触发 JSContext 中的方法，最后调用 setData 再返回来重新渲染 webview。webview 中绑定的方法名众多，如： bindtap=\"a\", bindtap=\"b\", bindtap=\"c\" 等，但是可以通过 “抹平 WXML” 的时候最终只保留一个出口，如:v-on:click=\"callClick('a', $event)\" 等，这样 vue 中的 method 只需要实现对应的几个事件便可：结尾利用原生作为桥梁，在两个引擎之间通信，webview 中的 JSContext 负责接收渲染通知，以及发送事件到 Native 的 JSContext 中，JSContext 独立运行，所以既访问不到 window 对象，也访问不到 document 对象。" } { "title": "微信小程序 接入 腾讯云验证码 ", "author": "Rolan", "pub_time": "2020-1-7 00:06", "content": "前言：最近做了一个小程序抽奖的活动，出现了部分用户恶意薅羊毛的现象，因此考虑接入腾讯云的验证码。其实腾讯的官方文档写的相当清晰： https://cloud.tencent.com/doc...不想啃文档的筒子们的就往下继续看吧~（虽然大同小异）整体效果1、小程序触发验证，跳转到验证码小程序2、在验证码小程序内通过验证，并携带参数跳回原来的小程序3、在原来的小程序内，监测携带回的参数，并作后续操作前提条件验证码接入前，需要先在 验证码控制台 中注册 AppID 和 AppSecret，注册完成后，您可以在控制台的 基础配置 中查看 AppID (下文extraData中使用) 以及 AppSecret。注意，这里的 appId 和 appSecret 和小程序后台的是不一致的！接入步骤1、在你需要的地方，唤起验证码小程序首先在 app.json 配置 navigateToMiniProgramAppIdList，如下：{\r\n  \"navigateToMiniProgramAppIdList\": [\"wx5a3a7366fd07e119\"]\r\n}这个appId是官方文档中直接提供的，搬上去就好。假设你的唤起方式是通过一个这样的按钮事件：<button bindtap=\"toTCaptcha\">验证</button>toTCaptcha: function () {\r\n    wx.navigateToMiniProgram({\r\n      appId: 'wx5a3a7366fd07e119',\r\n      path: '/pages/captcha/index',\r\n      extraData: {\r\n        appId: 'appId' //您申请的验证码的 appId\r\n      }\r\n    })\r\n  }2、在 app.js 获取验证结果由于小程序间相互跳转过程中产生的数据仅能在 app.js 中获取到，故需要在 app.js 的 onShow 中添加以下代码，来捕获验证结果 captchaResultApp({\r\n  // ...\r\n  onShow: function(options) {\r\n    // 解决各类回调的兼容问题\r\n    if (!this.captchaTicketExpire) this.captchaTicketExpire = {};\r\n\r\n    if (options.scene === 1038 && options.referrerInfo.appId === 'wx5a3a7366fd07e119') {\r\n      const result = options.referrerInfo.extraData;\r\n      if (result.ret === 0) {\r\n        const ticket = result.ticket;\r\n        if (!this.captchaTicketExpire[ticket]) {\r\n          this.captchaResult = result;\r\n          this.captchaTicketExpire[ticket] = true;\r\n        }\r\n      } else {\r\n        // 用户关闭了验证码\r\n        // 这里可以加上一些验证失败提示\r\n      }\r\n    }\r\n  },\r\n  // ...\r\n});验证结果（captchaResult） 参数说明：3、将验证结果返回至服务端校验在小程序页面的 onShow 阶段，将验证结果及待提交的表单数据一起提交到服务器，进行校验。// page.js\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    // ...\r\n  },\r\n  onShow() {\r\n    const captchaResult = app.captchaResult;\r\n    app.captchaResult = null; // 验证码的票据为一次性票据，取完需要置空\r\n    if (captchaResult && captchaResult.ret === 0) {\r\n      // 将验证码的结果返回至服务端校验，以及后续的操作\r\n      // const ticket = captchaResult.ticket;\r\n      // const randstr = captchaResult.randstr;\r\n    }\r\n  },\r\n  // ...\r\n});用一个词描述这个开发过程：搬上去！" } { "title": "微信小程序极致的scroll-view的下拉刷新扩展组件 ", "author": "Rolan", "pub_time": "2019-12-13 00:11", "content": "其实原理很简单，和普通H5以及市面上有的下拉刷新没有特别大的区别，都是基于 touch 手势检测事件来实现下拉刷新的。 touchstart 的时候记录当前触摸点， touchmove 的时候开始计算移动方向和移动距离, touchend 的时候计算是否要进行下拉刷新操作。如图所示：实现方法调研了一些实现方法，目前大部分都是通过js计算，然后setData来改变元素的 transform 值实现下拉刷新。考虑到性能问题，此处使用了 wxs 的响应式能力来实现整个计算逻辑，不用通过逻辑层和视图层通信，直接在视图层进行渲染。具体文档请参考 wxs响应事件 。这里在 list 组件(由 scroll-view 组成)下抽出了一个 scroll.wxs 作为响应事件的事件处理函数集合，源码基本上就在 scroll.wxs 和 list 组件。scroll.wxs 定义了如下变量和函数：var moveStartPosition = 0     //开始位置\r\nvar moveDistance = 0          //移动距离\r\n\r\nvar moveRefreshDistance = 60  //达到刷新的阈值\r\nvar moveMaxDistance = 100     //最大可滑动距离\r\nvar isRefreshMaxDown = false  //是否达到了最大距离， 用来判断是否要震动提示\r\n\r\nvar loading = false           //是否正在loading\r\n\r\n... ...\r\n\r\nmodule.exports = {\r\n  touchStart: touchStart, //手指开始触摸事件\r\n  touchMove: touchMove, //手指移动事件\r\n  touchEnd: touchEnd, //手指离开屏幕事件\r\n  loadingTypeChange: loadingTypeChange, //请求状态变化监听，监听刷新请求开始和请求完成\r\n  triggerRefresh: triggerRefresh //主动触发刷新操作，比如点击页面上一个按钮，重新刷新list，这就需要用到这个方法\r\n}\r\n复制代码touchStart 和 touchMove 就不用说了，代码注释都很明白，普通的监听移动和处理逻辑。touchEnd 主要是判断移动距离是否达到了阈值，然后根据结果，调用监听实例的 callMethod 方法触发 refreshStart 或者 refreshCancel 方法，这两个方法都是写到 list 组件里面的，用来触发刷新方法或者取消刷新。loadingTypeChange 方法主要是监听刷新是否完成，以此来触发动画效果。triggerRefresh 通过监听主动触发的变量来处理。如果需要主动触发刷新，则调用 list 组件内部的 forceRefresh 方法，具体使用示例在 index/index/js 的 onLoad 函数有: this.selectComponent('.list').forceRefresh()scroll.wxs 里面还有一个未导出的方法，叫 drawTransitionY ，这个方法主要是因为 ios12对于 transition 动画效果支持的不好，所以自己写了个Y轴方向的动画（ linear 线性的），大佬们可以自己往上添加各种 ease-in-out 效果。里面具体的实现可以查看代码注释哦~使用好了，前面讲了实现的原理和方法，那么在代码里面，应该怎么直接使用呢？如下代码所示：<!-- 使用示例 -->\r\n<list class=\"list\" refresh-loading=\"{{refreshLoading}}\" loading=\"{{loading}}\" bindrefresh=\"initList\" bindloadmore=\"loadmore\">\r\n  <!-- your code -->\r\n</list>\r\n复制代码refresh-loading 属性用来通过外部loading态来控制刷新动画的开始结束，因为每当变化 refresh-loading 的值时，会将变化同步到组件内的 showRefresh 属性， wxs 通过监听 showRefresh 来处理动画逻辑。loading 属性是上拉加载更多的时候触发的loading态展示，跟刷新无关bindrefresh 是刷新触发时绑定的函数，下拉刷新动画成功开始后触发这个函数bindloadmore 透传 scroll-view 的加载更多方法当然，源码里面也包含了一个 list-item 组件，这个跟本文没太大关系，是用来做瀑布流长列表内容太多时的内存不足问题解决方案的，具体请看 解决小程序渲染复杂长列表，内存不足问题" } { "title": "小程序Canvas性能优化实战 ", "author": "Rolan", "pub_time": "2019-12-17 00:18", "content": "案例背景需求：在小程序中使用canvas组件绘制地铁图，地铁图包括地铁线路、站点图标、线及站点名称文字，绘制元素为线、圆、图片、文字。支持拖动平移和双指缩放。问题：小程序中的canvas性能有限，特别在交互的过程中不断触发重绘会引发严重卡顿。基本实现在不考虑优化的情况下，先说说如何实现绘制和交互。数据格式首先看看数据，服务返回的数据中每个元素都是独立的，包括该元素的样式及坐标1234567891011121314// 线路数据lineData = { path: [x0, y0, x1, y1, ...], strokeColor, strokeWidth }// 站点数据：分为普通站点和换乘站点// 普通站点绘制简单圆形stationData = { x, y, r, fillColor, strokeColor, strokeWidth }// 换乘站点绘制换乘图标（png图片）stationData_transfer = { x, y, width, height }// 线路名称lineNameData = { text, x, y, fillColor }// 站点名称stationNameData = { text, x, y }绘图API绘制的时候遍历绘制元素数组，根据元素类型设置上下文样式，绘制及填充。接口参考：https://developers.weixin.qq.com/miniprogram/dev/api/CanvasContext.html。设置样式：setStrokeStyle, setFillStyle, setLineWidth, setFontSize绘制路线：moveTo, lineTo, stroke绘制站点：moveTo, arc, stroke, fill绘制图片：drawImage绘制文字：fillText交互实现实现交互主要步骤如下：通过bindtouchstart、bindtouchmove、bindtouchend实现对用户拖动和双指缩放的监听，得到拖动位移向量、缩放比例，触发重绘绘制时通过scale和translate在不用对数据坐标进行处理的情况下实现缩放和平移最终得到的结果如下，平均渲染时长为42.82ms，真机（ios）验证：龟速移动，画面延迟非常大。优化方法完全不了解canvas优化方案的同学可以先看看： canvas的优化。避免不必要的画布状态改变参考Canvas 最佳实践（性能篇） ，绘图上下文是一个状态机，状态的改变是有一定开销的。画布状态改变这里主要指strokeStyle、fillStyle等样式的改变。如何减少这部分的开销呢？我们可以尽量让样式相同的元素放在一起进行一次性的绘制。观察一下数据可以发现，很多站点元素样式都是相同的，那么在绘制之前可以先做一次数据的聚合，将样式相同的数据组合成一条数据：12345678910111213141516function mergeStationData(mapStation) {  let mergedData = {}  mapStation.forEach(station => {    let coord = `${station.x},${station.y},${station.r}`    let stationStyle = `${station.fillColor}|${station.strokeColor}|${station.strokeWidth}`    if (mergedData[stationStyle]) {      mergedData[stationStyle].push(coord)    } else {      mergedData[stationStyle] = [coord]    }  })  return mergedData}聚合后，329条站点数据合并为24条，有效的减少了90%的冗余状态改变开销。修改之后测试一下，平均渲染时长降到了20.48ms，真机验证：移动稍快了一些，但画面仍有较高延迟。合并数据的时候需要注意，此应用场景下各站点是没有互相压盖的，而如果有压盖顺序的话，在合并时只能合并相邻且样式相同的数据。减少绘制物筛除视野外的绘制物： 当用户在放大图像时，其实大部分绘制物都消失在了视野范围之外，避免绘制视野外的元素可以节省不必要的开销。点元素是比较容易判断是否在视野范围之外的，而站点、站点名、线路名都可以作为点元素处理；线路也可以计算出在视野范围内的部分线段，较为复杂，这里先不做处理。筛除掉视野外的绘制物之后测试一下，平均渲染时长17.02ms，真机验证：同上，没有太多变化。筛除过小的绘制物： 当用户在缩小图像时，文字和站点会由于尺寸太小而看不大清，在不影响用户体验的前提下可以考虑直接去掉。根据测试，最终决定在显示比例小于30%时去除文字和站点，这个级别下的渲染时长从22.12ms，减少到了9.68ms。降低重绘频率虽然平均渲染时长已经低了很多，但是在交互时却仍有较高的延迟，这是因为每次ontouchmove都会将渲染任务加入到异步队列中，事件触发频率远高于每秒能够执行的渲染次数，导致渲染任务严重积压，不断滞后。在PC端一般使用requestAnimationFrame解决这个问题，小程序里没有，但是可以自己实现，参考微信小程序中使用requestAnimationFrame：1234567891011121314151617const requestAnimationFrame = function (callback, lastTime) {  var lastTime;  if (typeof lastTime === 'undefined') {    lastTime = 0  }  var currTime = new Date().getTime();  var timeToCall = Math.max(0, 30 - (currTime - lastTime));  lastTime = currTime + timeToCall;  var id = setTimeout(function () {    callback(lastTime);  }, timeToCall);  return id;};const cancelAnimationFrame = function (id) {  clearTimeout(id);};PC端我们一般将渲染间隔控制在16ms左右，但是在小程序中考虑到性能限制，且移动端各机型性能不一，所以这里留了一些空间，控制在30ms，对应到30FPS左右。但如果一直循环调用也会造成静止状态下不必要的开销，所以可以在交互开始ontouchstart和结束ontouchend时分别开启、停止动画：12345678910animate(lastTime) {  this.animateId = requestAnimationFrame((t) => {    this.render()    this.animate(t)  }, lastTime)},stop() {  cancelAnimationFrame(this.animateId)},修改之后真机验证一下：画面比较流程，有轻微卡顿，但不会延迟。其他注意由于本例中缩放和平移状态是以绝对状态保存的，所以scale和translate要搭配save和restore一起使用；但也可以使用setTransform直接重置矩阵。从理论上看这样应该能节省开销，但实际测试并没什么效果，平均渲染时长在18.12ms。这个问题有待研究。小程序中避免使用setData保存与界面渲染无关的数据，以避免引起页面重绘。优化结果经过以上优化，渲染时长从42降到了17ms左右，真机验证下安卓机型普遍非常流畅，体验很好；ios机型有轻微卡顿，且随着使用时长卡顿逐渐明显，后期可以深入研究下是否有内存管理的问题。" } { "title": "小程序跨页面数据传递与事件响应 ", "author": "Rolan", "pub_time": "2019-12-17 00:27", "content": "在实际工作中有很多场景需要在第二个页面中将用户操作之后的将数据回传到上一页面。接下来将我的方案分享给小伙伴。\r\n\r\n本次示例采用 uni-app 框架和 weui 样式库\r\n\r\n实现思路\r\n\r\n创建一个 Emitter，用于事件处理\r\n创建一个全局的 Storage\r\n在第一个页面创建一个 emitter 对象，并添加事件监听，将 emitter 存储到 Storage 中\r\n在第二个页面从 Storage 中取出 emitter 对象， 并触发事件，将数据传递到第一个页面中做处理\r\n\r\n创建 Emitter\r\nfunction isFunc(fn) {\r\n  return typeof fn === 'function';\r\n}\r\n\r\nexport default class Emitter {\r\n  constructor() {\r\n    this._store = {};\r\n  }\r\n\r\n  /**\r\n   * 事件监听\r\n   * @param {String} event 事件名\r\n   * @param {Function} listener 事件回调函数\r\n   */\r\n  on(event, listener) {\r\n    const listeners = this._store[event] || (this._store[event] = []);\r\n\r\n    listeners.push(listener);\r\n  }\r\n\r\n  /**\r\n   * 取消事件监听\r\n   * @param {String} event 事件名\r\n   * @param {Function} listener 事件回调函数\r\n   */\r\n  off(event, listener) {\r\n    const listeners = this._store[event] || (this._store[event] = []);\r\n\r\n    listeners.splice(listeners.findIndex(item => item === listener), 1);\r\n  }\r\n\r\n  /**\r\n   * 事件监听 仅监听一次\r\n   * @param {String} event 事件名\r\n   * @param {Function} listener 事件回调函数\r\n   */\r\n  once(event, listener) {\r\n    const proxyListener = (data) => {\r\n      isFunc(listener) && listener.call(null, data);\r\n\r\n      this.off(event, proxyListener);\r\n    }\r\n\r\n    this.on(event, proxyListener);\r\n  }\r\n\r\n  /**\r\n   * 触发事件\r\n   * @param {String} 事件名\r\n   * @param {Object} 传给事件回调函数的参数\r\n   */\r\n  emit(event, data) {\r\n    const listeners = this._store[event] || (this._store[event] = []);\r\n\r\n    for (const listener of listeners) {\r\n      isFunc(listener) && listener.call(null, data);\r\n    }\r\n  }\r\n}\r\n\r\n复制代码创建 Storage\r\nexport class Storage {\r\n  constructor() {\r\n    this._store = {};\r\n  }\r\n\r\n  add(key, val) {\r\n    this._store[key] = val;\r\n  }\r\n  \r\n  get(key) {\r\n    return this._store[key];\r\n  }\r\n  \r\n  remove(key) {\r\n    delete this._store[key];\r\n  }\r\n  \r\n  clear() {\r\n    this._store = {};\r\n  }\r\n}\r\n\r\nexport default new Storage();\r\n\r\n复制代码第一个页面中的处理\r\n<template>\r\n  <div class=\"page\">\r\n    <div class=\"weui-cells__title\">选择城市</div>\r\n    <div class=\"weui-cells weui-cells_after-title\">\r\n      <navigator :url=\"`../select/select?id=${cityId}`\" class=\"weui-cell weui-cell_access\" hover-class=\"weui-cell_active\">\r\n        <div class=\"weui-cell__hd weui-label\">所在城市</div>\r\n        <div class=\"weui-cell__bd\" :style=\"{color: cityName || '#999'}\">{{ cityName || '请选择' }}</div>\r\n        <div class=\"weui-cell__ft weui-cell__ft_in-access\"></div>\r\n      </navigator>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport Emitter from '../../utils/emitter';\r\nimport storage from '../../utils/storage';\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      cityId: '',\r\n      cityName: '',\r\n    }\r\n  },\r\n  onLoad() {\r\n    const emitter = new Emitter();\r\n\r\n    // 将emitter存到storage中\r\n    storage.add('indexEmitter', emitter);\r\n\r\n    // 添加事件监听\r\n    emitter.on('onSelect', this.handleSelect);\r\n  },\r\n  methods: {\r\n    // 事件处理\r\n    handleSelect(data) {\r\n      this.cityId = data.id;\r\n      this.cityName = data.text;\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n复制代码第二个页面中的处理\r\n<template>\r\n  <div class=\"page\">\r\n    <div class=\"weui-cells__title\">城市列表</div>\r\n    <div class=\"weui-cells weui-cells_after-title\">\r\n      <radio-group @change=\"handleChange\">\r\n        <label class=\"weui-cell weui-check__label\" v-for=\"item in list\" :key=\"item.id\">\r\n          <radio class=\"weui-check\" :value=\"item.id\" :checked=\"`${item.id}` === selectedId\" />\r\n          <div class=\"weui-cell__bd\">{{ item.text }}</div>\r\n          <div v-if=\"`${item.id}` === selectedId\" class=\"weui-cell__ft weui-cell__ft_in-radio\">\r\n            <icon class=\"weui-icon-radio\" type=\"success_no_circle\" size=\"16\" />\r\n          </div>\r\n        </label>\r\n      </radio-group>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport storage from '../../utils/storage';\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      list: [\r\n        { id: 0, text: '北京' },\r\n        { id: 1, text: '上海' },\r\n        { id: 2, text: '广州' },\r\n        { id: 3, text: '深圳' },\r\n        { id: 4, text: '杭州' },\r\n      ],\r\n      selectedId: ''\r\n    }\r\n  },\r\n  onLoad({ id }) {\r\n    this.selectedId = id;\r\n    \r\n    // 取出 emitter\r\n    this.emitter = storage.get('indexEmitter');\r\n  },\r\n  methods: {\r\n    handleChange(e) {\r\n      this.selectedId = e.detail.value;\r\n\r\n      const item = this.list.find(({ id }) => `${id}` === e.detail.value);\r\n\r\n      // 触发事件并传递数据\r\n      this.emitter.emit('onSelect', { ...item });\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n复制代码效果展示\r\n传送门\r\ngithub\r\n总结\r\n之所以将Storage定义成全局的，是为了保证第一个页面放到Storage中和第二个页面从 Storage 中取出的emitter是同一个实例，如此第一个页面才能正确监听到第二个页面触发的事件。也可以使用 vuex，将 emitter 放到 state 中。" } { "title": "小程序 input 使用setData触发bindinput事件 ", "author": "Rolan", "pub_time": "2019-12-17 00:33", "content": "背景\r\nUI设计如下图\r\n\r\n当有输入内容后显示后面的清除按钮，点击清除删除input里的内容\r\n代码实现\r\n我的代码实现是监听bindinput事件，将输入框中的值this.setData({inputValue}), 清除按钮监听点击事件，触发后this.setData({inputValue: ''})\r\n问题\r\nandroid手机上存在一个问题，当input组件是focus状态时，点击清除按钮输入框会闪一下，键盘保持弹出状态，输入框中的内容并没有删除，再次点击后才能删除， 开发者工具和ios均没有上述问题\r\n解决\r\n我发现出现上面的问题是因为在点击清除按钮时额外的触发了一次bindinput事件，将输入框中的值又重新赋值给inputValue了，我一开始以为，额外触发bindinput事件是因为input失焦导致的，但是后面又发现我点击空白的地方并不会触发bindinput事件\r\n后来我发现是setData导致的，找到了原因就可以对症下药了，查看开发文档发现bindinput的返回值中有一个keyCode属性，这个属性只有在键盘输入的时候才会有，用于记录输入的键值，所以我在bindinput中加了一层判断，如果有keyCode这个属性才会进行后面的运算。\r\n缺陷\r\n在开发者工具中使用键盘输入bindinput的返回值中并没有keyCode这个属性，所以在调试时就会存在输入的值并不会赋值给inputValue,需要注释对keyCode的判断。\r\n疑问\r\n上面的问题只会在input组件是focus状态时才会出现，如果一开始不是focus时直接点击清除按钮并不会出现上述问题，所以这个bug可能还和同时监听bindinput和bindblur或者bindfocus有关，这个有待后面进行验证。" } { "title": "某相册类小程序项目总结 ", "author": "Rolan", "pub_time": "2019-12-19 00:02", "content": "某相册类小程序项目总结1.项目简介一款为家庭设计的亲密社交产品，分为云端存储、智能电视、小程序三个平台，小程序端主要功能包括：建立相册，上传图片、视频，单张图片(视频)的预览、分享、下载、评论相册集预览、分享、下载、评论相册内容管理，删除、下载、设置封面、重命名、设置成开机视屏及屏保图片等照片共享，手机、电视多端家庭内容同步和管理邀请、删除家庭成员，添加、删除绑定设备个性化设置家庭昵称、自己昵称、相册名称2. 主要工作和疑难点汇总2.1 主要工作封装api请求，改造wx.requeset方法，封装http请求抽取公共样式文件，在每个page文件夹的.wxss文件中，通过import 引入，\t如：@import \"../../lib/base.wxss\";抽取公共组件，如单个相册组件、弹出卡片组件、个人头像组件、照片卡片组件，通过在各个页面配置usingComponents参数使用。封装全局公共函数业务逻辑接入百度统计, 统计实时数据在我的应用中添加小程序appkey，下载解压后的js文件到utils文件夹中去，同时将百度添加到request合法域名中去。2.2 业务亮点2.3 疑难点汇总如何在小程序中使用less，可以实时转化为 .wxss文件？小程序Page里的函数比app.js先执行的解决办法fixed 元素 auto 不生效原因封装一个有输入框的modal层组件微信小程序去除button默认边框样式小程序如何获取点击元素信息小程序如何在页面间传递数组对象？小程序如何批量上传图片chooseImage、chooseVideo的回调函数中，wx.uploadFile\r\n上传，更新进度\r\nthis.data.updated_length + 1\r\n\r\n当所有照片都上传成功，updated_length == total_length时，\r\n显示完全上传完毕\r\n\r\n视频的进度显示和图片的不一样\r\n图片是每次上传成功一张，updated_length + 1\r\n视频是调用\r\nwx.uploadFile 对象的 onProgressUpdate 函数，看到视频上传进度，每500毫秒更新一次小程序几个组件如何让swiper 跳转到点击的index ？current 参数\r\npreview了, 还能点击图片么,  失败，不使用\r\nhttps://www.cnblogs.com/BlueCc/p/10172742.html动态设置小程序背景图片如何实现分享、点赞功能分享： onShareAppMessage, 点赞：根据本人是否点赞过，是否有点赞权限\r\n\r\nonShareAppMessage: function(res) {\r\n    var obj = {\r\n      from: 'sharephoto',\r\n      mac: app.globalData.mac,\r\n      open_id: app.globalData.open_id,\r\n      member_id: app.globalData.current_member.member_id,\r\n      family_id: app.globalData.family_id,\r\n      album_id: this.data.album_id\r\n    }\r\n    obj = JSON.stringify(obj);\r\n    var name = app.globalData.current_member.nick_name;\r\n    var shareObj = {\r\n　　　　title: `${name}跟你分享了一本有趣的相册集‘${this.data.album_title}’`,        // 默认是小程序的名称(可以写slogan等)\r\n       path:`pages/login/login?message=${obj}`,\r\n　　　　imageUrl: this.data.album_cover,     //自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径，支持PNG及JPG，不传入 imageUrl 则使用默认截图。显示图片长宽比是 5:4\r\n　　　　success: function(res){\r\n　　　　},\r\n　　　　fail: function(){\r\n　　　　}\r\n　　};\r\n　　return shareObj;\r\n  },\r\n        \r\n\r\n\r\n\r\n//节流,300ms才能点一次\r\nif (this.timer) {\r\n  clearTimeout(this.timer)\r\n}\r\nthis.timer = setTimeout(() => {\r\n  console.log('点击点赞', this.data.like_id);\r\n  server.like(family_id, this.data.album_id, mac, member_id, open_id, app.globalData.open_id, form_id,  this.data.like_id).then((res)=>{\r\n    this.getPhotoBlock();\r\n  })\r\n}, 300)如何实现全选、单选功能对某一天日期的照片，如果没张都选了，传递今天整个相册\r\n每次单选照片都会重新判断是否全选小程序时间过滤器 formatTime util的使用wxs中new Date()等js方法不可用,  所以不能用过滤器，还是用方法为什么多个 formId 会重复，因为不支持同时获取多个 formId, 每次只能获取一个如何实现预览照片，点击后跳转到单张照片？wx.previewImage，这里注意 swiper中，currentIndex 左右滑动是否一致，change函数的处理。如何支持同时预览图片和视频？直接使用 wx.previewImage缺点：不能支持视频，不支持对单张照片做其他操作，智能预览，所以先跳转到 swiper页面\r\n点击照片，预览单张照片。点击视频，跳转到vediofull页面。视频播放是否全屏videofullchange，监听全屏事件，小程序视频根据尺寸判断全屏\r\n在 chooseVideo 的时候， 获取视频的高宽解决，如果有其他照片上传失败怎么办？每次调用 showProgress如何判断小程序来源？分享？邀请？this.data.message.from几个值判断，一共有9种情况\r\n\r\n邀请、分享、在家庭中，不在家庭中，是不是管理员，是否来源扫一扫\r\n\r\n单张相片\r\n相册\r\n受到邀请，不在家庭\r\n受到邀请，在家庭中\r\n扫一扫，不在家庭中\r\n扫一扫，在家庭中，是管理员\r\n扫一扫，在家庭中，不是管理员\r\n不是成员，不是扫一扫\r\n已经在家庭中\r\n其他showActionSheet 有长度限制吗？有6个，超过怎么办？二层底部弹卡如何见人照片与视频内容过滤接入百度移动统计授权问题问题出现在，分享给第三人单张照片的时候，未先授权小程序前，不能查看照片，改变login页面逻辑，去掉入门授权，在点击分享、下载时候再询问授权\r\n首页、家庭页，操作后才授权，点击前会有蒙层安全问题需要操作的页面，onLoad都会 checkInFamily，如果不在任何家庭中，跳转到scan页面哪些情况下展示红包？创建相册、邀请成功成员如何通过扫描二维码获得数据wx.scanCode, 获取返回参数如何判断自己有没有全选评论、点赞、编辑？如果照片、视频来源于分享者，且分享人的id=评论id，用分享人的信息给后端传递参数。无论是获取评论、删除评论、发送评论，被分享人都是使用的分享者信息。一级tab页面需要哪些验证？1，首先检查有没有授权，wx.getUserInfo，授权后下一步操作  \r\n2，检查checkIn，在不在家庭中，有没有操作权限，没有退出  \r\n3，获取成员信息，检查有没有红包，有，领取后下一步操作如何拿到信息扫描？wx.scanCode({\r\n      success: (res)...\r\n      \r\n  通过res值获取获取验证码逻辑me.data.timerFun = setInterval(function () {\r\n    if (me.data.timer > 0) {\r\n    me.setData({timer:me.data.timer-1})\r\n    }else {\r\n    me.setData({timer:'重新发送'})\r\n      clearInterval(me.data.timerFun);\r\n    }\r\n    }, 1000);4. 业务逻辑梳理4.1 项目哪几个page组成？有几个组件？| 16个page  | 5个组件 |\r\n|  ----  | ----  |\r\n| login  | 获取token、管理跳转 |\r\n| le_login  | 同步账号 |\r\n| about | 账号绑定、消息、关于、意见反馈 |\r\n|  photo-edit | 照片编辑页 |\r\n| select-device | 选择屏保页面 |\r\n| h5 | 红包页面 |\r\n| comment | 评论列表页面 |\r\n| swiperphotos | 视频、照片滑动页面 |\r\n| vediofull | 全屏播放视频页面 |\r\n| photomanage | 照片管理页面，全选、反选、下载 |\r\n| photos | 相册所有照片页面 |\r\n| one-photo | 单张照片分享页面 |\r\n| homepage | 首页，我的相册页面 |\r\n| familypage | 家庭首页 |\r\n| del-member | 删除成员、设备页面 |\r\n| my-modal | 弹卡组件|\r\n| member-icon | 头像组件|\r\n| photo-album | 相册组件|\r\n| photo-detail | 相册详情组件|\r\n| red-packet | 红包组件|4.2 挑几个页面看看family 页面？1.1 邀请成员主要通过 onShareAppMessage 函数，将邀请人的信息添加在 path的参数中，在login页面中获得1.2 添加设备调整到 homescan页面1.3 退出家庭//如果只剩本人自己, 解散家庭，否则按照退出家庭算photomanage 页面？（点击，下载、设置壁纸，设置屏保后跳转的页面）全选，反选逻辑\r\n\r\n\r\n\r\n设置封面逻辑，如何做到 所有天，只有一个封面？每一天的照片、视频，是一个组件\r\n\r\nselect_photos  所有选中的照片\r\n\r\n\r\n选照片、下载、删除逻辑：\r\n传值过来的是 按日期分布的数组，按照日期对应，修改当天的照片数组。\r\n遍历所有天的照片，计算选中张数，编号。\r\n\r\n设置封面逻辑：\r\n所有天照片，只有有一天选中了，其他所有置灰。photos 页面？ 点击相册进入的页面功能：上传照片、视频，点赞、评论vediofull 页面首先需要创建视频播放上下文对象   \r\nwx.createVideoContext('myVideo');\r\n\r\n退出：\r\n视频对象 pause，退出全屏， 对象置为null\r\n\r\n监听是否需要横屏：\r\n如果视频宽度大于高度，横屏swiperphotos 页面如何支持，同时预览照片和视频？  \r\n不使用原生自带的 wx.previewImage\r\n视频，跳转到 vediofull 页面\r\n\r\n定位到当前照片是，所有 swiper数组的第几章照片  \r\n初始状态，当前滑动照片数，预览照片上面的显示数字，current_index，和 swiper组件绑定的，current值差1，change函数滑动照片，改变current_index值5. 几个组件简介member-icon:支持头像组件两种形态：文字在头像下方、文字在头像右方my-modal:支持弹出会话层有input文本框，支持编辑和新建功能\r\n    \r\n    新建相册名称为空，编辑相册名称为相册名称，怎么做到的？\r\n    新建，文本框内容为update_value，编辑为从父类传过来的数据，textvalue\r\n    \r\n    如何在操作完编辑后，新建，相册名称为空？\r\n    每次确认后，input框内容置空\r\n    \r\n    实时计算文本框字数？\r\n    bindinput函数photo-album: 相册组件每个相册组件，点击跳转到该相册详情页面red-packet: 红包组件//将红包信息参数发送给后端，传递给前端一个web-view 地址链接\r\n    //webview src指向网页的链接。（承载网页的容器，会自动铺满整个小程序页面）\r\n    <web-view src=\"{{link}}\"></web-view>photo-detail: 相册详情组件，支持同一天照片全选、反选，设置屏保、删除、下载等功能如何区分对照片的操作类型？设置封面？下载？删除？根据前一个页面传过来的操作类型判断\r\n    photo-detail只是一天的照片、视频操作，如何将所有日期选中照片传递给后端？\r\n    每次触发某一天的照片，是一个数组，向父元素触发事件，\r\n    \r\n    this.data.photo_block.forEach((item, index)=> {\r\n     if(item.days == photo.days) {\r\n       this.data.photo_block[index] = photo;\r\n     }\r\n   })\r\n   \r\n     \r\n     如何统计总数？\r\n     每次重新计算选中照片。遍历。6. 问题汇总解答1. 如何在小程序中使用less，可以实时转化为 .wxss文件？微信小程序只支持原生css写法，但是很浪费时间，使用 wxss-cli 可以实时将编写的 .less 文件自动编译为 .wxss 文件1、npm或者yarn全局安装wxss-clinpm install -g wxss-cli2、运行wxss-cli命令(miniProject为小程序目录)，less文件保存时自动编译wxss ./miniProject参考资料2. 小程序Page里的函数比app.js先执行的解决办法问题描述：当我们初始化一个小程序时，默认文件 app.js 中有onLaunch函数，onLaunch: function () {\r\n    console.log(\"onLaunch\");\r\n    wx.login({\r\n      success: res => {\r\n        console.log(\"login\");\r\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n      }\r\n    })\r\n}默认目录，\"pages/index/index\", 中index.js 有 onLoad函数onLoad: function () {\r\n    console.log(\"index onLoad\");\r\n}小程序网络请求默认为异步请求，在app.js的onLaunch运行后进行异步请求时，程序不会停止，index.js页已执行onload, onload里面的数据会因为没有获取到app.js里的东西而报错, 我们希望onLaunch执行完后再执行onLoad。他们的执行顺序是，onLaunch > index onLoad > login我们希望的执行顺序是：onLaunch > login > index onLoad解决办法定义回调函数, onload里获取不到东西就一直获取，不执行下一步操作，直到获取到app.js的数据才继续执行。若login返回为空，则给app.js注册一个loginSuccessCallback回调，这个回调方法的执行时机，就是app.js中的异步请求完毕把 app.js 中的 onLaunch 中方法拿到 index.js 文件中，按照自己的逻辑写使用promise方法1：App({\r\n  onLaunch: function () {\r\n    wx.login({\r\n      success: res => {\r\n        this.globalData.checkLogin = true;\r\n        //由于这里是网络请求，可能会在 Page.onLoad 之后才返回\r\n        // 所以此处加入 callback 以防止这种情况\r\n        if (this.checkLoginReadyCallback){\r\n          this.checkLoginReadyCallback(res);\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    checkLogin: false\r\n  }\r\n  \r\n  ...\r\n})\r\n \r\n\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n \r\nPage({\r\n  data: {\r\n    test: false\r\n  },\r\n  onLoad: function () {\r\n    let that = this;\r\n    //判断onLaunch是否执行完毕\r\n    if (app.globalData.checkLogin){\r\n      that.setData({\r\n        test:true\r\n      })\r\n    }else{\r\n      app.checkLoginReadyCallback = res => {\r\n            //登陆成功后自己希望执行的，和上面一样\r\n        that.setData({\r\n          test:true\r\n        })\r\n      };\r\n    }\r\n  }\r\n})方法2：把 app.js 中的 onLaunch 中登陆后才执行的方法拿到 index.js 文件中，这是最简单的方法//index.js\r\n\r\nonLoad: function () { \r\n    wx.login({\r\n      success: res => {\r\n        resolve(res); \r\n      }\r\n    })\r\n}方法3：// app.js中定义一个新的方法\r\nApp({\r\n  onLaunch: function () {\r\n      ...\r\n  },\r\n  getAuthKey: function (argument) {\r\n    var that = this;\r\n    return new Promise(function(resolve, reject){\r\n        wx.login({\r\n          success: res => {\r\n            resolve(res); \r\n          }\r\n        })\r\n    })\r\n  }\r\n  ...\r\n  \r\n})\r\n\r\n//index.js\r\nonLoad: function () {\r\n    ...\r\n        \r\n    app.getAuthKey().then(function(res){\r\n      console.log('res')\r\n    })\r\n }参考资料：\t参考1 参考2 参考33. fixed 元素 auto 必须要同时设置 top、leftposition: fixed;\r\ntop: 132rpx;\r\nleft: 30rpx;\r\nwidth: 690rpx;\r\nmargin: 0 auto;4.封装一个有输入框的modal层组件其实很简单，就是在modal中添加新的 input,<view>\r\n    <modal class=\"modal\" wx:if=\"{{!hiddenModal}}\"\r\n     title=\"{{title}}\" confirm-text=\"确定\" cancel-text=\"取消\" bindconfirm=\"modalconfirm\" bindcancel=\"modalcancel\">\r\n        <view class=\"input-line\">\r\n            <input placeholder='请输入内容' maxlength=\"{{ maxlength }}\" bindinput='input' type=\"text\" type=\"text\"  value=\"{{ textvalue }}\" />\r\n            <text>{{ currentlength}}/{{ maxlength }}</text>\r\n        </view>\r\n    </modal>\r\n</view>\r\n\r\n.modal{\r\n    width: 540rpx;\r\n    max-width: 540rpx;\r\n    border-radius: 28rpx;\r\n    .input-line {\r\n        display: flex;\r\n        border: 2rpx solid rgba(0, 0, 0, 0.05);\r\n        font-size: 28rpx;\r\n        padding: 16rpx;\r\n        height: 40rpx;\r\n        line-height: 40rpx;\r\n    }\r\n    input,  text{\r\n        display: inline-block;\r\n        vertical-align: top;\r\n    }\r\n    input {\r\n        flex: 1;\r\n    }\r\n    text {\r\n        width: 90rpx;\r\n        color: #FFA004 ;\r\n    }\r\n}5.微信小程序去除button默认边框样式button::after{\r\n    border: none;\r\n}6.小程序如何获取点击元素信息使用驼峰模式，给点击元素绑定 data-\t* ，通过 event.currentTarget.dataset 获取<image src=\"{{ item.mini_pic }}\" class=\"{{ item.show_opacity ? 'show_opacity' : ''}}\" bindtap=\"tap\" data-message=\"{{ item }}\">\r\n</image>\r\n\r\n// 获取的点击节点元素是一个对象\r\n tap: function(event) {\r\n    var message = event.currentTarget.dataset.message;\r\n}7. 小程序如何在页面间传递数组对象？方法1：A页面跳转链接添加参数，B页面onLoad 接受方法2：设置全局变量 globalData，用的少，一般适用于全局共享的一份信息，如用户open_id等// A页面\r\n// 数组、对象都需要stringify\r\nvar listData = JSON.stringify(that.data.listData)\r\nvar taskArray = JSON.stringify(that.data.taskArray)\r\nwx.navigateTo({\r\n    url: '../workRecord/updateBatch?listData=' + listData + '&taskArray=' + taskArray \r\n})\r\n\r\n//B页面\r\nonLoad: function (options) {\r\n    var that = this\r\n    var listData = JSON.parse(options.listData)\r\n    var taskArray = JSON.parse(options.taskArray)\r\n}\r\n\r\n\r\n\r\n//A页面：\r\napp.globalData.open_id = 3;\r\n//B页面：\r\nvar lala = app.globalData.open_id;8. 小程序如何批量上传图片chooseImage、的回调函数中，wx.uploadFile\r\n    上传，更新进度6. 其他封装http请求class HTTP{request({url,data={},method='POST', header={'content-type':'application/json'} }){\r\n            return new Promise((resolve, reject)=>{\r\n                this._request(url,resolve,reject,data, method, header)\r\n            })\r\n        }\r\n        _request(url,resolve, reject, data={}, method='POST', header){\r\n            wx.request({\r\n                url:url,\r\n                method:method,\r\n                data:data,\r\n                header: header,\r\n                success:(res)=>{\r\n                    const code = res.statusCode.toString()\r\n                    if (code.startsWith('2') && res.data.errno == 10000){\r\n                        resolve(res.data)\r\n                    }\r\n                    else{\r\n                        if(res && res.data && res.data.errmsg) {\r\n                            this._show_error(res.data.errmsg)\r\n                        }\r\n                        else {\r\n                            this._show_error(tips[1])\r\n                        }\r\n                        console.log('错111111111')\r\n                        reject(res)\r\n                    }\r\n                },\r\n                fail:(err)=>{\r\n                    reject(err)\r\n                    console.log('错22222222')\r\n                    this._show_error(tips[1])\r\n                }\r\n            })\r\n    \r\n        }\r\n    \r\n        _show_error(tip){\r\n            if(!tip){\r\n                tip = tips[1]\r\n            }\r\n            wx.showToast({\r\n                title: tip,\r\n                icon:'none',\r\n                duration:2000\r\n            })\r\n        }\r\n    }" } { "title": "实战：在小程序中获取用户所在城市信息 ", "author": "Rolan", "pub_time": "2019-12-19 00:18", "content": "最近在做自己的小程序《看啥好呢》，这个小程序是使用云开发的方式开发的，功能特别简单，就是获取豆瓣、大麦网的数据展示，虽然功能简单，但还是记录下开发过程和一些技术点，大约会有两篇博文产出，这是第二篇。 GitHub地址背景在《看啥好呢》中有个本地好看 Tab，进去后会获取用户当前所在城市，然后显示该城市的数据，并且显示在导航栏和 Tab上。微信小程序中，我们可以通过调用 wx.getLocation() 获取到设备当前的地理位置信息，这个信息是当前位置的经纬度。如果我们想获取当前位置是处于哪个国家，哪个城市等信息，该如何实现呢？微信小程序中并没有提供这样的API，但是没关系，有 wx.getLocation() 得到的经纬度作为基础就够了，其他的，我们可以使用其他第三方地图服务可以来实现，比如腾讯地图或百度地图的API。所以整个步骤就是：wx.getLocation\r\nreverseGeocoder(options:Object)\r\n在小程序中获取当前的地理位置在小程序中，调用 wx.getLocation ，使用前需要用户授权 scope.userLocation ，代码如下checkAuth(callback) {\r\n  wx.getSetting({\r\n    success(res) {\r\n      if (!res.authSetting\\['scope.userLocation'\\]) {\r\n        wx.authorize({\r\n          scope: 'scope.userLocation',\r\n          success() {\r\n            wx.getLocation({\r\n              type: 'wgs84', \r\n              success(res) {\r\n                callback(res.latitude, res.longitude)\r\n              }\r\n            })\r\n          }\r\n        })\r\n      }\r\n    }\r\n  })\r\n}其中 type 的取值可以为：wgs84 意思返回 gps 坐标gcj02 返回可用于 wx.openLocation 的坐标。运行后会提示如下信息，还需要在 app.json 中配置 permission 字段查询 文档 后得知，得知需要如下配置\"permission\": {\r\n    \"scope.userLocation\": {\r\n      \"desc\": \"你的位置信息将用于小程序位置接口的效果展示\"\r\n    }\r\n}desc 用于在弹出的授权提示框中展示，如下允许后即可获取接口返回的信息，此过程会在右上角胶囊按钮上显示箭头图标{\r\n    accuracy: 65\r\n    errMsg: \"getLocation:ok\"\r\n    horizontalAccuracy: 65\r\n    latitude: 30.25961    // 纬度，范围为 -90~90，负数表示南纬\r\n    longitude: 120.13026    // 经度，范围为 -180~180，负数表示西经\r\n    speed: \\-1\r\n    verticalAccuracy: 65\r\n}latitude 和 longitude 即是我们需要的两个字段腾讯地图接口逆地址解析以腾讯地图为例，我们可以去腾讯地图开放平台注册一个账号，然后在它的管理后台创建一个密钥(key)，以及进行KEY设置，按照 微信小程序JavaScript SDK 入门及使用限制文档在 KEY设置的启用产品中，勾选 WebServiceAPI，选择签名校验方式，因为我是使用云开发的方式，所以没有什么域名也没有授权IP。这部分代码逻辑如下import QQMapWX from '../../scripts/qqmap-wx-jssdk.min.js'\r\nlet qqmapsdk\r\nPage({\r\n    onLoad: function (options) {\r\n      // 实例化API核心类\r\n      qqmapsdk = new QQMapWX({\r\n         key: '开发密钥（key）'    // 必填\r\n      });\r\n      this.checkAuth((latitude, longitude) => {\r\n         // https://lbs.qq.com/qqmap\\_wx\\_jssdk/method-reverseGeocoder.html\r\n         qqmapsdk.reverseGeocoder({\r\n           sig: 'KEY设置中生成的SK字符串',    // 必填\r\n            location: {latitude, longitude},\r\n            success(res) {\r\n                wx.setStorageSync('loca\\_city', res.result.ad\\_info.city)\r\n            },\r\n            fail(err) {\r\n               console.log(err)\r\n               wx.showToast('获取城市失败')\r\n            },\r\n            complete() {\r\n               // 做点什么\r\n            }\r\n         })\r\n      })\r\n    }\r\n}）reverseGeocoder 接口返回的结果，这里面的字段比较多，详细可以看接口文档，里面好几个字段可以取到城市，其中 ad_info 是行政区划信息，我就取这里面的 city 了。全文完。关注公众号，第一时间接收最新文章。如果对你有一点点帮助，可以点喜欢点赞点收藏，还可以小额打赏作者，以鼓励作者写出更多更好的文章。" } { "title": "微信小程序文本展开/收起功能 ", "author": "Rolan", "pub_time": "2019-12-19 00:44", "content": "微信小程序中，有时候文本需要实现这样的功能 1、文本超过n行显示省略号 2、省略时，显示 展开/收起 按钮 3、文本不超过n行时，不显示省略号和展开/收起按钮 实现思路文本过长显示省略号、展开和收起功能，通过css样式即可实现 判断是否显示展开/收起按钮： 通过嵌套元素，可以实现text既显示省略号，其高度又是全显示时的高度 通过SelectorQuery选择器，获取text及其父元素的高度，判断text高度是否超过其父元素高度，决定是否显示展开/收起按钮即可代码wxss.frame {  width: 100%;  max-height: 206rpx;  text-align: left;  display: -webkit-box;  overflow: hidden;  text-overflow: ellipsis;  word-wrap: break-word;  white-space: normal !important;  -webkit-line-clamp: 3;  -webkit-box-orient: vertical;}.nofold {  display: block;  text-overflow: unset;  -webkit-line-clamp: unset;  max-height: unset;}frame样式设置最大高度，超过3行后出现省略号。overflow为hidden，使得text的超出父元素部分隐藏掉。nofold样式则将最大高度、出现省略号的行数去除，以展示全文。wxml<view id=\"frame\" class='frame {{fold == false ? \"nofold\":\"\"}}'>    <text id=\"content\">{{detail}}</text></view>wxml中，在view元素中嵌套text元素。样式写在view中，text不加任何样式（重要）。分别写上id，方便js代码获取其尺寸信息。 javascriptvar query = this.createSelectorQuery();query.select('#content').boundingClientRect();query.select('#frame').boundingClientRect();query.exec(function(res) {  if (res[0] && res[0].height) {    if (res[0].height > res[1].height) {      self.setData({        fold: true,      });    } else {      self.setData({        fold: null,      });    }  }})js代码中，通过选择器获取两者的高度，如果text高度高于view，则说明有省略文本，显示展开/收起按钮。 js的选择器如果是写在onshow/onload方法中，最好加上延迟，以防止出现判断时元素尚未渲染出来的情况。" } { "title": "基于微信小程序picker组件开发的时间自定义功能 ", "author": "Rolan", "pub_time": "2019-12-23 00:33", "content": "背景需求：最近接了一个需求，需要做一个类似电影院的选座功能，不同的是需要自己选择日期，预定时间段，然后根据日期+时间段查询座位信息，结合图片说下需求。a、日期组件可选2天内（当天+第二天）。进入页面默认展示当天日期，预定开始时间为当前时间，预定结束时间为开始时间之后30分钟。b、日期确定后才能选择预定开始时间，开始时间以及结束时间我这边是固定的时间点（08:30-22:30）。开始时间分钟段以5分钟为倍数设置往后推算展示，其余时段不显示。如果当前时间为22:00，则不展示当天时间，自动切换到第二天。c、选择预定结束时间。结束时间已开始时间为标记，半小时为倍数生成规则，其余时段不显示。两个时间段确定以后算出预定时长（小时为单位），并调后端接口查询座位信息。" } { "title": "使用阿里云函数计算构建小程序 ", "author": "Rolan", "pub_time": "2019-12-23 00:43", "content": "在用户使用HyperMotion产品过程中，用户可以通过扫描产品中二维码方式，自助进行Licnese申请。用户提交申请后，请求将发送到钉钉流程中。完成审批后，后台服务将自动根据用户的特征码、申请的数量、可使用的时间将生成好的正式Licnese发送到客户的邮箱中。在原有设计中，使用了Python Flask提供WEB界面，后台使用Celery异步的将用户请求发送至钉钉中，之后采用轮询方式监控审批工单状态，当工单完成审批后，将生成好的License发送至客户提供的邮箱中。实现的效果：这种方式虽然可以满足需求，但是在使用过程中也发现有如下痛点：1、由于对于可用性要求比较高，所以将整套应用以容器化方式部署在云主机上，程序高可用性依赖于底层的平台，基于成本考虑并没有在多可用区进行部署。2、当业务变化时，需要专人将容器从本地容器库上传后进行更新，更新速度慢，敏捷性低。3、需要专人对操作系统层进行维护，并且由于该云主机还运行了其他程序，所以管控上也存在安全风险。基于以上出现的问题，决定对原有二维码程序进行重构，并重新部署在阿里云函数计算服务上。1、第一阶段的改造主要是将二维码扫描程序移植到函数计算服务中。2、第二阶段的改造主要是将发送二维码程序改造为函数计算服务，使用钉钉流程接口中的Callback方法调用该接口，在审批结束后触发发送License流程。2、函数计算服务——无服务，零运维最早接触Serverless的雏形是在2011年开发Cloud Foundry项目时，当时留下一个非常深的印象就是把写好的应用直接上传就完成了部署、扩展等。但是当时Cloud Foundry有一个非常大的局限性，受限于几种开发语言和框架。记得当时的Cloud Foundry只支持Node.js、Python、Java、PHP、Ruby on Rails等，脱离了这个范围则就无法支持，所以当时我其实对这种形态的应用场景存在很大的疑问。这种困惑直到2013年Docker的出现而逐步解开，Docker的出现让开发语言、框架不再是问题，巧妙的解决了Cloud Foundry上述局限性。但是Docker毕竟只是一种工具形态，还不能称得上是平台，紧接着k8s的出现弥补了这一空白，使得Docker从游击队变成了正规军。在这个发展过程中我们不难看出，软件领域发展出现了重大变革，从服务器为王逐渐演进到应用为王的阶段。如果说虚拟化改变了整个物理机的格局，那么无服务化的出现则改变了整个软件开发行业。由于网上各种文档太多了，这里就不对Serverless基本概念进行介绍了，借用一张图说明下。另外还有一点，我们从这里面看到IT行业里的某些岗位，注定要消失的，比如传统运维。3、应用架构整个架构上，分为两个函数计算服务完成：二维码前端：主要用于显示页面，并承担HTTP请求转发代理的角色，将请求转发至二维码后端，发给钉钉，采用HTTP触发器，允许公网访问。二维码后端：用于将用户请求发送给钉钉，该部分服务仍然采用HTTP触发器，不同于前端，该服务是不允许公网直接访问的，但是需要配置NAT网关，通过网关访问钉钉，实现固定IP访问钉钉的效果。从逻辑上讲，整个应用并不复杂，但是在实际使用时遇到最大的问题来自钉钉白名单。由于函数服务对外连接的IP并不固定，所以无法在钉钉中添加，那么就要求函数服务对外连接的IP地址一定要固定。社区中提供的方法主要分为：ECI（运行Nginx充当Proxy），优势是便宜，劣势是高可用性需要自己维护NAT网关，优势是高可用性，劣势是比ECI贵4、构建过程由于篇幅原因，这里只介绍关键步骤。4.1 构建模板为了后续管理和扩展方便，选用了阿里云函数计算中使用flask-web模板进行构建，同时可以将前端静态文件模板存放于项目下（出于统一管理的需要，也可以存放于阿里云的OSS中，作为静态网站发布）。前端我们使用flask-web作为模板创建函数，后端我们直接采用最简单的HTTP函数。函数入口配置，及触发器配置：服务配置，包含公网访问权限，专有网络配置，日志配置，权限配置。前端服务需要公网访问权限，不需要专有网络配置，需要的权限为：AliyunLogFullAccess。后端服务不需要公网访问权限，但是需要配置好的NAT映射的专有网络，由于函数服务在北京2区中在cn-beijing-c和cn-beijing-f，所以在新建交换机时需要使用这两个区。还需要选择安全组，由于出方向并没有明确禁止，所以不需要特别的安全组规则设定。需要的权限为：AliyunLogFullAccess/AliyunECSNetworkInterfaceManagementAccess。配置好后，通过导出功能，分别下载前端和后端代码和配置，在本地进行开发调试。4.2 前端开发我们的前端采用Vue.js进行开发，在main.py同级新建templates目录。Vue编译好的静态文件可以放入该目录中，后续Flask会加载该文件作为入口文件。├── templates\r\n│   ├── index.html\r\n│   ├── static\r\n├── main.py\r\n# main.py sample\r\nfrom flask import render_template\r\n\r\nLICENSE_URL = \"https://[x](https://.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xxxx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xxxxxx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license).cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license\"\r\n\r\n@app.route('/qr_code', methods=['GET'])\r\ndef index():\r\n      return render_template('index.html')\r\n\r\n      @app.route('/qr_code/license', methods=['POST'])\r\n      def create():\r\n            payload = request.json\r\n                resp = requests.post(LICENSE_URL,\r\n                                                 json=payload,\r\n                                                                              headers=DEFAULT_HEADERS)\r\n                return make_response(resp.text, resp.status_code)\r\n4.3 后端开发后端的开发较为简单，实现一个函数支持POST请求，将转发的结果发送至钉钉即可。4.4 本地调试阿里云在本地开发时提供了fun应用部署和开发工具，详细使用方法见： https://help.aliyun.com/document_detail/64204.html 。安装funnpm config set registry [https://registry.npm.taobao.org](https://registry.npm.taobao.org/) --global\r\nnpm config set disturl [https://npm.taobao.org/dist](https://npm.taobao.org/dist) --global\r\n\r\nnpm install @alicloud/fun -g\r\n配置funfun config\r\n\r\n(venv) [root@ray-dev test_func]# fun config\r\n? Aliyun Account ID xxxxxxxx\r\n? Aliyun Access Key ID ***********r5Qd\r\n? Aliyun Access Key Secret ***********kCCi\r\n? Default region name cn-beijing\r\n? The timeout in seconds for each SDK client invoking 10\r\n? The maximum number of retries for each SDK client 3\r\n? Allow to anonymously report usage statistics to improve the tool over time? Yes\r\nHttp Trigger本地运行fun local start\r\n部署fun deploy\r\n4.5 配置域名解析部署完成后有一点需要特别注意，必须要绑定域名，并且设定必要的路由。如果在没有绑定域名的情况下，服务端会为 response header中强制添加 content-disposition: attachment字段，此字段会使得返回结果在浏览器中以附件的方式打开。（ https://www.alibabacloud.com/help/zh/doc-detail/56103.htm ）" } { "title": "小程序 找不到可构建的npm包-解决方法 ", "author": "Rolan", "pub_time": "2019-12-23 00:52", "content": "问题复现：在项目根目录执行npm init -y # 初始化npm最近在学习7yue老师的koa课，使用到npm包，出现这个问题，目录结构如下工具 -> 构建 npm -> '没有找到可以构建的 NPM 包'查看文档查阅npm 支持| 微信开放文档)有如下说明此处并没有强制要求 node_modules 必须在小程序根目录下（即 project.config.js 中的 miniprogramRoot 字段），也可以存在于小程序根目录下的各个子目录中。但是不允许 node_modules 在小程序根目录外。所以： npm包应放在小程序根目录下 ，而我搞混了小程序目录和项目根目录小程序根目录(为 /project.config.json 中 miniprogramRoot字段指定)项目根目录(为 / )是两个不同位置原来是我的node-models放错了地方，正确位置应该是**miniprogram**文件夹下问题解决cd miniprogramnpm init -ynpm install lin-ui --production工具 -> 构建 npm目录如下，出现了miniprogram_npm" } { "title": "【微信小程序】知乎视频查看 ", "author": "Rolan", "pub_time": "2019-12-24 00:04", "content": "第一版做了知乎视频保存视频到本地相册的功能。进一步我们可以做一个增强功能，支持视频查看。用户在登录状态下载过的知乎视频，可以在我的浏览或者查看历史记录在线查看视频这个功能的核心其实是用户身份标识的获取，因为我们只要拿到了用户标识，相应用户下载过的视频就可以和用户标识绑定，存储到数据库中。当用户下次再进入app，只要通过用户标识就可以去数据库中拿用户之前下载过的视频就可以了。表结构如下：CREATE TABLE `wx_user_zhihu_answer` (\r\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\r\n  `is_delete` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '软删除标识',\r\n  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\r\n  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\r\n  `openId_md5` varchar(128) NOT NULL DEFAULT '' COMMENT 'openId md5加密',\r\n  `answer_url` varchar(128) NOT NULL DEFAULT '' COMMENT '知乎回答url',\r\n  PRIMARY KEY (`id`),\r\n  KEY `idx_is_delete` (`is_delete`),\r\n  KEY `idx_openId_md5` (`openId_md5`),\r\n  KEY `idx_answer_url` (`answer_url`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户及知乎回答信息';获取用户标识我们借鉴微信的例程来设计用户登录逻辑首先按钮上设置open-type=\"getUserInfo\",可以让用户自主选择是否授权小程序。<button class=\"login-btn\" wx:if=\"{{!hasUserInfo}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">\r\n  点击登录\r\n</button>当用户点击并确认授权，会执行回调的getUserInfo方法getUserInfo: function(e) {\r\n  app.globalData.userInfo = e.detail.userInfo;\r\n  this.setData({\r\n    userInfo: e.detail.userInfo,\r\n    hasUserInfo: true\r\n  });\r\n\r\n  // 登录\r\n  wx.login({\r\n    success: res => {\r\n      const { code } = res;\r\n      app.globalData.loginInfo.jsCode = code;\r\n      this.fetchUserIdInfo();\r\n      // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n    }\r\n  });\r\n  // 获取用户信息\r\n  wx.getSetting({\r\n    success: res => {\r\n      if (res.authSetting[\"scope.userInfo\"]) {\r\n        // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n        wx.getUserInfo({\r\n          success: res => {\r\n            const { encryptedData, iv } = res;\r\n            // 可以将 res 发送给后台解码出 unionId\r\n            app.globalData.loginInfo.encryptedData = encryptedData;\r\n            app.globalData.loginInfo.iv = iv;\r\n            this.fetchUserIdInfo();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  });\r\n},\r\nfetchUserIdInfo() {\r\n  const { jsCode, encryptedData, iv } = app.globalData.loginInfo;\r\n  if (!(jsCode && encryptedData && iv)) {\r\n    return;\r\n  }\r\n  wx.request({\r\n    url: userInfoFetchUrl,\r\n    method: \"POST\",\r\n    data: {\r\n      jsCode,\r\n      encryptedData,\r\n      iv\r\n    },\r\n    header: {\r\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n    },\r\n    success: res => {\r\n      res = res.data;\r\n      if (res.code === 1) {\r\n        app.globalData.userIdInfo = res.data;\r\n      }\r\n    }\r\n  });\r\n},getUserInfo可以获取用户的信息，调用wx.login能够拿到code,调用wx.getUserInfo能够拿到encryptedData和iv。拿到code、encryptedData、iv我们就可以调用微信接口以及解码逻辑拿到用户的openId和unionId,我们这部分都放在了后端接口(userInfoFetchUrl)处理，这里我们使用openId标识用户身份，该接口返回的是openId用m5加密后的id。由于所以身份标识相关的操作都在服务器进行且返回的是md5加密后的值，所以极大提高了用户信息的安全性。后端解析用户标识的逻辑如下exports.infoFetch = async params => {\r\n  const { jsCode, encryptedData, iv } = params;\r\n  const sessionRes = await axios.get(\r\n    `${jscode2sessionUrl}?appid=${appId}&secret=${appSecret}&js_code=${jsCode}&grant_type=authorization_code`\r\n  );\r\n  const sessionResData = sessionRes.data;\r\n  const sessionKey = sessionResData.session_key;\r\n  const openId = sessionResData.openid;\r\n  const pc = new WXBizDataCrypt(appId, sessionKey);\r\n  const userInfo = pc.decryptData(encryptedData, iv);\r\n  const unionId = userInfo.unionId;\r\n  if (unionId && openId) {\r\n    return {\r\n      openIdMD5: md5(openId),\r\n      unionIdMD5: md5(unionId)\r\n    };\r\n  } else if (openId) {\r\n    return {\r\n      openIdMD5: md5(openId)\r\n    };\r\n  }\r\n  return {};\r\n};拿到用户标识后工作基本就完成了。我们还需要做一些优化，在app.js的onLaunch回调和登录页onLoad回调中获取用户信息，使得用户再次打开app在有效登录时间内依然可以直接使用用户标识。" } { "title": "【微信小程序】写一个能自定义尺寸、样式的switch ", "author": "Rolan", "pub_time": "2019-12-24 00:51", "content": "小程序原生的switch不能灵活的修改宽高、样式，很不方便，我这边参考 WeUI 的开关，写了一个可以自定义尺寸样式的switch组件。直接上代码： https://gitee.com/piscdong/we...效果如下图，可以自定义宽高，可以做成方角的代码分析这个switch主要的难点就是点击后背景颜色变换的动画，这里用到了css的transition、transform两个属性来实现动画，以及::before和::after两个伪元素。wxml基本结构为：<view class=\"switch\">\r\n    <view></view>\r\n</view>父级view是整个switch容器，会用到::before做背景色切换动画，::after做禁用时的灰色遮罩。内部的一个view是来回切换的白点。未选中时默认class是switch，选中时增加一个class：switch_checked。选中状态到未选中状态背景有一个从中间变大到全部的白色动画，所以需要给父级view设置一个颜色作为背景色。.switch {\r\n    ...\r\n    background: #00c000;\r\n    position: relative;\r\n}未选中时::before覆盖整个容器，选中时::before设置 transform: scale(0); ，这样选中时白色区域就会缩放到最小，再加上transition的实现动画效果。.switch::before {\r\n    display: block;\r\n    content: '';\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    border-radius: 9999rpx;\r\n    background: #fff;\r\n    transition: all 0.35s cubic-bezier(0.45, 1, 0.4, 1);\r\n}\r\n\r\n.switch_checked::before {\r\n    transform: scale(0);\r\n}来回移动的白点，未选中时通过 left: 0; 定位到左侧，选中时将left设置为100%定位到右侧，但是这样白点会完全移出容器范围，所以还需要加上 transform: translateX(-100%); 将白点向左再一定自身宽度的100%，同样加上transition的实现动画效果。.switch view {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 60rpx;\r\n    height: 60rpx;\r\n    border-radius: 50%;\r\n    background: #fff;\r\n    box-shadow: 0 2rpx 6rpx rgba(0, 0, 0, 0.4);\r\n    transition: all 0.35s cubic-bezier(0.45, 1, 0.4, 1);\r\n}\r\n\r\n.switch_checked view {\r\n    left: 100%;\r\n    transform: translateX(-100%);\r\n}关于“::”最后搭车说一下“:”和“::”，“:”是伪类，“::”是伪元素。按照我的理解：伪类不会在dom中增加节点，只不过是css选择器的一种特殊效果；伪元素会增加节点，flex布局中会影响到其他元素。为了保证兼容性，css3是允许伪元素使用单个冒号。" } { "title": "小程序的getElementsById，就像一把梭 ", "author": "Rolan", "pub_time": "2019-12-24 00:52", "content": "使用selectComponent可以抓取自定义组件实例对象，但在层层嵌套结构的业务场景中，id的设置繁复，js/wxml开发界面频繁的切换，查找、维护、调整的开发工作很是让人抓狂啊好想封装一个getElementsById方法给小程序，像在web开发中那样能够方便的获取页面元素。在父子子子子级间轻松调用，好想念jquery开发的一把梭时代！实现如下需求：任何绑定id的自定义组件都能够方便抓取实例对象(任何嵌套层级均可调用)通过数据配置思路实现不难，我们可以将所有自定义组件在create生命周期方法时将\tthis 挂载到一个全局变量中，\tdetached 生命周期时销毁该实例(不然爆内存)实现准备一个全局变量app._elements = {}\r\n复制代码挂载/销毁方法一个全局的挂载、销毁方法，方便将实例对象注册、注销在app._elements上app.mount = function(id, context){\r\n    app._elements[id] = context\r\n}\r\n\r\napp.unmount = function(id){\r\n    app._elements[id] = null\r\n}\r\n复制代码getElementsById定义全局\tgetElementsById 在Page中能够方便调用app.getElementsById = function(id){\r\n    let res = app._elements[id]\r\n    if (!res) {  // 兼容selectComponent\r\n        return wx.selectComponent('#'+id) || wx.selectComponent('.'+id)\r\n    }\r\n    return res\r\n}\r\n复制代码自定义组件ui-component组件const app = getApp()\r\nComponent({\r\n  options: {\r\n    multipleSlots: true, // 在组件定义时的选项中启用多slot支持\r\n    addGlobalClass: true\r\n  },\r\n  properties: {\r\n    dataSource: {\r\n      type: Object,\r\n    },\r\n  },\r\n  data: {},\r\n  behaviors: [],\r\n  lifetimes: {\r\n    created: function() {\r\n    },\r\n    attached: function() {\r\n        this.id = this.data.dataSource.$$id  // 专用$$id来指定唯一名称\r\n    },\r\n    ready: function() {\r\n        app.mount(this.id, this)\r\n    },\r\n    detached: function(){\r\n        app.unmount(this.id)\r\n    }\r\n  },\r\n  methods: {\r\n      active(clsName){\r\n          /* do something */\r\n      }\r\n  })\r\n复制代码应用下面开始在Page中使用\tgetElementsById 来抓取自定义组件实例wxml<ui-component dataSource=\"{{config}}\" />\r\n复制代码jsPage({\r\n    data: {\r\n        config:  {\r\n            $$id: 'component-id',\r\n            title: 'some text'\r\n        }\r\n    },\r\n    \r\n    onReady(){\r\n        // 我们应该在onReady中来调用，onLoad时，页面组件结构并没有渲染完成  \r\n        const $ele = app.getElementsById('component-id')\r\n        $ele.active('.active') \r\n    }\r\n})\r\n复制代码至此，基本思路已经实现，现在即兼容了selectComponent方法，又简化了写模板id的麻烦。不知道大家有没有了解小程序组件是可以递归嵌套自己的(模板不能递归嵌套)。因此聪明的你应该可以想到通过数据嵌套去实现组件嵌套，进而实现结构嵌套，这样我们就能够实现很复杂的页面结构，当然小程序目前建议是结构应该在30层左右，然并卵，反正它能够正常显示，哈哈" } { "title": "小程序  点击按钮后修改颜色(样式) ", "author": "Rolan", "pub_time": "2019-12-3 00:32", "content": "需实现的功能：点击按钮后，按钮的颜色会加深效果展示：原按钮 点击后按钮思路：给按钮设置一个点击事件，点击了按钮后，修改按钮的样式。代码：test.wxml文件 <view wx:if=\"{{sty==0}}\">  <view class=\"score\" style=\"background-color:{{score}};\" catchtap='score'>    <text>按钮一</text>  </view></view><view wx:if=\"{{sty==1}}\">  <view class=\"score\" style=\"background-color:{{score}};\" catchtap='score'>    <text>按钮一</text>  </view></view>test.js文件Page({  /*** 页面的初始数据*/  data: {    sty:0,    score: '#fff5df',   }, score: function (e) {   //点击按钮，样式改变   let that = this;   that.setData({     sty: 1,     score: 'rgba(252,178,22, 0.3)'   });  },)}test.css文件.score{  width:335rpx;  border-radius:10rpx 0rpx 0rpx 10rpx;}.score text{  color: #FCB216;}" } { "title": "小程序-腾讯地图SDK-获取当前地址 ", "author": "Rolan", "pub_time": "2019-12-3 00:41", "content": "如何获取用户当前地址，这个就要先用到小程序的定位功能:定位官方文档第一步获取当前定位在js当中写运行项目之后会有个这样的弹窗：这是因为开发者需要说明获取用户地理位置的用途。 解决方法： 在app.json中增加permission属性。这样就可以获取到用户的地理坐标了。第二步讲当前定位转换程地址信息这个功能需要用到腾讯地图SDK：官方文档 官方文档上使用SDK的步骤写的挺详细的，还带上了各种链接：第4步的安全域名设置在你自己的小程序管理后台里设置 以上4步都完成后，将下载好的SDK文件放到项目里。 在页面js里引入SDK：我们需要用到的是SKD里面的reverseGeocoder()方法，所以我们在获取到用户当前坐标后调用这个方法：这样就将地址坐标转换成了地址，在页面上简单展示出来：完整代码 最后贴上我的js完整代码，写的有点小啰嗦了，如果有什么不太懂的地方欢迎加我qq一起讨论下：546529770，谢谢~~js/**引入SDK核心类 */var qqSDK = require('../../apis/qqmap-wx-jssdk.min.js')Page({  /**   * 页面的初始数据   */  data: {    latitude: '',    longitude: '',    positionData: ''  },  /**   * 生命周期函数--监听页面加载   */  onLoad: function(options) {    var _this = this    /**实例化SDK核心类 */    var qqMap = new qqSDK({      key: '3B4BZ-QHNK3-HLX34-YKUQA-YDHCV-CHFFB' //必填    });    /**获取当前坐标 */    wx.getLocation({      success: function(res) {        var latitude = res.latitude        var longitude = res.longitude        qqMap.reverseGeocoder({          success: function(res) {            var address = res.result.address;            _this.setData({              latitude: latitude,              longitude: longitude,              positionData: address            });          }        })      }    })  }})" } { "title": "小程序云开发模糊查询，实现数据库多字段的模糊搜索 ", "author": "Rolan", "pub_time": "2019-12-3 00:53", "content": "最近做小程序云开发时，用到了一个数据库的模糊搜索功能，并且是要求多字段的模糊搜索。网上也有一大堆资源，但是都是单个字段的搜索。如下图上图只可以实现time字段的模糊搜索。但是我们如果相对数据表里的多个字段做模糊查询呢？该怎么办呢。多字段模糊搜索一，如我们的数据表里有以下数据，我们想同时模糊查询name和address字段如我们搜索“周杰”可以看到我们查询到下面两条数据。二，如我们搜索“编程”，可以搜索到下面数据可以看到我们搜索到的两条数据，一个是name字段为 编程小石头， 一个是address字段里包含“编程“ 字样。下面把代码贴给大家    let key = \"编程小石头\";    console.log(\"查询的内容\", key)    const db = wx.cloud.database();    const _ = db.command    db.collection('qcl').where(_.or([{        name: db.RegExp({          regexp: '.*' + key,          options: 'i',        })      },      {        address: db.RegExp({          regexp: '.*' + key,          options: 'i',        })      }    ])).get({      success: res => {        console.log(res)      },      fail: err => {        console.log(err)      }    })key就是我们要搜索的关键字。主要是用到了数据库查询的where,or,get方法。 代码都给大家贴出来来，如果对云开发和云数据库还不是很了解的同学可以去翻看下我以前写的文章。" } { "title": "用云开发制作教务助手小程序丨实战 ", "author": "Rolan", "pub_time": "2019-12-4 00:02", "content": "本项目由一人承担从后端到前端的构思以及开发，下面我就讲讲从教务助手小程序的构思到开发实现（基于云开发）。1、灵感来源教务小程序的灵感来源：用完即走，查个成绩和课表，无需下载app或去翻看公众号内的历史内容。加上本人很久以前就想实现开发一个类似的app，但app的开发对于开发小白不太友好，不知从何下手！幸好 小程序·云开发 的出现解决了我的需求，它的低入门门槛和免后端运维等优势让非科班出身的我也能快速动手开发一款应用类小程序。2、构思教务小程序需要核心就是： 成绩查询、课表查询、教务通知查询 ！ 那么问题来了，学校教务处只有网页版，教务小程序数据从何而来呢？ 经过一系列思考，百度各种问题，思路就来了：后端模拟登陆——拿到页面数据——整理数据——反馈到小程序前端渲染大概结构如下：▌项目开发1、后端后端的实现 完全基于云开发 。 部分目录：采用云开发后端node.js语言，主要利用模块有：Router模块：const cloud = require('tcb-admin-node');\r\n//   npm  install tcb-router\r\nconst TcbRouter = require('tcb-router');\r\ncloud.init({\r\n  env: '//'\r\n})\r\nconst db = cloud.database();\r\nconst _ = db.command;\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const app = new TcbRouter({ event });\r\n  /** 教务处登陆 eg*/\r\n  app.router('login', async (ctx, next) => {\r\n    const test = require('login/login.js');\r\n    ctx.body = test.main(event, context);\r\n  });\r\n  /**查取成绩*/\r\n  app.router('getpoint', async (ctx, next) => {\r\n    const logList = require('getpoint/index.js');\r\n    ctx.body = logList.main(event, context);\r\n  });\r\n  /**学术活动*/\r\n  app.router('academic', async (ctx, next) => {\r\n    const userList = require('schoolnews/academic.js');\r\n    ctx.body = userList.main(event, context);\r\n  });\r\n  app.router('xsxx', async (ctx, next) => {\r\n    const userList = require('schoolnews/xsxx.js');\r\n    ctx.body = userList.main(event, context);\r\n  });\r\n  return app.serve();\r\n}\r\n复制代码Cherrio实现课表成绩等网页解析：const cloud = require('tcb-admin-node')\r\nconst rp = require('request-promise');\r\nvar cheerio = require(\"cheerio\");\r\ncloud.init()\r\nmodule.exports = {\r\n  main: async (event, context) => {\r\n    var url ='URL'\r\n    var res = await rp({method: 'get',uri: url,json: false}).then((body) => {\r\n      var academic = [];\r\n      var $ = cheerio.load(body);\r\n      $('.fl').find('dl').each(function (i, elem) {\r\n        //业务代码未写\r\n        /**\r\n          **/\r\n        academic.push({date: date,time:time,title:title,speaker:speaker,place:place,link:link})\r\n      });\r\n      return academic\r\n    }).catch(err => {\r\n      return err;\r\n    })\r\n    return res\r\n  }\r\n}\r\n复制代码数据库access_token定时修改// 云函数入口文件\r\nconst cloud = require('wx-server-sdk'),rp = require('request-promise'),key=require('key.js')\r\ncloud.init({\r\n  env: \"//\"\r\n})\r\n//指定数据库环境\r\nconst db = cloud.database({\r\n  env: \"//\"\r\n}), _ = db.command;\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  try { \r\n    var res = await rp(\r\n      {\r\n        method: 'get',\r\n        uri: 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=' + key.APPID + '&secret=' + key.APPSECRET,\r\n        qs: {},//参数\r\n        headers: {},//请求头\r\n        json: true  //是否json数据\r\n      }\r\n    ).then((body) => {\r\n      return body\r\n    }).catch(err => {\r\n      return {errmsg:\"rp函数获取失败\"}\r\n    })\r\n/*将获取的access_token存到数据库*/\r\n    console.log(res)\r\n    if (res.hasOwnProperty('access_token')) {\r\n      await db.collection('key').where({\r\n        type: \"accesstoken\"\r\n      }).update({\r\n        data: {\r\n          accesstoken: res.access_token,\r\n          datearray: _.unshift(new Date(new Date().getTime())),\r\n          num: _.inc(1)\r\n        }\r\n      })\r\n    } else {\r\n      console.log(\"err错误\" + res)\r\n    }\r\n  } catch (err) {\r\n    console.log(err)\r\n  } \r\n  \r\n}\r\n复制代码此外还借助了其他模块实现登陆、数据处理（课表等数据格式化）、云开发数据库操作（用户信息储存，消息发布）、用户权限鉴定（确保后台信息安全）等，在此就不赘述。2、前端小白就是“简单粗暴”的进行各种if、var操作；部分详细介绍如下：① 课程表：实现了一键导入（其实课程表这一功能可以单独形成一个通用的小程序上线），每天一卡片形式在首页提醒：今天有什么课，上完没有？②主题全局替换：支持自定义主题色，给用户自定义能力。③校历：利用了插件【极点日历】再加以美化。▌感悟一个从小白到从后端到前端到UI全部自己写的入门者参赛的心路历程就这么多了，目前源码暂不开放，对本小程序有疑问与建议均可在留言，同时希望大家能够利用好小程序实现自己的想法和创意！源码地址github.com/TencentClou…如果你想要了解更多关于云开发CloudBase相关的技术故事/技术实战经验，请扫码关注【腾讯云云开发】公众号～" } { "title": "小程序同构方案 kbone 分析与适配 ", "author": "Rolan", "pub_time": "2019-12-4 00:23", "content": "在微信小程序的开发的过程中，我们会存在小程序和 H5 页面共存的场景，而让小程序原生和 web h5 独立开发，往往会遇到需要两套人力去维护。对开发者而言，加大了工作量成本，对于产品而言，容易出现展示形态同步不及时问题。在这种情况下，我们急需要找到一个既能平衡性能，也能满足快速迭代的方案。主流的小程序同构方案web-view 组件webview 组件是一个承载网页的容器，最简单的方案就是使用原 h5 的代码，通过 web-view 组件进行展示。其优点是业务逻辑无需额外开发与适配，只需要处理小程序特有的逻辑，然后通过 jssdk 与原生小程序通讯。使用 webview 加载 h5 的问题也非常明显，首先是体验问题，用户见到页面会经过以下环节：加载小程序包，初始化小程序，再加载 webview 中的 html 页面，然后加载相关资源，渲染 h5 页面，最后进行展示。最终导致的结果是打开体验非常差。另外其他缺点是小程序对 web-view 部分特性有限制，比如组件会自动铺满整个小程序页面，不支持自定义导航效果等。静态编译兼容静态编译是最为主流的小程序同构方案，类似的有 taro, mpvue 等。其思路是在构建打包过程，把一种结构化语言，转换成另一种结构化语言。比如，taro 把 jsx 在构建时进行词法分析，解析代码获取 AST，然后将 AST 递归遍历生成 wxml 目标代码。静态编译的好处是非常明显，一套代码，通过编译分别转 h5 和小程序，兼具性能与跨平台。另一方面，随着这种方案的流行，大家也感受到了其明显的问题，首先，由于小程序本身的限制，比如无法 dom 操作，js 与 webview 双线程通信等，导致静态编译语法转换，不能做到彻底的兼容，开发体验受制于框架本身的支持程度，相信踩过坑的同学应该非常有痛的感悟。其次，静态编译转换逻辑需要与小程序最新的特性保持同步，不断升级。小程序运行时兼容方案静态编译的方案实现了同构，但它只是以一种中间态的结构化语法去编码，非真正的 web，牺牲了大量的灵活性。另外一种更灵活的方案，运行时兼容应值得去尝试。小程序原理我们回到小程序本身的限制上来。由于小程序采用双线程机制，内部通过一个 webview 用于承载页面渲染，但小程序屏蔽了它原本的 DOM/BOM 接口，自己定义了一套组件规范；另一方面，使用独立的 js-core 负责对 javascript 代码进行解析，让页面和 js-core 之间进行相互通信（setData），从而达到执行与渲染的分离。而浏览器的 DOM 接口是大量 web 得以显示的底层依赖，这也是 h5 代码无法直接在小程序中运行的主要原因。那么如何突破小程序对接口 DOM 的屏蔽呢？ 最直接的思路就是用 JS 实现和仿造一层浏览器环境的 DOM 相关的标准接口，让用户的 JS 代码可以无感知的自由操作 DOM。通过仿造的底层 DOM 接口，web 代码执行完后，最终生成一层仿造的 DOM 树，然后讲这棵 DOM 树转换成小程序的 wxml 构成的 DOM 树，最后由小程序原生去负责正确的渲染出来。kbonekbone 是微信官方出一套小程序运行时兼容方案，目前已经接入的小程序有小程序官方社区，及腾讯课堂新人礼包等。并且有专人维护，反馈及时。kbone 方案核心主要有两大模块，第一是 miniprogram-render 实现了对浏览器环境下 dom/bom 的仿造，构建 dom 树，及模拟 web 事件机制。第二个模块是 miniprogram-element 是原生小程序渲染入口，主要监听仿造 dom 树的变化，生成对应的小程序的 dom 树，另外一个功能是监听原生小程序事件，派发到仿造的事件中心处理。DOM/BOM 仿造层DOM、BOM 相关的接口模拟，主要是按照 web 标准构建 widow、document、node 节点等相关 api，思路比较清晰，我们简单看下其流程。首先在用户层有一个配置文件 miniprogram.config，里面有必要信息 origin、entry 等需要配置。在 miniprogram-render 的入口文件 createPage 方法中，配置会初始化到一个全局 cache 对象中，然后根据配置初始化 Window 和 Document 这两个重要的对象。Location、Navigator、Screen、History 等 BOM 实例都是在 window 初始化过程中完成。DOM 节点相关 api 都是在 Document 类中初始化。所有生成的节点和对象都会通过全局的 pageMap 管理，在各个流程中都能获取到。小程序渲染层miniprogram-element 负责监听仿造 DOM 仿造的变化，然后生成对应小程序组件。由于小程序中提供的组件和 web 标准并不完全一样，而我们通过 html 生成的 dom 树结构千差万别，如和保证任意的 html dom 树可以映射到小程序渲染的 dom 树上呢？kbone 通过小程序自定义组件去做了这件事情。简单说下什么是自定义组件，既将特定的代码抽象成一个模块，可以组装和复用。以 react 为例，div、span 等标签是原生组件，通过 react.Component 将 div 和 span 组合成一个特定的 react 组件，在小程序中用自带的 view、image 等标签通过 Component 写法就能组合成小程序自定义组件。和大部分 web 框架的自定义组件类似，小程序自定义组件也能够自己递归地调用自己，通过将伪造的 dom 结构数据传给自定义组件作为子组件，然后再递归的调用，直到没有子节点为止，这样就完成了一个小程序 dom 树的生成。性能问题多层 dom 组合大量小程序自定义组件会有额外的性能损耗，kbone 在实现时提供了一些优化。其中最基本的一个优化是将多层小程序原生标签作为一个自定义组件。dom 子树作为自定义组件渲染的层级数是可以通过配置传入，理论上层级越多，使用自定义组件数量越少，性能也就越好。以上逻辑就是通过 DOM_SUB_TREE_LEVEL 层级数对节点过滤，更新后，检测是否还有节点，再触发更新。节点缓存在页面 onUnload 卸载的过程中，kbone 会将当前节点放入缓存池中，方便下次初始化的时候优先从缓存中读取。kbone 接入与适配kbone 作为一种运行时兼容方案，适配成本相对于静态编译方案而言会低很多，总体来说对原代码侵入性非常少，目前接入过程比较顺利（期间遇到的坑，感谢 作者 june 第一时间帮忙更新发布 [玫瑰]）svg 资源适配小程序不支持 svg，对于使用 svg 标签作为图片资源的应用而言，需要从底层适配。在一开始我们想到的方案有通过 肝王的 cax 进行兼容，但评估后不太靠谱，cax 通过 解析 svg 绘制成 canvas，大量 icon 会面临比较严重的性能问题。那么最直接暴力的办法就是使用 webpack 构建过程直接把 svg 转 png？后面一位给力的小伙伴想到通过把 svg 标签转成 Data URI 作为背景图显示，最终实践验证非常可靠，具体可以参考 kbone svg 适配。网络层适配/cookie微信小程序环境拥有自己定义的一套 wx.request API， web 中的 XMLHttpRequest 对象是无法直接使用。由于我们代码中使用了 axios，所以在预言阶段直接简单通过 axios-miniprogram-adapter 进行适配器，后面发现部分业务没有使用 axios，兼容并不够彻底。于是直接从底层构建了一个 XMLHttpRequest 模块，将 web 网络请求适配到 wx.request。同时做了 cookie 的自动存取逻辑适配（小程序网络请求默认不带 cookie）。这一层等完善好了看是否能 pull request 到 kbone 代码仓库中。差异性 DOM/BOM API 适配部分 web 中的接口在小程序无法完全获得模拟，比如 getBoundingClientRect 在小程序中只能通过异步的方式实现。类似的有 removeProperty、stopImmediatePropagation等接口在 kbone 中没有实现，performance 等 web 特有的全局变量的需要兼容。这些扩展 API 可以通过 kbone 对外暴露的 dom/bom 扩展 API 进行兼容。getBoundingClientRect对于元素的的高度 height \\offsetHeight 获取，我们只能通过 $getBoundingClientRect 异步接口，如果是 body scroll-view 实现的，getBoundingClientRect 返回的是 scrollHeight。滚动web 的全局滚动事件默认是无法触发，需要通过配置 windowScroll 来监听，启用这个特性会影响性能。global: {\r\n    windowScroll: true\r\n},\r\n样式适配标签选择器kbone 样式有一个坑，就是它会将标签选择器转换成类选择器去适配小程序环境，比如span { } =>  .h5-span{  }\r\n这样带来的副作用就是选择器的权重会被自动提升，对选择器权重依赖的标签样式需要去手动调整兼容。其他适配点注意使用标准的 style 属性，比如有 webkit-transform 会不支持，及小程序样式和 web 差异性兼容等。  style: {\r\n      'WebkitTransform': 'translate(' + x + 'px, 0)' // 正确\r\n     // '-webkit-transform': 'translate(' + x + 'px, 0)' 报错\r\n  }\r\n路由适配在初始化路由阶段，曾经遇到过 Redux 更新 dom 后偶现节点销毁，最终定位到是 kbone 对 Location 等 BOM 实例化过晚，最终在 june 帮忙及时调整了顺序，更新了一个版本，现最新本所有 BOM 对象会在业务执行前准备好。//初始化dom\r\nthis.window.$$miniprogram.init()\r\n...\r\n//初始化业务\r\ninit(this.window, this.document)\r\n隐式全局变量兼容在模拟 XMLHttpRequest 模块的过程中遇到一个问题，什么时候初始化这个对象，我们可以选择在网络请求库初始化前引入它，挂载在仿造的 window 对象下。但仍然会出现一个问题，第三放库直接使用的是 XMLHttpRequest 对象，而非通过 window 访问。var request = new XMLHttpRequest() // 报错\r\n \r\nvar request = new window.XMLHttpRequest() // 正确\r\n在正常的 web 环境，window 是默认的顶层作用域，而小程序中隐式的使用 window 对象则会报错。为了解决这一问题，可以通过配置文件的 globalVars 字段，将 XMLHttpRequest 直接进行定义。 globalVars: [\r\n    ['XMLHttpRequest', 'require(\"libs/xmlhttprequest.js\")']\r\n]\r\n构建的过程中会在所有依赖前转成如下代码 ： var XMLHttpRequest = require(\"libs/xmlhttprequest.js\")\r\n这样做解决了隐式访问 window 作用域问题。但又面临另一个问题，那就是 xmlhttprequest 模块本身内部由依赖仿造 window 对象，比如 cookie 访问，而此时因为 require 的模块独立的作用域无法访问到其他模块的仿造 window 对象。于是最终通过导入一个 function 传入 window 作用域，然后初始化 xmlhttprequest。  globalVars: [\r\n      ['XMLHttpRequest', 'require(\"libs/xmlhttprequest.js\").init(window, document)']\r\n]\r\n多端构建小程序和 web 端需要的资源及部分逻辑是有差异，通过 webpck 配置进行差异化处理，具体可以参考文档编写 kbone webpack 配置。大概是这样的区分跨端配置：分离打包入口文件:小程序打包入口依赖的 dom 节点，需要主动创建。详细示例参照官方 demo.export default function createApp() {\r\n    initialize(function() {\r\n        let Root = require('./root/index').default;\r\n \r\n        const container = document.createElement('div')\r\n        container.id = 'pages';\r\n        document.body.appendChild(container);\r\n        render(<Root />, container)\r\n    })\r\n}\r\n由于小程序本身是没有真正 userAgent，kbone 内部是是根据当前环境进行仿造。//miniprogram-render/src/bom/navigator#45\r\nthis.$_userAgent = `${this.appCodeName}/${appVersion} (${platformContext}) AppleWebKit/${appleWebKitVersion} (KHTML, like Gecko) Mobile MicroMessenger/${this.$_wxVersion} Language/${this.language}`\r\n在业务中有需要区分小程序平台的场景，我们可以通过 webpack DefinePlugin 插件进行注入，然后通过定义变量进行判断。if (!process.env.isWxMiniProgram) {\r\n    render(\r\n        <Root />,\r\n        document.getElementById('pages')\r\n    );\r\n}\r\n小程序分包在腾讯文档的小程序中，有一个独立的小程序仓库。 而文档管理列表是另外一个独立的 H5 项目，嵌入到小程序 webview 动态加载。通过 kbone 转原生打包后，这部分代码需要继承到小程序仓库中。首先我们可以通过脚本，在 webpack 构建过程，将 kbone 编译后的包 copy 到独立小程序仓库的目录下，合并小程序相关配置，从而实现功能合并。这样遇到的一个问题是主包大小超过限制，通过小程序分包我们可以解决这个问题，将原小程序非首屏页面全部放分包之中，配置 preloadRule 字段再预加载分包。\"subpackages\": [\r\n    {\r\n      \"root\": \"packageA\",\r\n      \"pages\": [\r\n        \"pages/cat\"      ]\r\n    }\r\n  ]\r\n  \"preloadRule\": {\r\n    \"pages/index\": {\r\n      \"network\": \"all\",\r\n      \"packages\": [\"important\"]\r\n    }  \r\n}\r\n结通过对目前各种小程序同构方案的对比与实践，kbone 是一种非常值得推荐的新思路，新方法，兼具性能与灵活。唯一不足的地方就是目前仍有不少底层工作需要适配，更多的问题在继续探索中，相信随着不断迭代及采坑后的反馈，kbone 会变得越来稳定和成熟" } { "title": "京喜首页（微信购物入口）跨端开发与优化实践 ", "author": "Rolan", "pub_time": "2019-12-4 00:45", "content": "随着今年的双十一落下帷幕，京喜（原京东拼购）也迎来了首捷。双十一前夕微信购物一级入口切换为京喜小程序，项目顺利通过近亿级的流量考验，在此与大家分享一点自己参与的工作。在接手项目前，京喜业务已在线上稳定运行较长时间。但经过一段时间迭代维护后，发现首页存在以下问题：H5 版本首页针对不同渠道开发了多套页面，对开发者维护和内容运营来说存在较大挑战，需投入大量人力成本；项目技术栈不统一，分别有传统 H5 开发、原生小程序开发、wqVue 框架开发，严重影响项目复杂度，迭代过程苦不堪言；H5、小程序以及 RN 三端存在各自构建和发布流程，涉及较多工具及复杂系统流程，影响业务交付效率。综上所述，京喜迎来一次改版契机。改版目标从前端角度来看，本次改版要实现以下目标：升级并统一项目技术栈，解决项目技术栈混乱的现状；使用一套代码，适配微信入口、手 Q 入口、微信小程序、京东 APP、京喜 APP、M 站六大业务场景，减少多套页面的维护成本，提升交付效率；通过让 RN 技术在业务上的落地，完善团队在 App 端的技术储备；优化页面性能及体验，为下沉市场用户提供优质的产品体验；技术选型京喜业务拥有非常丰富的产品形态，涵盖了 H5、微信小程序以及独立 APP 三种不同的端，对支持多端的开发框架有着天然的需求。在技术选型上，我们选择团队自研的 Taro 多端统一开发解决方案。Taro 是一套遵循 React 语法规范的多端开发解决方案。现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ 小程序、快应用、H5、React-Native 等）运行的代码。选它有两个原因，一来是 Taro 已经成熟，内部和外部都有大量实践，内部有京东 7FRESH、京东到家等，外部有淘票票、猫眼试用等多个案例，可以放心投入到业务开发；二来团队成员都拥有使用 Taro 来开发内部组件库的经验，对业务快速完成有保障。开发实录由于首页改版的开发排期并不充裕，因此充分地复用已有基础能力（比如像请求、上报、跳转等必不可少的公共类库），能大量减少我们重复的工作量。话虽如此，但在三端统一开发过程中，我们仍遇到不少问题同时也带来解决方案，以下我们一一阐述。H5 篇我们所有的页面都依赖现有业务的全局公共头尾及搜索栏等组件，这就不可避免的需要将 Taro 开发流程融入到现有开发和发布流程中去。同时公共组件都是通过 SSI 的方式引入和维护的，为了能在运行 npm run dev:h5 时预览到完整的页面效果，需要对 index.html 模版中的 SSI 语法进行解析， index.html 模版文件代码结构大致如下：<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover\">\r\n  <title>京喜</title>\r\n  <!--#include virtual=\"/sinclude/common/head_inc.shtml\"-->\r\n</head>\r\n<body>\r\n  <div id=\"m_common_header\" style=\"display:none;\"></div>\r\n  <!--S 搜索框-->\r\n  <div id=\"search_block\" class=\"search_block\"></div>\r\n  <div id=\"smartboxBlock\" style=\"display:none;\"></div>\r\n  <!--E 搜索框-->\r\n  <div id=\"app\" class=\"wx_wrap\"></div>\r\n  <!--#include virtual=\"/sinclude/common/foot.shtml\"-->\r\n</body>\r\n</html>\r\n复制代码可以看到模版中存在很多类似 <!--#include virtual=\"...\" --> 格式的代码，这些就是通过 SSI 方式引入的 H5 公共组件，它的 virtual 属性指向的文件不存在于本地而是存在于服务器上的，所以我们遇到的第一个问题就是在本地解析这些文件，确保能预览到完整的页面效果，不然开发调试起来就非常的低效。好在 Taro 有暴露出 webpack 的配置，我们可以通过引入自定义加载器（这里就叫 ssi-loader ）来解析这些代码的路径，然后请求服务器上的文件内容并进行替换即可，要实现这个功能只需在项目的 config/dev.js 中加入如下代码即可：module.exports = {\r\n  h5: {\r\n    webpackChain(chain, webpack) {\r\n      chain.merge({\r\n        module: {\r\n          rule: {\r\n            ssiLoader: {\r\n              test: /\\.html/,\r\n              use: [\r\n                {\r\n                  loader: 'html-loader'\r\n                },\r\n                {\r\n                  loader: 'ssi-loader',\r\n                  options: {\r\n                    locations: {\r\n                      include: 'https://wqs.jd.com'\r\n                    }\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          }\r\n        }\r\n      })\r\n    }\r\n  }\r\n}\r\n复制代码这样就解决了本地开发调试难点，然后开开心心的进行页面开发。当页面开发完成之后，接下来遇到的问题就是如何将前端资源部署到测试和生产环境。由于现有开发和发布流程都是基于内部已有的平台，我们临时定制一套也不太现实，所以需要将它融入到 Taro 的流程中去，这里我们引入了 gulp 来整合各种构建和发布等操作，只要构建出符合发布平台规范的目录即可利用它的静态资源构建、版本控制及服务器发布等能力，这样我们就打通了整个开发和发布流程。这套拼凑起来的流程还存在不少的问题，对于新接手的同学有一点小繁琐，有着不少改善的空间，这也是接下来的重点工作方向。另外 Taro 的 H5 端之前是基于 SPA 模式，对于有着多页开发需求的项目来说不太友好，当时反馈给 Taro 团队负责 H5 的同学，很快得到了响应，目前 Taro 已支持 H5 多页开发模式，支持非常迅速。小程序篇由于开发完 H5 版之后，对应的业务逻辑就已经处理完了，接下来只需要处理小程序下的一些特殊逻辑（比如分享、前端测速上报等）即可，差异比较大的就是开发和发布流程。这里讲一下如何在一个原生小程序项目中使用 Taro 进行开发，因为我们的 Taro 项目跟已有的原生小程序项目是独立的两个项目，所以需要将 Taro 项目的小程序代码编译到已有的原生小程序项目目录下，第一步要做的就是调整 Taro 配置 config/index.js ，指定编译输出目录以及禁用 app 文件输出防止覆盖已有文件。const config = {\r\n  // 自定义输出根目录\r\n  outputRoot: process.argv[3] === 'weapp' ? '../.temp' : 'dist',\r\n  // 不输出 app.js 和 app.json 文件\r\n  weapp: {\r\n    appOutput: false\r\n  }\r\n}\r\n复制代码由于京喜以前是主购小程序的一个栏目，后面独立成了独立的小程序，但是核心购物流程还是复用的主购小程序，所以这让情况变得更加复杂。这里还是通过 gulp 来进行繁琐的目录文件处理，比如我们的小程序页面和组件都需要继承主购小程序的 JDPage 和 JDComponent 基类，所以在进行文件复制之前需要进行代码替换，代码如下：// WEAPP\r\nconst basePath = `../.temp`\r\nconst destPaths = [`${basePath}/pages/index/`, `${basePath}/pages/components/`]\r\nconst destFiles = destPaths.map(item => `${item}**/*.js`)\r\n\r\n/*\r\n * 基类替换\r\n */\r\nfunction replaceBaseComponent (files) {\r\n  return (\r\n    gulp\r\n      .src(files || destFiles, { base: basePath })\r\n      .pipe(\r\n        replace(\r\n          /\\b(Page|Component)(\\(require\\(['\"](.*? \"'\"\")\\/npm\\/)(.*)(createComponent.*)/,\r\n          function(match, p1, p2, p3, p4, p5) {\r\n            const type =\r\n              (p5 || '').indexOf('true') != -1 ||\r\n              (p5 || '').indexOf('!0') != -1\r\n                ? 'Page'\r\n                : 'Component'\r\n            if (type == 'Page') p5 = p5.replace('))', '), true)') // 新：page.js基类要多传一个参数\r\n            const reservedParts = p2 + p4 + p5\r\n            // const type = p1\r\n            // const reservedParts = p2\r\n            const rootPath = p3\r\n\r\n            const clsName = type == 'Page' ? 'JDPage' : 'JDComponent'\r\n            const baseFile = type == 'Page' ? 'page.taro.js' : 'component.js'\r\n\r\n            console.log(\r\n              `:full_moon_with_face: Replace with \\`${clsName}\\` successfully: ${this.file.path.replace(\r\n                /.*?wxapp\\//,\r\n                'wxapp/'\r\n              )}`\r\n            )\r\n            return `new (require(\"${rootPath}/bases/${baseFile}\").${clsName})${reservedParts}`\r\n          }\r\n        )\r\n      )\r\n      .pipe(gulp.dest(basePath))\r\n  )\r\n}\r\n\r\n// 基类替换\r\ngulp.task('replace-base-component', () => replaceBaseComponent())\r\n复制代码还有很多类似这样的骚操作，虽然比较麻烦，但是只需要处理一次，后续也很少改动。RN 篇对于 RN 开发，也是第一次将它落地到实际的业务项目中，所以大部分时候都是伴随着各种未知的坑不断前行，所以这里也友情提示一下，对于从未使用过的技术，还是需要一些耐心的，遇到问题勤查勤问。由于京喜 APP 是复用京东技术中台的基础框架和 JDReact 引擎，所以整个的开发和部署都是遵循 JDReact 已有的流程，画了一张大致的流程图如下：JDReact 平台是在 Facebook ReactNative 开源框架基础上，进行了深度二次开发和功能扩展。不仅打通了 Android/iOS/Web 三端平台，而且对京东移动端基础业务能力进行了 SDK 级别的封装，提供了统一、易于开发的 API。业务开发者可以通过 JDReact SDK 平台进行快速京东业务开发，并且不依赖发版就能无缝集成到客户端(android/iOS)或者转换成 Web 页面进行线上部署，真正实现了一次开发，快速部署三端。由于京喜 APP 的 JDReact 模块都是独立的 git 仓库，所以需要调整我们 Taro 项目配置 config/index.js 的编译输出路径如下：rn: {\r\n  outPath: '../jdreact-jsbundle-jdreactpingouindex'\r\n}\r\n复制代码这样，当我们运行 yarn run dev:rn 进行本地开发时，文件自动编译到了 JDReact 项目，接下来我们就可以用模拟器或者真机来进行预览调试了。当我们在进行本地开发调试的时候，最高效的方式还是推荐用 Taro 官方提供的 taro-native-shell 原生 React Native 壳子来启动我们的项目，详细的配置参照该项目的 README 进行配置即可。由于 React Native 官方提供的 Remote Debugger 功能非常弱，推荐使用 React Native Debugger 来进行本地 RN 调试，提供了更为丰富的功能，基本接近 H5 和小程序的调试体验。这样我们就拥有了一个正常的开发调试环境，接下来就可以进行高效的开发了，由于我们前面在 H5 和小程序版本阶段已经完成了绝大部分的业务逻辑开发，所以针对 RN 版本的主要工作集中在 iOS 和安卓不同机型的样式和交互适配上。在样式适配这块，不得不提下 Taro 针对我们常见的场景提供了一些最佳实践，可以作为布局参考：Image\r\nflex\r\nscalePx2dp\r\nTaro RN 最佳实践集锦在实际开发过程中也遇到不少兼容性问题，这里整理出来以供大家参考：文本要用 <Text> 标签包起来，因为 RN 没有 textNode 的概念；使用 Swiper 时在外面包一个 View，否则设置 margin 后会导致安卓下高度异常；Cannot read property 'x' of undefined ，Swiper 底层使用的 react-native-swiper 导致的问题，Disable Remote JS Debug 就不会出现。图片默认尺寸不对，RN 不会自动帮助设置图片尺寸，而是交给开发者自己处理，故意这样设计的；Image 组件上不可以设置 onClick实现基线对齐： vertical-align: baseline ，用 <Text> 把需要基线对齐的组件包住即可。<Text>\r\n  <Text style={{ fontSize: 20 }}>abc</Text>\r\n  <Text style={{ fontSize: 40 }}>123</Text>\r\n</Text>\r\n复制代码尽量避免使用 line-height ，在安卓和 iOS 下表现不一致，而且即使设置为与 fontSize 相同也会导致裁剪；android 调试生产环境的 bundle，摇手机，选 Dev Setting，取消勾选第一项 Dev 即可；iOS 调试生产环境的 bundle， AppDelegate.m 中增加一行语句关闭 dev 即可：[[RCTBundleURLProvider sharedSettings] setEnableDev:false];\r\n  // 找到这行，并在它的上面增加上面这行\r\n  jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index\" fallbackResource:nil];\r\n复制代码<Text> 与 <View> 支持的 style 属性不相同。> [Text Style Props](https://facebook.github.io/react-native/docs/text-style-props \"Text Style Props\") & [View Style Props](https://facebook.github.io/\r\n复制代码react-native/docs/view-style-props)render 方法中不要返回空字符串下面的代码在 android 下会报错（empty_string 内容为空字符串）<View>\r\n  {empty_string && <Text></Text>}\r\n</View>\r\n复制代码因为 empty_string && <Text></Text> 的返回值是空字符串，RN 尝试把字符串添加到 View 的 children 时在安卓环境下会报错：Error: Cannot add a child that doesn't have a YogaNode\r\n复制代码border-radius 导致背景色异常，单独给某个角设置圆角时，没有设置圆角的边会出现一块与背景色颜色相同，但半透明的色块。transform:tanslate()\r\n透明 View 无法点击的问题，给设置了 onClick 的元素添加透明背景色即可：style={{ backgroundColor: \"transparent\" }}\r\n复制代码不可以用 scss 写，只有写在 JSX 上的才有效，Taro 编译时可能把透明背景色忽略了。一像素缝隙问题可能是 RN 布局引擎的问题，或单位转换以及浏览器渲染中的精度损失问题。可以调整页面结构来绕过。 或者简单粗暴一点，设置负 margin 值盖住缝隙。跨平台开发JS 文件1、文件拆分的方式要\"完美\"的编译出三端代码，首先要解决的是公共类库的适配问题，好在兄弟业务团队已经沉淀有完成度较高的三端公共类库，利用 Taro 提供的跨平台开发能力，抹平三端方法名和参数不统一的情况，即可很好的解决公共类库的适配问题，如下所示：.\r\n├── goto.h5.js\r\n├── goto.rn.js\r\n├── goto.weapp.js\r\n├── request.h5.js\r\n├── request.rn.js\r\n├── request.weapp.js\r\n└── ...\r\n复制代码以 request 公共组件为例，三端代码如下：request.h5.jsimport request from '@legos/request'\r\nexport { request }\r\n复制代码request.rn.jsimport request from '@wqvue/jdreact-request'\r\nexport { request }\r\n复制代码request.weapp.js（由于小程序的公共组件没有发布至 npm，这里引用的本地项目源文件）import { request } from '../../../common/request/request.js'\r\nexport { request }\r\n复制代码如遇到需要适配的方法参数不一致或者增加额外处理的情况，可进行再包装确保最终输出的接口一致，如下：goto.rn.jsimport jump from '@wqvue/jdreact-jump'\r\n\r\nfunction goto(url, params = {}, options = {}) {\r\n  jump(url, options.des || 'm', options.source || 'JDPingou', params)\r\n}\r\n\r\nexport default goto\r\n复制代码文件引入的时候我们正常使用就好，Taro 在编译的时候为我们编译对应的平台的文件import goto from './goto.js'\r\n复制代码2、条件编译的方式解决了公共类库适配之后，接下来就可以专注于业务代码开发了，同样业务代码在三端也可能存差异的情况，可以用 Taro 提供的环境变量来达到目的，示例代码如下：if (process.env.TARO_ENV === 'h5') {\r\n  this.speedReport(8) // [测速上报] 首屏渲染完成\r\n} else if (process.env.TARO_ENV === 'weapp') {\r\n  speed.mark(6).report() // [测速上报] 首屏渲染完成\r\n} else if (process.env.TARO_ENV === 'rn') {\r\n  speed.mark(7).report() // [测速上报] 首屏渲染完成\r\n}\r\n复制代码CSS 文件以上是 js 的代码处理方式，对于 css 文件及代码，同样也有类似的处理。1、文件拆分的方式比如 RN 相对于 H5 和小程序的样式就存在比较大的差异，RN 支持的样式是 CSS 的子集，所以很多看起来很常见的样式是不支持的，可以通过以下方式进行差异化处理：├── index.base.scss\r\n├── index.rn.scss\r\n├── index.scss\r\n复制代码这里以 index.base.scss 作为三端都能兼容的公共样式（名字可以任取，不一定为 xxx.base.scss）， index.rn.scss 则为 RN 端独特的样式， index.scss 则为 H5 和小程序独特的样式，因为 H5 和小程序样式基本上没有什么差异，这里合为一个文件处理。2、条件编译的方式Taro 也支持样式文件内的条件编译，语法如下：/* #ifdef %PLATFORM% */\r\n// 指定平台保留\r\n/* #endif */\r\n\r\n/* #ifndef %PLATFORM% */\r\n// 指定平台剔除\r\n/* #endif */\r\n复制代码%PLATFORM% 的取值请参考 Taro 内置环境变量以下为示例代码：.selector {\r\n  color: #fff;\r\n  /* #ifndef RN */\r\n  box-shadow: 1px 1px 1px rgba(0, 0, 0, .1);\r\n  /* #endif */\r\n}\r\n复制代码编译为 H5 和小程序的样式为：.selector {\r\n  color: #fff;\r\n  box-shadow: 1px 1px 1px rgba(0, 0, 0, .1);\r\n}\r\n复制代码RN 的样式为：.selector {\r\n  color: #fff;\r\n}\r\n复制代码两种方式选其一即可，这样就能开开心心的编写业务代码了。有些许遗憾的是产品经理对这次新版首页有着明确的上线优先级：先 H5 版，再微信小程序版，最后是 RN 版，这就为后续 RN 版本跟 H5 和 小程序版本分道扬镳埋下了伏笔，条件允许的话建议优先以 RN 版本为基准进行开发，以免开发完成 H5 和小程序之后发现对结构和样式进行大的调整，因为 RN 对样式确实会弱一些。性能优化图片优化电商性质的网站，会存在大量的素材或商品图片， 往往这些会对页面造成较大的性能影响。得益于京东图床服务，提供强大的图片定制功能，让我们在图片优化方面省去大量工作。以引入商品图片 \"https://img10.360buyimg.com/mobilecms/s355x355_jfs/t1/55430/24/116/143859/5cd27c99E71cc323f/0e8da8810fb49796.jpg!q70.dpg.webp\" 为样本，我们对图片应用做了部分优化：根据容器大小适当裁剪图片尺寸：s355x355_jfs根据网络环境设置图片品质参数：0e8da8810fb49796.jpg!q70根据浏览器环境合理选择图片类型：0e8da8810fb49796.jpg!q70.dpg.webp为 Image 标签设置 lazyload 属性，这样可以在 H5 和小程序下获得懒加载功能。接口聚合直出起初京喜首页的首屏数据涉及的后端接口多达 20 余个，导致整体数据返回时间较长；为了解决此项痛点，我们联合后端团队，独立开发首屏专用的 聚合直出接口 。一方面，将众多接口请求合并成一个，减少接口联动请求带来的性能损耗；另一方面，将复杂的业务逻辑挪到后端处理，前端只负责视图渲染和交互即可，减少前端代码复杂度；通过此项优化，页面性能和体验得到极大改善。缓存优先策略由于京喜业务主要围绕下沉市场，其用户群体的网络环境会更加复杂，要保障页面的性能，减少网络延时是一项重要措施。为了提升用户二次访问的加载性能，我们决定采用 缓存优先策略 。即用户每次访问页面时所请求的主接口数据写入本地缓存，同时用户每次访问都优先加载缓存数据，形成一套规范的数据读取机制。通过优先读取本地缓存数据，可让页面内容在极短时间内完成渲染；另外，本地缓存数据亦可作为页面兜底数据，在用户网络超时或故障时使用，可避免页面空窗的情景出现。高性能瀑布流长列表首页紧接着首屏区域的是一个支持下滑加载的瀑布流长列表，每次滑到底部都会异步拉取 20 条数据，总计会拉取将近 500 条数据，这在 iOS 下交互体验还比较正常。但是在配置较低的安卓机型下，当滑动到 2 到 3 屏之后就开始出现严重卡顿，甚至会闪退。针对这种场景也尝试过用 FlatList 和 SectionList 组件来优化，但是它们都要求规则等高的列表条目，于是不得不自己来实现不规则的瀑布流无限滚动加载。其核心思路是通过判断列表的条目是否在视窗内来决定图片是否渲染，要优化得更彻底些得话，甚至可以移除条目内所有内容只保留容器，以达到减少内容节点以及内存占用，不过在快速进行滑动时比较容易出现一片白框，算是为了性能损失一些体验，整体上来说是可以接受得。由于 RN 下在获取元素坐标偏移等数据相对 H5 和小程序要麻烦得到，具体的实现细节可以查看抽离出来的简单实现 Taro 高性能瀑布流组件（for RN） 。写在最后这篇文章从技术选型、开发实录再到性能优化三个维度对京喜首页改版做了简单总结。整个项目实践下来，证实 Taro 开发框架 已完全具备投入大型商业项目的条件。虽在多端开发适配上耗费了一些时间，但仍比各端独立开发维护工作量要少；在前端资源匮乏的今天，选择成熟的开发工具来控制成本、提升效率，已是各团队的首要工作目标。 同时，京喜作为京东战略级业务，拥有千万级别的流量入口，我们对页面的体验优化和性能改进远不止于此，希望每一次微小的改动能为用户带来愉悦的感受，始终为用户提供优质的产品体验。欢迎关注凹凸实验室博客： aotu.io" } { "title": "小程序解析excel表格并存储到云数据库 ", "author": "Rolan", "pub_time": "2019-12-4 00:52", "content": "最近一直比较忙，答应大家的小程序解析excel一直没有写出来，今天终于忙里偷闲，有机会把这篇文章写出来给大家了。老规矩先看效果图效果其实很简单，就是把excel里的数据解析出来，然后存到云数据库里。说起来很简单。但是真的做起来的时候，发现其中要用到的东西还是很多的。不信。。。。 那来看下流程图流程图通过流程图，我看看到我们这里使用了云函数，云存储，云数据库。 流程图主要实现下面几个步骤1，使用wx.chooseMessageFile选择要解析的excel表格 2，通过wx.cloud.uploadFile上传excel文件到云存储 3，云存储返回一个fileid 给我们 4，定义一个excel云函数 5，把第3步返回的fileid传递给excel云函数 6，在excel云函数里解析excel，并把数据添加到云数据库。 可以看到最神秘，最重要的就是我们的excel云函数。 所以我们先把前5步实现了，后面重点讲解下我们的excel云函数。一，选择并上传excel表格文件到云存储这里我们使用到了云开发，使用云开发必须要先注册一个小程序，并给自己的小程序开通云开发功能。这个知识点我讲过很多遍了，还不知道怎么开通并使用云开发的同学，去翻下我前面的文章，或者看下我录的讲解视频《5小时入门小程序云开发》1，先定义我们的页面 页面很简单，就是一个按钮如下图，点击按钮时调用chooseExcel方法，选择excel对应的wxml代码如下2，编写文件选择和文件上传方法上图的chooseExcel就是我们的excel文件选择方法。 uploadExcel就是我们的文件上传方法，上传成功以后会返回一个fildID。我们把fildID传递给我们的jiexi方法，jiexi方法如下3 把fildID传递给云函数二，解下来就是定义我们的云函数了。1，首先我们要新建云函数如果你还不知道如何新建云函数，可以翻看下我之前写的文章，也可以看我录的视频《5小时入门小程序云开发》 如下图所示的excel就是我们创建的云函数2，安装node-xlsx依赖库如上图所示，右键excel，然后点击在终端中打开。 打开终端后， 输入 npm install node-xlsx 安装依赖。可以看到下图安装中的进度条这一步需要你电脑上安装过node.js并配置npm命令。 3，安装node-xlsx依赖库完成三，编写云函数我把完整的代码贴出来给大家const cloud = require('wx-server-sdk')cloud.init()var xlsx = require('node-xlsx');const db = cloud.database()exports.main = async(event, context) => {  let {    fileID  } = event  //1,通过fileID下载云存储里的excel文件  const res = await cloud.downloadFile({    fileID: fileID,  })  const buffer = res.fileContent  const tasks = [] //用来存储所有的添加数据操作  //2,解析excel文件里的数据  var sheets = xlsx.parse(buffer); //获取到所有sheets  sheets.forEach(function(sheet) {    console.log(sheet['name']);    for (var rowId in sheet['data']) {      console.log(rowId);      var row = sheet['data'][rowId]; //第几行数据      if (rowId > 0 && row) { //第一行是表格标题，所有我们要从第2行开始读        //3，把解析到的数据存到excelList数据表里        const promise = db.collection('users')          .add({            data: {              name: row[0], //姓名              age: row[1], //年龄              address: row[2], //地址              wechat: row[3] //wechat            }          })        tasks.push(promise)      }    }  });  // 等待所有数据添加完成  let result = await Promise.all(tasks).then(res => {    return res  }).catch(function(err) {    return err  })  return result}上面代码里注释的很清楚了，我这里就不在啰嗦了。 有几点注意的给大家说下1，要先创建数据表2，有时候如果老是解析失败，可能是有的电脑需要在云函数里也要初始化云开发环境四，解析并上传成功 如我的表格里有下面三条数据点击上传按钮，并选择我们的表格文件上传成功的返回如下，可以看出我们添加了3条数据到数据库添加成功效果图如下到这里我们就完整的实现了小程序上传excel数据到数据库的功能了。再来带大家看下流程图如果你有遇到问题，可以在底部留言，我看到后会及时解答。后面我会写更多小程序云开发实战的文章出来。也会录制本节的视频出来，敬请关注。" } { "title": "小程序不同页面的异步回调，callback和promise的使用讲解 ", "author": "Rolan", "pub_time": "2019-12-5 00:23", "content": "发个扫盲贴，大神请绕道。最近好多同学问我如何再请求数据成功后直接使用数据。我们通常的做法就是在请求成功后，再调用我们定义的方法，进而使用数据。如下代码  onLoad() {    let that=this    wx.cloud.database().collection(\"users\").get({      success(res) {        that.setData(res.data)      },      fail(res) {      }    })  },  showData(dataList) {    //.........做数据处理  },我们这样写其实也没什么不对，但是如果数据请求和使用是在两个不同的页面呢。 比如我们在app.js里请求位置，获取用户信息。然后在首页index.js里要使用这些数据，那么我们这么写就有问题了。下面就来教大家两种方式来很好的解决这个问题。一，通过callback回调。先看下代码，然后我再具体给大家讲解下原理。app.js里定义如下方法然后再index.js 里这么使用这时候，其实就可以看到了，我们在首页index.js里调用了app.js里的请求数据的方法，并且可以在index.js里直接使用数据。原理讲解 原理其实很简单，就是我们在app.js里的获取数据的方法里定义一个参数。而这个参数和普通参数唯一不同的地方，就是这个参数是个function方法我们上图的callback参数，其实就是下图 function(result){}把function方法作为一个参数传递进去的目的，就是为了下面的回调。我们这个callBack参数，可以在请求数据成功或者失败的时候作为一个方法调用。这样就可以把请求到的数据，回传回去了。 讲的有点绕，不知道大家有没有被绕晕。这在java开发中，其实就相当于监听者模式。说白了就是在一个页面里监听另外一个页面的动作，如获取数据成功，当监听到数据获取成功这个动作以后，就可以直接把数据回传回来了。 如果觉得这种方法有点绕，不好使用，我们就用下面的这个第二种方式。二，promisepromise的好处就是可以不用那个层层传递，不用那么绕。 还是先看代码，后面结合代码给大家讲下原理 app.js里定义如下方法index.js里这么调用用句通俗的话说，就是通过promise让我们的数据请求和使用看上去是在同一个页面完成。怎么实现的呢 1，在app.js里把数据请求封装到promise里，然后把promise返回到我们的首页index.js里 2，在首页里使用这个promise 实现数据的获取和使用。 在具体些就是下面这几步 promise基础用法1、new 一个Promise对象 2、请求数据的异步代码写在promise的函数中 3、promise接受两个参数，一个resolve(已成功success)，一个reject(已失败fail) 4、promise有三种状态pendding(进行中，当new了promise就是pendding的状态)、fulfilled(已成功)、rejected(已失败)，当成功的时候调用resolve将状态改为已成功，当失败的时候调用reject将状态改为已失败，一旦状态发生改变之后，状态就凝固了，后面就无法改变状态了，成功会将成功的数据返回，失败会将失败的信息返回。 5、在需要获取数据的地方通过promise.then()的方式获取，这里面接受两个参数，都是匿名函数，第一个是接受成功的函数，第二个是失败时候的函数好了，到这里我们两种不同页面的异步回调就给大家将完了。代码就完整的给大家贴出来吧，方便大家日后使用app.js//app.jsApp({  //第二种，通过promise  promiseGetData() {    let promise = new Promise(function(success, fail) {      wx.cloud.database().collection(\"users\").get({        success(res) {          success(res)        },        fail(res) {          fail(res)        }      })    })    return promise;  },  //第一种，通过callback的方式来实现回调  callBackGetData(callBack) {    wx.cloud.database().collection(\"users\").get({      success(res) {        callBack(res)      },      fail(res) {        callBack(res)      }    })  },})index.js// 异步调用，callbackconst app = getApp()Page({  clickBtn() { //按钮点击    //callback方式    // app.callBackGetData(function(result) {    //   console.log(\"dataList\", result)    // })    //promise方法    let promise = app.promiseGetData()    promise.then((res) => { //获取成功的结果，res中存着获取成功时的数据      console.log(\"成功\", res)    }, (error) => { // 获取数据失败时      console.log(\"失败\", error)    })  },})" } { "title": "当小程序的flex布局遇到button时，justify-content不起作用的原因及解决方案 ... ", "author": "Rolan", "pub_time": "2019-12-5 00:31", "content": "当小程序的flex布局遇到button时，justify-content不起作用的原因及解决方案 在做小程序的时候，要实现下面的搜索历史界面下面的搜索很明显的想到是用flex布局，然后把justify-content设置为justify-content: flex-start; 代码如下：<view class=\"flex\"><button class=\"item\">1</button><button class=\"item\">2</button><button class=\"item\">3</button><button class=\"item\">4</button><button class=\"item\">5</button><button class=\"item\">6</button><button class=\"item\">7</button></view>.flex{  display: flex;  flex-wrap: wrap;   justify-content: flex-start;}.flex .item{  width: 216rpx;  background-color: red;  margin-bottom: 34rpx;}可效果却不尽人意，发现justify-content不起作用，无论怎么设置都是space-around的效果。 经过排查，发现原因是小程序button中的默认样式中的margin-left: auto;margin-right: auto;所引起的。flex 格式化上下文中，在通过 justify-content 和 align-self 进行对齐之前，任何正处于空闲的空间都会分配到该方向的自动 margin 中去。参考自探秘 flex 上下文中神奇的自动 margin原因找到了，具体修改就容易多了，我们可以覆盖button的margin-left和margin-right的默认值，或者在button外面包裹一层view。在遇到这个问题之前，我也没想到过flex和margin之间还能这么用，涨姿势了" } { "title": "微信小程序|CSS的内边距和圆框 ", "author": "Rolan", "pub_time": "2019-12-9 00:02", "content": "本文首发于微信公众号： \"算法与编程之美\"，欢迎关注，及时了解更多此系列文章。问题描述在制作小程序的时候会经常用到浮动来设计各种组件的排版，微信小程序对排版的要求很高。 光有浮动是远远不够的，如果一个板块内的组件过多就会变得混乱。 所以就需要用设置内边框来调整位置。 微信小程序中会有很多的头像设置，所以就会用到圆框。 那么如何来设置css盒子的内边框和头像的圆框呢？解决方案跟网页一样小程序也是用很多标签来定义的。 需要用css盒子来设置解决问题，并调用来实现问题。（1）内边距我们需要用到margin这个标签代表内边距，用rpx来设置距离单位。 在.wxss中设置，然后在wxml中调用就可以了。margin-left： 离左边的距离margin-right： 离右边的距离margin-top： 离上边的距离margin-bottom： 离下边的距离margin-top: 100rpx;margin-left: 10rpx（2）框 用border来定义框线的宽度，用width和heigth来设置框的长宽。solid来定义颜色。 跟内边距一样在.wxss中设置，然后在wxml中调用。.view4{margin-top: 0rpx;margin-left: 0rpx;width: 800rpx;height: 115rpx;border: 5rpx solid whitesmoke}（3）圆框border-radius： rpx定义圆框。.view3{margin-top: 350rpx;margin-left: -190rpx;height: 60rpx;width: 220rpx;float: left;background-color: rgb(131, 178, 240);border-radius: r5px}（4）圆框头像跟上面的圆框一样也是用border-radius来定义，但不同的是后面的设置： %。 就是一个圆的弧度不同，rpx是将框的四角成为圆弧而%是成为一个圆。.view1{float: left;margin-left: 290rpx;margin-top: 120rpx;border-radius: 50%}结语对标签的正确使用和调用， 最麻烦的是对标签后面的单位设置，必须充满耐心，你需要不断地调才能调到你需要的位置，才能使界面美观。END实习编辑 | 王文星责 编 | 江汪霖where2go 团队微信号： 算法与编程之美" } { "title": "解决小程序渲染复杂长列表，内存不足问题 ", "author": "Rolan", "pub_time": "2019-12-9 00:12", "content": "问题回顾：我们有一个列表展示页，是无限瀑布流式的，展示的元素我们封装成了单个组件，暂且叫它Item组件。这个瀑布流包含若干个Item组件，并且这个Item组件也比较复杂，包含各种展示样式（根据不同类型，大概有9种吧，反正渲染节点很多），在进行滑动的过程中，item大概加载30-40个以后，就会造成小程序内存不足而退出，蓝瘦香菇......【干货在最后，小程序代码片段奉上】\r\n\r\n解决思路：\r\n将超出屏幕一定部分的列表内的组件进行不渲染的处理（也就是用wx:if卸载掉组件），当到达渲染临界点时再开始渲染；保证每次少量的数据展示。\r\n\r\n我们的项目中是保持15条Item，我们是每次分页请求5条，按照前5条，中间5条和后5条来划分，如果不在这个范围，则用一个等高度的骨架代替，并且卸载这些组件\r\n\r\n初期实现方式（后面有更优化的方式）\r\n使用曝光监听，当一个Item曝光时，记录Item高度，并放到数组里面，作为骨架的填充高度，如果已经记录了高度，则不再重复记录；曝光时向外传递一个当前渲染范围的中心值（比如当前Item所属页码，或者当前Item索引），以此进行处理；\r\n\r\n这里有一点要注意，如果你的列表item组件比较复杂，需要在ready的时候将记录的高度设置为item最小高度，不然组件重新装载时会有一定的渲染时间，在临界点会造成跳屏【此处已经通过骨架组件解决，可以忽略，只是作为踩坑记录】\r\n\r\n此时优化点\r\n\r\n为避免频繁setData和渲染，做了防抖函数，时间是600ms\r\n\r\n此时缺点\r\n\r\n滑动特别快时，会出现白屏，是因为曝光监听是在组件里面，而超快速滚动时，组件没有装载进来，也无法进行曝光监听，所以无法触发，这里考虑用骨架组件进行二次监听曝光\r\n\r\n优化迭代\r\n\r\n将骨架组件作为外壳套在Item外面（用slot），并对骨架进行监听曝光，可以解决上面缺点\r\n给骨架组件做一个常规骨架屏样式，而不是纯白色，看起来更优雅\r\n\r\n继续发现问题\r\n经过一系列的实践，上面的方案有些问题，其中最麻烦的就是，需要对外传递一个当前index，然后控制前后数据展示；这里对于每个用到skeleton组件的页面来说，都要重复的写一个方法来承接这个index，然后渲染页面对应的数据。\r\n优化\r\n依然是监听skeleton曝光，这里监听的方案变为出现在屏幕上下n屏的内容块进行展示，此范围外的内容块就卸载掉。\r\n如图所示\r\n\r\n核心代码\r\n     // 修改了监听是否显示内容的方法，改为前后showNum屏高度渲染\r\n     // 监听进入屏幕的范围relativeToViewport({top: xxx, bottom: xxx})\r\n      let info = SystemInfo.getInfo() //获取系统信息\r\n      let { windowHeight = 667 } = info.source.system\r\n      let showNum = 2 //超过屏幕的数量，目前这个设置是上下2屏\r\n      let listItemContainer = this.createIntersectionObserver()\r\n      listItemContainer.relativeToViewport({ top: showNum * windowHeight, bottom: showNum * windowHeight })\r\n        .observe(`#list-item-${this.data.skeletonId}`, (res) => {\r\n        \t// 此处来控制slot展示，详见代码片段\r\n        })\r\n       \r\n复制代码干货\r\n话不多说，干货放后面，点击获取代码片段\r\n最后，还是尽量减少节点数，优化代码" } { "title": "微信小程序setData复杂数组的更新、删除、添加、拼接 ", "author": "Rolan", "pub_time": "2019-12-9 00:20", "content": "众所周知，微信小程序里所有对数据的修改只有在setData里修改才会在页面上渲染。在此分享小程序里复杂数组的更新、删除、添加、拼接 初始数据数组嵌套对象data: {\r\n    cartList = [{ id: 1, goods: {id: 1, name: 'wechat'}, checked: true }, { id: 2, goods: {}, checked: false }, { id: 3, goods: {}, checked: true }]\r\n }, 索引部分删除1 let index = 2;\r\n2 let cartList = this.data.cartList\r\n3 cartList.splice(index, 1)\r\n4 this.setData({\r\n5         cartList: cartList\r\n6       }) 内部部分修改只修改数据内某项里的某属性。但此方法对于有引用到被修改的数据的wxs不会刷新页面显示，尚未清楚是bug还是小程序本身就不支持。let index = 2\r\nlet updateTodo = `cartList[${index}].checked`\r\nthis.setData({\r\n          [updateTodo]:  true\r\n        })用一个变量接收要修改的数组，修改好后再整体setData赋值，如果原数据很大的话可能会影响性能。1 let index = 2\r\n2 let cartList = this.data.cartList;\r\n3 cartList[index].checked = res.data.checked\r\n4 this.setData({\r\n5           cartList: cartList\r\n6         }) 添加、拼接push和concat 1 // push改变原数组\r\n 2 let newList=  [{ id: 4, goods: {}, checked: true }, { id: 5, goods: {}, checked: false }}]\r\n 3 let cartList = this.data.cartList;\r\n 4 cartList.push(...newList);\r\n 5 this.setData({\r\n 6           cartList: cartList\r\n 7         })\r\n 8 \r\n 9 // concat返回添加后的副本，并不会修改原有数组\r\n10 let newList=  [{ id: 4, goods: {}, checked: true }, { id: 5, goods: {}, checked: false }}]\r\n11 let cartList = this.data.cartList;\r\n12 this.setData({\r\n13           cartList: cartList.concat(newList)\r\n14         })" } { "title": "解决微信小程序安卓机器上 backgroundAudioManager 的一个坑 ", "author": "Rolan", "pub_time": "2019-12-9 10:32", "content": "一句话来说，问题的根源就在于安卓机器上 backgroundAudioManager.pause() 后还会触发一两次 onTimeUpdate背景在做的小程序中要做的一个功能是 AB 定次重复：重复播放音频中 A 秒到 B 秒的声音 N 次。根据我的需求，理想中流程是通过 backgroundAudioManager 的绑定事件完成功能（这里先不讨论 B == backgroundAudioManager.duration 的情况）。设定backgroundAudioManager的title和srcbackgroundAudioManager.seek(A)backgroundAudioManager.onSeeking()backgroundAudioManager.onSeeked()\t4.a backgroundAudioManager.play();backgroundAudioManager.onTimeUpdate\t5.a 如果 backgroundAudioManager.currentTime >= B, backgroundAudioManager.pause()\t5.a.1 如果没达到重复次数，回到步骤2\t5.b 如果 backgroundAudioManager.currentTime < B，回到步骤5问题在几次摸索后 iOS 上可以完美完成，但是安卓上会跳次数，比如希望一共播放3次，在播放完第一次之后会直接跳过第二次进行第三次的播放，最后一共只播放了两次。解决我在网上搜的时候发现有人写到了\tbackgroundAudioManager中的一些坑 ，其中提到暂停状态下跳转到指定位置，在 onSeeked() 回调中，Android 的 currentTime 是跳转前的时间，而 iOS 是跳转后的时间。一开始我以为完全是这个原因，seek 后第一次 onTimeUpdate 时 currentTime >= B导致直接跳次数，所以我就加上一个 boolean 变量，在 onSeeked 中将它赋值为 true，用它判断是否刚执行 seek，如果否再进行 currentTime 的判断。但是改来改去问题还是存在。在加了一堆 console.log，反复和 iOS的结果比较后为发现了问题的根本所在。安卓机器上 backgroundAudioManager.pause() 后还会触发一两次 onTimeUpdate找到了问题解决起来就比较简单啦，在 onTimeUpdate 中先判断 backgroundAudioManager.paused 是否为 true，只有在 backgroundAudioManager.paused == false 时才进行步骤5的流程。结论backgroundAudioManager 和 innerAudioContext 写起来，测试起来都好痛苦。同样的代码 innerAudioContext 在 2.6.1 可以在开发工具中完成我要的效果，但是后面的版本就不行了。而且 iOS，Android 还有开发者工具上的行为都不一样，每次改一点就要用两个手机扫码预览还是挺不方便的。希望官方可以优化一下。这篇文章我原本发在微信小程序交流专区https://developers.weixin.qq.com/community/develop/article/doc/00086c3f998a603d51899109151013" } { "title": "小程序开发中的一些实践和踩坑 ", "author": "Rolan", "pub_time": "2019-12-10 00:23", "content": "在公司小程序也开发了一段时间了，中间遇到过很多问题，特此记录几个比较典型的问题和解决方案。01—textarea 的高层级问题此问题提供源码demo，可导入微信开发者工具查看。复制到电脑上打开：https://github.com/dunizb/CodeTest/tree/master/Wechat/textarea-test 症状（表现）textarea 是小程序的原生组件，它的一个表现就是优先级很高，这导致了一些困扰，比如我们有一个表单页面，最下面就是一个textarea和一个保存按钮，这会导致textarea的文字会浮现在按钮上。如下图：它最大的问题是会导致保存按钮可能点击无效或者会弹出键盘，并且开发者工具模拟器和真机表现不一样，这真是个坑！诊断（实验）模拟器中，针对 position:fixed 定位的按钮，我们加一个 z-index:10 即可， z-index 等于多少合适不清楚，试了等于1是不行的，10就可以，其余的值没试过。.submit-cls {  position: fixed;  left: 30px;  right: 30px;  bottom: 300px;  text-align: center;  background-color: green;  color: #fff;  z-index: 10;}模拟器中的表现：然儿，真机上（Android）依然无效！如下图：于是我想到了 cover-view 标签，cover-view 是微信提供的一个原生组件，它是覆盖在原生组件之上的文本视图，可覆盖的原生组件包括 map、video、canvas、camera、live-player、live-pusher之上，只支持嵌套 cover-view、cover-image，可在 cover-view 中使用 button。用 cover-view 标签包裹 button 如何呢？郁闷的事情发生了，真机上按钮不见了！。。。这方法貌似不行。。<cover-view>  <button class=\"submit-cls\" id='button' bindtap=\"onClick\"> Button z-index: 10 </button></cover-view>那我直接用 cover-view 标签作为按钮呢？<cover-view class=\"cover-view-clas\" id='cover-view' bindtap=\"onClick\"> cover-view z-index: 10 </cover-view>.cover-view-clas {  position: fixed;  height: 40px;  line-height: 40px;  left: 30px;  right: 30px;  bottom: 250px;  text-align: center;  background-color: orangered;  color: #fff;}结果在模拟器里不行但是真机上表现很好。于是我也加了一个 z-index: 10 ，这样模拟器和真机表现就一致。药方（总结）综上所述，要解决这个问题似乎只有一个办法，那就是用 cover-view + z-index:10 ，然儿这样会导致一个的副作用，没法使用微信的开放能力比如 open-type。02—setData优化我们知道，与传统的浏览器Web页面最大区别在于，小程序的是基于 双线程 模型的，在这种架构中，小程序的渲染层使用 WebView 作为渲染载体，而逻辑层则由独立的 JsCore 线程运行 JS 脚本，双方并不具备数据直接共享的通道，因此渲染层和逻辑层的通信要由 Native 的 JSBrigde 做中转。每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。然而当 setData 传递大量的新数据、频繁的执行 setData 操作、过多的页面节点数时会影响渲染性能。区分数据类别意思是， setData 只用来通知页面更新，只有需要通知页面更新的时候，页面引用了某个 data 字段时才使用，其它字段数据我们有时候可能只是为了让 js 方便使用。比如如下数据data: {    form: {        name: 'xxxx',        ... ...    },    index: 0}假如 页面上根本没用到 index 来展示，只是我们的逻辑变量，那么我们在赋值的时候就直接 this.data.index = xxx 即可，不要用 setData 去赋值了。合理利用局部更新setData 是支持使用 数据路径 的方式对对象的局部字段进行更新，我们可能会遇到这样的场景：list 列表是从后台获取的数据，并展示在页面上，当 list 列表的第一项数据的 src 字段需要更新时，一般情况下我们会从后台获取新的 list 列表，执行 setData 更新整个 list 列表。// 后台获取列表数据const list = requestSync(); // 更新整个列表this.setData({ list });实际上，只有个别字段需要更新时，我们可以这么写来避免整个 list 列表更新:// 后台获取列表数据const list = requestSync(); // 局部更新列表this.setData({   'list[0].src': list[0].src});善用自定义组件小程序自定义组件的实现是由小程序官方设计的 Exparser 框架所支持，框架实现的自定义组件的组件模型与 Web Components 标准的 Shadow DOM 相似：在页面引用自定义组件后，当初始化页面时，Exparser 会在创建页面实例的同时，也会根据自定义组件的注册信息进行组件实例化，然后根据组件自带的 data 数据和组件WXML，构造出独立的 Shadow Tree ，并追加到页面 Composed Tree 。创建出来的 Shadow Tree 拥有着自己独立的逻辑空间、数据、样式环境及setData调用，这是组件化带来的好处。基于自定义组件的 Shadow DOM 模型设计，我们可以将页面中一些需要高频执行 setData 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。当这些自定义组件视图需要更新时，执行的是组件自己的 setData ，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。03—大表单交互的一点实践经验在项目中，有一个预约模块，字段忒多，保险业务嘛，需要用户填写各种数据的，为了用户体验拆成了多个步骤，如图一开始，业务上要求切换tab的时候数据要缓存，跟Vue的 keep-alive 一样，但是小程序没有这样的机制，所以利用小程序的 hidden 属性，也就是 Vue 中的 v-show，组件始终会被渲染，只是简单的控制显示与隐藏。关于wx:if 和 hidden。这样的导致页面节点太多，在低性能手机上会出现卡死的现象，直接无法渲染或者渲染太慢。后来改为 wx:if 来切换<view wx:if=\"{{current === 0}}\">......</view><view wx:if=\"{{current === 1}}\">......</view><view wx:if=\"{{current === 2}}\">......</view>... ...这样一来一次渲染节点太多的问题解决了，但是怎么实现tab切换的时候输入的内容杯缓存呢？其实我们的笨办法就是切换的时候把前一个表单内容保存到 localStorage 或 gloabData 中，切换回去的时候再取出来填充，这中间会有一个明显的渲染过程，肉眼可见，没办法，目前只能牺牲一点点体验了。对于这种大型表单，数据处理和逻辑交互的时候要非常注意，很容易出现性能问题。这次就说这么多吧，文章如有什么错误，或有什么想法，请留言，不吝赐教！" } { "title": "浅谈微信小程序流量变现的常见模式 ", "author": "Rolan", "pub_time": "2019-11-26 00:01", "content": "什么是小程序，小程序是基于微信平台发展而衍生出的即用即走、无需下载的第三方工具。由于其具有操作简单、使用便捷的天然优势，因而现在使用微信小程序人数的增长速度犹如闪电般一样。同时，现在小程序的变现流量也是大幅度的增长，这为商家企业带来了红利期。那么，今天小编将为大家介绍几种常见的小程序流量变现模式，供大家学习与参考。模式一 : 电商变现在微信社交关系链和微信支付体系里，电商小程序流量变现优势明显。电商类的小程序用户直接完结购买流程，包含产品选购、购买、付出一系列的流程，直接变现。如：拼多多、享物说、每日优鲜等社交电商小程序依靠微信社交关系链裂变传播，日订单数也在千万量级。模式二：广告变现广告变现是小游戏、工具类、资讯类小程序变现的主要方式。小程序官方开放了Banner广告，只要活跃用户达到一定量级，可通过广告点击直接变现流量。模式三 : 内容付费付费流量变现方式带动了微信小程序内容付费的发展，如Reader、读书知乎live等小程序，都选用的是付费程序。将公众号绑定小程序可以在公众号推文中嵌入付费产品的小程序贴片。小程序不必下载不占内存，界面清新，用小程序付费体验比APP更好，用户形成习惯后，可直接通过内容付费小程序模式完成引流、推广和变现的流量闭环营销操作。模式四 : 游戏付费微信官方发布了小游戏支撑微信交际关系链玩法，小程序游戏中道具、会员等等这些都能成为商家盈利的方法。游戏底部 banner 位、原生广告植入、续命激励来引导用户点击广告、通过设置付费关卡和道具等，都是游戏小程序的付费方式。当然，关于小程序的变现模式，不局限于以上四种，例如电商卖货、平台卖货等新型盈利模式，也赢得了强烈的反响度。因此，商家应当根据自己的用户群体和产品属性，来选择合适的流量变现模式。" } { "title": "微信小程序——基础知识 ", "author": "Rolan", "pub_time": "2019-11-26 00:02", "content": "目录结构介绍一个小程序至少由俩个文件组成 app.js 和 app.json 1. app.js 小程序逻辑 2. app.json 小程序全局配置 3. app.wxss 小程序公共样式表 4. project.config.json 开发项目时工具配置文件。一个小程序页面由四个文件组成传统web小程序结构HTMLwxml样式表CSSwxss逻辑Javascriptjs配置无json初始化页面的俩个警告:warning::warning:根据 sitemap 的规则[0]，当前页面 [pages/index/index] 将被索引 解决方案：小程序项目配置文件 project.config.json 的 setting 中配置字段 \"checkSiteMap\": false\"setting\": {\r\n    \"checkSiteMap\": false\r\n},\r\n复制代码:warning:获取 wx.getUserInfo 接口后续将不再出现授权弹窗，请注意升级解决方案：清空 App.js全局配置路由、导航栏和tabBar小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。路由 Pages路由 Pages | 微信开放文档项目开发目录为：├── app.js\r\n├── app.json\r\n├── app.wxss\r\n├── pages\r\n│   │── index\r\n│   │   ├── index.wxml\r\n│   │   ├── index.js\r\n│   │   ├── index.json\r\n│   │   └── index.wxss\r\n│   └── logs\r\n│       ├── logs.wxml\r\n│       └── logs.js\r\n└── utils\r\n复制代码则需要在 app.json 中写{\r\n    \"pages\": [\r\n        \"pages/index/index\",\r\n        \"pages/logs/logs\"\r\n    ],\r\n}\r\n复制代码顶部导航 window顶部导航 window | 微信开放文档用于设置小程序的状态栏、导航条、标题、窗口背景色。window属性说明文档属性描述backgroundTextStyle下拉 loading 的样式，仅支持 dark / lightnavigationBarBackgroundColor导航栏背景颜色，如 #000000navigationBarTitleText导航栏标题文字内容`navigationBarTextStyle导航栏标题颜色，仅支持 black / whiteenablePullDownRefresh是否开启当前页面的下拉刷新 true / false代码实例{\r\n    \"window\": {\r\n        \"backgroundTextStyle\": \"dark\",\r\n        \"navigationBarBackgroundColor\": \"#0081ff\",\r\n        \"navigationBarTitleText\": \"教育Top10\",\r\n        \"navigationBarTextStyle\": \"white\",\r\n        \"enablePullDownRefresh\": true\r\n    },\r\n}\r\n复制代码如何设置某个单页面的导航栏？自定义顶部栏,文字、背景色，在该单页面的 json里添加如下：{\r\n\t\"usingComponents\": {},\r\n    \"navigationBarTitleText\": \"课程列表\",\r\n    \"navigationBarBackgroundColor\": \"#0081ff\",\r\n    \"navigationBarTextStyle\": \"white\"\r\n}\r\n复制代码隐藏顶部栏，在该单页面的 json 里添加如下：{\r\n    \"navigationStyle\": \"custom\"\r\n}\r\n复制代码底部 tabBar底部 tabBar | 微信开放文档 小程序是一个多 tab 应用，可以通过 tabBar 配置项指定 tab 栏的表现，及切换时显示的对应页面。tabBar属性说明文档属性描述colortab 上的文字默认颜色，仅支持十六进制颜色selectedColortab 上的文字选中时的颜色，仅支持十六进制颜色backgroundColortab 的背景色，仅支持十六进制颜色borderStyletabbar上边框的颜色， 仅支持 black / whitecustom自定义 tabBar，见 详情listtab 的列表，详见 list 属性说明list 数组，包含 tab 最少 2 个、最多 5 个list属性描述pagePath路由：跳转到指定页面text底部导航文字iconPath底部导航图标、未选中状态selectedIconPath底部导航图标、选中状态代码实例{\r\n    \"tabBar\": {\r\n        \"color\": \"#333\",\r\n        \"selectedColor\": \"#0081ff\",\r\n        \"borderStyle\": \"black\",\r\n        \"backgroundColor\": \"#fff\",\r\n        \"list\": [\r\n            {\r\n                \"pagePath\": \"pages/tabBar/tabBar_home/tabBar_home\",\r\n                \"text\": \"首页\",\r\n                \"iconPath\": \"images/Tabbar/home.png\",\r\n                \"selectedIconPath\": \"images/Tabbar/home_cur.png\",\r\n            },\r\n            {\r\n                \"selectedIconPath\": \"images/Tabbar/my_cur.png\",\r\n                \"iconPath\": \"images/Tabbar/my.png\",\r\n                \"pagePath\": \"pages/tabBar/tabBar_myCenter/tabBar_myCenter\",\r\n                \"text\": \"个人中心\"\r\n            }\r\n        ],\r\n    }\r\n}\r\n复制代码基础组件view 视图容器text 文本<text>纯文本</text> 组件之间只能包含纯文本，在text中写其他标签，将会被忽略掉<text \r\n    class=\"info\" \r\n    id=\"zbc\" \r\n    style=\"\" \r\n    bindtap=\"_fun\" 点击事件\r\n    hidden=\"true\" 显示隐藏[微信小程序--hidden不生效原因及解决方案?]\r\n    data-user=\"user\" 自定义组件\r\n>\r\n    hello world\r\n</text>\r\n复制代码image 图片微信小程序 Image 图片实现宽度100%，高度自适应 mode=\"widthFix\"<image class=\"img\" src=\"../../images/hello.png\" mode=\"widthFix\">\r\n\r\n.img{width: 100vw;}\r\n复制代码Flex 布局Flex 布局兼容性Flex 布局属性要使用弹性布局，通过 display: flex 或者 display: inline-flex 来将此元素定义为弹性容器。flex-direction 决定元素的排列方向row\r\ncolumn\r\nflex-wrap 决定元素如何换行nowrap\r\nwrap\r\njustify-content 定义主轴为水平方向，分布方式。flex-start\r\nflex-end\r\ncenter\r\nspace-between\r\nspace-around\r\nalign-items 定义主轴为垂直方向，分布方式。flex-start\r\nflex-end\r\ncenter\r\nflex: 1 权重，分配主轴上剩余的空间（有图）<view style=\"display:flex;\">\r\n    <view class=\"A\" style=\"width: 140rpx;height: 80rpx; flex: 1;\"></view>\r\n    <view class=\"B\" style=\"width: 140rpx;height: 80rpx;\"></view>\r\n    <view class=\"C\" style=\"width: 140rpx;height: 80rpx;\"></view>\r\n    <view class=\"D\" style=\"width: 140rpx;height: 80rpx;\"></view>\r\n</view>\r\n复制代码数据绑定数据绑定 | 微信开放文档简单绑定<view> {{ message }} </view>\r\n复制代码Page({\r\n  data: {\r\n    message: 'Hello MINA!'\r\n  }\r\n})\r\n复制代码三元运算<view hidden=\"{{flag ? true : false}}\"> Hidden </view>\r\n复制代码算数运算<view> {{a + b}} + {{c}} + d </view>\r\n复制代码Page({\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n    c: 3\r\n  }\r\n})\r\n复制代码view中的内容为 3 + 3 + d。是否同意该协议表单按钮<checkbox checked=\"{{false}}\"> </checkbox>\r\n复制代码特别注意：不要直接写  checked=\"false\" ，其计算结果是一个字符串，转成 boolean 类型后代表真值。列表渲染wx:for列表渲染 | 微信开放文档在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 默认数组的当前项的下标变量名默认为 index ，数组当前项的变量名默认为 item 数据绑定使用 {{}} 将变量包起来，可以作用于：轮播图wx:for<swiper>\r\n    <swiper-item wx:for=\"{{banner}}\" wx:key=\"{{index}}\">\r\n        <image src=\"{{item.img}}\"></image>\r\n    </swiper-item>\r\n</swiper>\r\n复制代码Page({\r\n    data: {\r\n        banner: [{\r\n            img: '../../images/swiper-1.jpeg',\r\n        }, {\r\n            img: '../../images/swiper-2.jpeg',\r\n        }]\r\n    }\r\n})\r\n复制代码上述代码的简略版<swiper>\r\n    <swiper-item wx:for=\"{{2}}\" wx:key=\"{{index}}\">\r\n        <image src=\"../../images/swiper-{{index + 1}}.jpeg\"></image>\r\n    </swiper-item>\r\n</swiper>\r\n复制代码wx:for-item 和 wx:for-index使用 wx:for-item 可以指定数组当前元素的变量名， 使用 wx:for-index 可以指定数组当前下标的变量名：<swiper>\r\n    <swiper-item wx:for=\"{{banner}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">\r\n        <image src=\"{{itemName.img}}\"></image>\r\n    </swiper-item>\r\n</swiper>\r\n复制代码wx:keywx:key 是列表中唯一的字符串或数字，且不能动态改变。例如：<switch wx:for=\"{{objectArray}}\" wx:key=\"unique\" style=\"display: block;\"> {{item.id}} </switch>\r\n复制代码Page({\r\n    data: {\r\n        objectArray: [\r\n            { id: '时间', unique: 'unique_5' },\r\n            { id: '速度', unique: 'unique_4' },\r\n            { id: '路程', unique: 'unique_3' },\r\n            { id: 2, unique: 'unique_2' },\r\n        ],\r\n    },\r\n})\r\n复制代码小鹿咖啡的菜单【实例】<scroll-view scroll-y class=\"rightBar\">\r\n        <view class=\"rightBar_Item\" wx:for=\"{{foodList}}\" wx:key=\"{{index}}\">\r\n            <view class=\"series_Title flex\">\r\n                <view class=\"drink_Title_name\">{{item.title}}</view>\r\n                <view class=\"drink_Title_line\"></view>\r\n            </view>\r\n            <view class=\"drink_List\">\r\n                <view class=\"drink_Item flex\" wx:for-item=\"it\" wx:for=\"{{item.food}}\" wx:key=\"{{index}}\">\r\n                    <view class=\"drink_Img\">\r\n                        <image class=\"drink_Img\" src=\"{{it.img}}\"></image>\r\n                        <view class=\"tip\" wx:if=\"{{it.tip}}\">{{it.tip}}</view>\r\n                    </view>\r\n                    <view class=\"drink_Cont\">\r\n                        <view class=\"drink_Title\">\r\n                            <view class=\"drink_Ch_Title\">{{it.name}}</view>\r\n                            <view class=\"drink_En_Title\">{{it.enname}}</view>\r\n                        </view>\r\n                        <view class=\"ju_between\">\r\n                            <view class=\"drink_price\">¥{{it.price}}</view>\r\n                        </view>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n    </scroll-view>\r\n复制代码Page({\r\n    data: {\r\n        \"foodList\": [\r\n            {\r\n                \"id\": 1,\r\n                \"title\": \"大师咖啡\",\r\n                \"food\": [\r\n                    {\r\n                        \"id\": 1,\r\n                        \"img\": \"http://r.photo.store.qq.com/psb?/V12jhopW1tjEiY/SvHL13tH2g5UKUmVrbCjAPs4sLNBvAo7fhdJGpEU1.s!/r/dFQBAAAAAAAA\",\r\n                        \"name\": \"摩卡\",\r\n                        \"enname\": \"Mocha\",\r\n                        \"price\": \"27\",\r\n                        \"tip\": \"买2增1\"\r\n                    },\r\n                ]\r\n            },\r\n            {\r\n                \"id\": 2,\r\n                \"title\": \"小鹿茶\",\r\n                \"food\": [\r\n                    {\r\n                        \"id\": 1,\r\n                        \"img\": \"http://r.photo.store.qq.com/psb?/V12jhopW1tjEiY/VoBwYjGp2dIkV1owMWjVr4rm6Tp3wl8H1Gsa7n5hh08!/r/dFQBAAAAAAAA\",\r\n                        \"name\": \"活力柠檬红宝石茶\",\r\n                        \"enname\": \"Lemon Ruby Tea\",\r\n                        \"price\": \"24\",\r\n                        \"tip\": \"买2增1\"\r\n                    },\r\n                    {\r\n                        \"id\": 2,\r\n                        \"img\": \"http://r.photo.store.qq.com/psb?/V12jhopW1tjEiY/o7p7XoYAGaeMH6EtQNPVbU8tHFnKZitOcl9RarOcqNA!/r/dAgBAAAAAAAA\",\r\n                        \"name\": \"桃桃山雾乌龙茶\",\r\n                        \"enname\": \"White & Yellow Peach Oolong Tea\",\r\n                        \"price\": \"24\"\r\n                    }\r\n                ]\r\n            }\r\n        ]\r\n    },\r\n})\r\n复制代码条件渲染wx:if条件渲染 | 微信开放文档wx:if使用方法wx:if=\"{{false}}\" , wx:if=\"{{true}}\"在小程序里面识别boolean值时，只要属性的值 不为空时，boolean就判断为真，就算里面随便几个字符，例如 wx:if=\"11223\" ，也判断为真， 如果需要为false,就必须采用数据绑定的方式{{false}},才能被小程序解析为假。在框架中，使用 wx:if=\"\" 来判断是否需要渲染该代码块： 也可以用  wx:elif 和  wx:else 来添加一个 else 块：<view wx:if=\"{{length > 85}}\">优秀</view>\r\n<view wx:elif=\"{{length > 60}}\">及格</view>\r\n<view wx:else>不及格</view>\r\n复制代码Page({\r\n    data: {\r\n        length: 61,\r\n    }\r\n})\r\n复制代码结果：及格的使用注意： <block/> 并不是一个组件，它仅仅是一个包装元素，将多个组件包装起来,不会在页面中做任何渲染，只接受控制属性。 wx:if 和 wx:for 含有 <block/> 的写法data: {\r\n        modalToggle: false,\r\n    },\r\n复制代码<block wx:if=\"{{modalToggle}}\">\r\n    \t<view class=\"modalWrap\">\r\n        \t<view class=\"modal\"></view>\r\n    \t</view>\r\n\t</block>\r\n\r\n复制代码不含有 <block/> 的写法data: {\r\n        modalToggle: false,\r\n    },\r\n复制代码<view class=\"modalWrap\" wx:if=\"{{modalToggle}}\">\r\n    \t<view class=\"modal\"></view>\r\n\t</view>\r\n复制代码教育Top10收藏列表【实例】页面描述：当有数据时，显示左侧列表。当没有数据时，则显示右侧内容<block wx:if=\"{{list.length>0}}\">\r\n    <block wx:for=\"{{list}}\" wx:key=\"idx\">\r\n        <view>{{item}}</view>\r\n    </block>\r\n</block>\r\n<block wx:else>\r\n    <view>暂时未收藏哦~</view>\r\n</block>\r\n复制代码Page({\r\n    data: {\r\n        list: ['月落乌啼霜满天','江枫渔火对愁眠']\r\n    },\r\n})\r\n复制代码wx:if vs  hidden1. wx:if 在初始渲染条件为  false ，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。所以当  wx:if 的条件值切换时，框架有一个局部渲染的过程，确保条件块在切换时销毁或重新渲染。 2. hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。总结: wx:if 有更高的切换消耗，而  hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用  hiddenhidden不生效原因及解决方案?<view hidden=\"true\" style=\"display:flex;\">\r\n    <text>text1</text>\r\n    <text>text2</text>\r\n</view>\r\n复制代码你会发现 hidden 没生效。经我实验发现 hidden 元素对块状布局才生效，所以这段代码里导致 hidden 没生效的罪魁祸首是 display:flex 。把这个去掉就可以了。如果一定要用flex布局怎么办？其实这里想用 hidden 无非就是想影藏这个布局， display:none 也能做到隐藏。这里可以用一个取巧的方法，动态设置 display 属性，示例如下：<view style=\"display:{{hideview ? 'none' : 'flex'}};\">\r\n    <text>text1</text>\r\n    <text>text2</text>\r\n</view>\r\n复制代码这里的 hideview 是在对应的 js 里是一个变量，由 js 来动态控制。" } { "title": "捕获web与小程序JS异常的方法 ", "author": "Rolan", "pub_time": "2019-11-26 00:50", "content": "前段时间，我们发现小程序异步代码里的错误没有上报到异常监控平台，经过排查这部分小程序没法直接监听到，需要我们手动上报。再者，开发过程中，异常处理一直是不太受重视且容易遗漏的模块。本文总结了JS异常的类型及捕获方法，最后针对小程序给出错误处理经验。JS异常分类Error：常规异常，一般为用户自定义的异常，如 new Error(\"error message\")，这类自定义的错误用来统计异常数据，直接上报即可；RangeError：数值溢出越界异常，当 Number 类型变量超过指定的范围，如var pi = 3.14159;  pi.toFixed(100000);d（toFixed()方法参数只能接受 0~100） ；ReferenceError：引用异常，当不存在的变量被使用的时候，这类错误一般在编码检查阶段就会暴露；SyntaxError：语法错误，作为解释型语言的 JavaScript 只有到执行的时候才能识别出语法错误，这类错误在编码检查和构建阶段就会暴露；TypeError：类型错误，当调用不存在的对象方法或对象不存在时，例如：var foo = {}; foo.bar();为了避免这类错误出现，可使用防御式编程，但如若数据有误则应抛出异常；URIError：encodeURI() 和 decodeURI() 方法参数不正确抛出的异常，例如：decodeURIComponent(\"%\");EvalError：eval() 方法参数不正确抛出的异常；Web端对异常的捕获能力了解了异常的分类后，我们还需要知道浏览器如何捕获到这些异常。1）try-catchJavaScript 里有 try-catch 语法块，可用于异常捕获处理。try-catch 可以成功捕获大部分错误，但对于 SyntaxError 语法错误 和 异步代码中的错误，则无法捕获。例如：SyntaxError 语法错误try {\r\n    var p = \r\n} catch(e) { \r\n    console.log('caught error: ', e.message)\r\n}\r\n\r\n// 输出：Uncaught SyntaxError: Unexpected token '}'复制代码例如：异步代码中的错误try {\r\n    setTimeout(function() {\r\n        var p = error + 1\r\n    }, 0)\r\n} catch(e) {\r\n    console.log('caught error:', e.message)\r\n}\r\n\r\n// 输出：Uncaught ReferenceError: error is not defined复制代码2）error 事件try-catch 针对我们预感到可能会有问题的代码，捕获异常进行处理，而对于一些我们未知的错误，可以使用 window 对象的 error 事件进行监听。error 事件可以捕获到同步或异步（非 Promise ）代码中的非语法错误。例如：异步代码中的错误window.addEventListener('error', e => {\r\n  console.log('caught error', e.message);\r\n  e.preventDefault();\r\n});\r\nsetTimeout(function() {\r\n    var p = error + 1\r\n}, 0)\r\n\r\n// 输出：caught error Uncaught ReferenceError: error is not defined复制代码需要注意的是：e.preventDefault() 在 error 监听事件中调用，可以阻止报告异常给浏览器，别让浏览器默认地在控制台输出错误。另外，文档中也提到关于资源加载失败的错误：When a resource (such as an <img> or <script>) fails to load, an error event using interface Event is fired at the element that initiated the load, and the onerror() handler on the element is invoked. These error events do not bubble up to window, but (at least in Firefox) can be handled with a window.addEventListener configured with useCapture set to True.对于图片或脚本资源加载失败，这类错误不会冒泡给 window，但可以在捕获阶段进行处理，即addEventListener 最后一个参数置为 true：window.addEventListener('error', e => {\r\n    console.log('资源加载失败');\r\n}, true)复制代码3）unhandledRejection 与 rejectionhandled 事件error 事件可以捕获到非 Promise 的异步错误，而针对 Promise，window对象有专门的事件来处理这类错误。当异步错误没被 catch 住时，触发 unhandledRejection 事件：window.addEventListener('unhandledrejection', e => {\r\n    console.log('caught unhandledrejection', e.reason);\r\n    e.preventDefault();\r\n})\r\nvar p = new Promise(function(resolve, reject) {\r\n    tp = error + 1\r\n})\r\n\r\n// 输出：caught unhandledrejection ReferenceError: error is not defined复制代码而当异步错误一开始未被 catch 住，过后才被 catch 的情况，会先触发 unhandledRejection 事件，当被 catch 的时候，会触发 rejectionhandled 事件：window.addEventListener('unhandledrejection', e => {\r\n    console.log('caught unhandledrejection', e.reason);\r\n    e.preventDefault();\r\n})\r\nwindow.addEventListener('rejectionhandled', e => {\r\n    console.log('caught rejectionhandled', e.reason);\r\n    e.preventDefault();\r\n})\r\nvar p = new Promise(function(resolve, reject) {\r\n    tp = error + 1\r\n})\r\nsetTimeout(() => {\r\n    p.catch(e => console.log('catch', e.message))\r\n}, 1000)\r\n\r\n// 输出：\r\n// caught unhandledrejection ReferenceError: error is not defined\r\n// （1s后）\r\n// catch error is not defined\r\n// caught rejectionhandled ReferenceError: error is not defined复制代码也就是说未处理的异常增加时会触发 unhandledRejection，而未处理的异常（被处理后）减少时会触发 rejectionhandled，这在上报异常中可以避免上报那些已经被处理过的异常。关于兼容性，截止至本文成稿，移动端的支持程度还是可以的，iOS主流版本 和 Chrome 都支持：（图来源：unhandledrejection/rejectionhandled events，caniuse.com/#search=unh…）小程序端对异常的捕获能力小程序的 App 对象中有 onError 方法，相当于 web 端的 error 事件，可以捕获到同步或异步（非 Promise ）代码中的非语法错误。而对于 Promise，小程序并没有如 window 对象中的 unhandledRejection 与 rejectionhandled 事件，无法像 web 端那样统一处理异常。不过，既然都是 Promise 相关的错误，那么，我们可以改写或覆盖 Promise 对象，将其进行封装把所有错误都 catch 住也就可以了。推荐 promise-polyfill 这个轻量级的 promise 实现包，其中提供了 _unhandledRejectionFn 方法，用于捕获那些未被处理的 Promise 异常。import Promise from 'promise-polyfill';\r\nPromise._unhandledRejectionFn = function(rejectError) {\r\n    // 处理异常或上报\r\n}\r\n复制代码总结关于JS的异常总结已经差不多了，之前一直觉得这部分知识不够系统，一来自己重视程度不够，二来也是知识点不多但都较零散。经过这段时间收集资料，捋清思路，编码实现还算有所收获，便总结成文，若有不尽不祥不对之处烦请各位读者多多指点。参考文献Exceptional Exception Handling in JavaScript前端代码异常监控实战GlobalEventHandlers.onerrorPromise rejection events in Using Promisespromise-polyfill" } { "title": "微信小程序：扭蛋抽奖机-css3动画实现 ", "author": "Rolan", "pub_time": "2019-11-26 00:59", "content": "最近快速上线一个抽奖活动，又不想用canvas做，思考了很久，还是决定使用css3的动画来做，只要小球动得快，就没人发现我这些个小球的运动路径都是一样的了。先上动图。扭蛋机抽奖.gifwxml文件：<view class=\"ball-box\">      <image class=\"ball ball_1 {{start?'weiyi_1':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball1.png\"></image>      <image class=\"ball ball_2 {{start?'weiyi_2':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball1.png\"></image>      <image class=\"ball ball_3 {{start?'weiyi_3':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball2.png\"></image>      <image class=\"ball ball_4 {{start?'weiyi_4':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball2.png\"></image>      <image class=\"ball ball_5 {{start?'weiyi_5':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball1.png\"></image>      <image class=\"ball ball_6 {{start?'weiyi_6':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball2.png\"></image>      <image class=\"ball ball_7 {{start?'weiyi_7':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball3.png\"></image>      <image class=\"ball ball_8 {{start?'weiyi_8':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball3.png\"></image>      <image class=\"ball ball_9 {{start?'weiyi_9':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball3.png\"></image>      <image class=\"ball ball_10 {{start?'weiyi_10':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball4.png\"></image>      <image class=\"ball ball_11 {{start?'weiyi_11':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball4.png\"></image></view>这个做得我头皮发麻，但是写这篇文章时突然想到，为啥不用个for循环来做呢？！<view class=\"ball-box\">  <image wx:for=\"ballList\" wx:for-index=\"i\" class=\"ball ball_{{i}} {{start?'weiyi_{{i}}':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball{{i}}.png\"></image></view>这样看起来是不是舒服多了，因为是这段代码现场手写，如果有啥bug也不好说。wxss文件：.weiyi_1 {  animation: around1 1.5s linear infinite;  -webkit-animation: around1 1.5s linear infinite;}简单的动画/* 位移 */@-webkit-keyframes around1 {  0% {    -webkit-transform: translate(0rpx, 0rpx)  }  20% {    -webkit-transform: translate(100rpx, -250rpx)  }  40% {    -webkit-transform: translate(200rpx, -100rpx)  }  60% {    -webkit-transform: translate(50rpx, -230rpx)  }  80% {    -webkit-transform: translate(300rpx, -50rpx)  }  100% {    -webkit-transform: translate(0, 0)  }}@keyframes around1 {  0% {    transform: translate(0rpx, 0rpx)  }  20% {    transform: translate(100rpx, -250rpx)  }  40% {    transform: translate(200rpx, -100rpx)  }  60% {    transform: translate(50rpx, -230rpx)  }  80% {    transform: translate(300rpx, -50rpx)  }  100% {    transform: translate(0, 0)  }}简单的位移 其他就不一一列出来了，反正都差不多，改变一下运动轨迹就行了。js文件：相比丧病的样式，js文件就简单多了。_this.setData({  start: true})控制抽奖开始setTimeout(() => {        _this.setData({          start: false,          end: true        })      //其他代码部分      //time是接口请求开始到结束的时间}, Math.ceil(time / 1500) * 1500 - time)这里用了一个setTimeout，用于设置动画结束时间，优化一下动画，不让结束看起来太突兀。 1500是wxss里这是的动画时间。总结：简单的扭蛋机，有时间用canvas来做做。" } { "title": "Taro+react自定义导航条/Tabbar菜单 ", "author": "Rolan", "pub_time": "2019-11-27 00:38", "content": "基于taro自定义导航栏Navbar|仿微信顶部导航|taro自定义tabbar这几天研究taro发现，官网提供的都是H5、小程序案例，至于RN案例甚少。恰好之前有过react及react-native项目经验，经过一番探究，终于实现能编译到多端，不过采坑不少，尤其是在RN环境下的样式问题。react仿微信web版聊天室： blog.csdn.net/yanxinyun19…如下图：在H5/小程序/RN效果均测试通过项目中用到的图标都是阿里iconfont字体图标，下载好后将fonts文件夹拷贝到项目目录下。import './styles/fonts/iconfont.scss' 在h5、小程序下 这种写法即可： <Text className=\"iconfont icon-back\"></Text>不过为了兼容RN，只能通过Unicode方式这样写： <Text className=\"iconfont\">&#xe84c;</Text>如果是通过变量传递： let back = '\\ue84c' <Text>{back}</Text>Taro自定义导航栏在App.js配置navigationStyle，将设置为custom，就可以自定义导航栏class App extends Component {\r\n    config = {\r\n        pages: \r\n            'pages/index/index',\r\n            ...\r\n        ],\r\n        window: {\r\n            backgroundTextStyle: 'light',\r\n            navigationBarBackgroundColor: '#fff',\r\n            navigationBarTitleText: 'Taro',\r\n            navigationBarTextStyle: 'black',\r\n            navigationStyle: 'custom'\r\n        },\r\n        ...\r\n    }\r\n    \r\n    ...\r\n}\r\n复制代码components目录下新建导航栏Navbar组件/*\r\n * @desc   Taro自定义导航条navbar组件\r\n * @about  Q：282310962  wx：xy190310\r\n */\r\n\r\nimport Taro from '@tarojs/taro'\r\nimport { View, Text, Input, Image } from '@tarojs/components'\r\nimport classNames from \"classnames\";\r\nimport './index.scss'\r\n \r\nexport default class NavBar extends Taro.Component {\r\n    // 默认配置\r\n    static defaultProps = {\r\n        isBack: false,\r\n        leftIcon: '\\ue84c',\r\n        title: ' ',\r\n        background: '#6190e8',\r\n        color: '#fff',\r\n        center: false,\r\n        search: false,\r\n        searchStyle: '',\r\n        fixed: false,\r\n        headerRight: [],\r\n    }\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            searchText: '',\r\n        }\r\n    }\r\n\t\r\n\t...\r\n \r\n    render() {\r\n        const { isBack, leftIcon, title, background, color, center, search, searchStyle, fixed, height, headerRight } = this.props\r\n        const { searchText } = this.state\r\n        \r\n        let weapp = false\r\n        if (process.env.TARO_ENV === 'weapp') {\r\n            weapp = true\r\n        }\r\n \r\n        return (\r\n            <View className={classNames('taro__navbar', fixed && 'taro__navbar--fixed', fixed && weapp && 'taro__navbar-weapp--fixed')}>\r\n                <View className={classNames('taro__navbar-wrap', fixed && 'taro__navbar-wrap--fixed', weapp && 'taro__navbar-wrap__weapp')} style={{backgroundColor: background}}>\r\n                    {/* 返回 */}\r\n                    <View className={classNames('taro__navbar-left__view', isBack && 'taro__navbar-left__view--isback')}>\r\n                    {isBack &&\r\n                        <TouchView activeOpacity={.5} onClick={this.handleNavigateBack}>\r\n                            <View className=\"taro__navbar-icon__item\"><Text className=\"iconfont taro__navbar-iconfont\" style={{color: color}}>{leftIcon}</Text></View>\r\n                        </TouchView>\r\n                    }\r\n                    </View>\r\n                    \r\n                    {/* 标题 */}\r\n                    {!search && center && !weapp ? <View className=\"flex1\" /> : null}\r\n                    {search ? \r\n                    (\r\n                        <View className=\"taro__navbar-search flex1\">\r\n                            <Input className=\"taro__navbar-search__input\" placeholder=\"搜索...\" onInput={this.updateInputText} style={{color: color, ...searchStyle}} />\r\n                        </View>\r\n                    )\r\n                    :\r\n                    (\r\n                        <View className={classNames('taro__navbar-title flex1', center && !weapp && 'taro__navbar-title--center')}>\r\n                            {title && <Text className=\"taro__navbar-title__text\" style={{color: color}}>{title}</Text>}\r\n                        </View>\r\n                    )\r\n                    }\r\n \r\n                    {/* 右侧 */}\r\n                    <View className=\"taro__navbar-right__view\">\r\n                    {headerRight.map((item, index) => (\r\n                        <TouchView activeOpacity={.5} key={index} onClick={()=>item.onClick && item.onClick(searchText)}>\r\n                            <View className=\"taro__navbar-icon__item\">\r\n                                {item.icon && <Text className=\"iconfont taro__navbar-iconfont\" style={{color: color, ...item.style}}>{item.icon}</Text>}\r\n                                {item.text && <Text className=\"taro__navbar-iconfont__text\" style={{color: color, ...item.style}}>{item.text}</Text>}\r\n                                {item.img && <Image className=\"taro__navbar-iconfont__img\" src={item.img} mode='aspectFit' />}\r\n                                {/* 圆点 */}\r\n                                {!!item.badge && <Text className=\"taro__badge taro__navbar-badge\">{item.badge}</Text>}\r\n                                {!!item.dot && <Text className=\"taro__badge-dot taro__navbar-badge--dot\"></Text>}\r\n                            </View>\r\n                        </TouchView>\r\n                    ))\r\n                    }\r\n                    </View>\r\n                </View>\r\n            </View>\r\n        );\r\n    }\r\n}\r\n复制代码在页面引入组件即可： import NavBar from '@components/navbar'支持自定义背景、颜色、左侧图标、标题居中、搜索框，右侧按钮支持图标/文字/图片，还可以设置样式，红点提示、事件处理<NavBar title='Taro标题栏' fixed\r\n    headerRight={[\r\n        {icon: '\\ue614', style: {color: '#e93b3d'}},\r\n        {img: require('../../assets/taro.png'), dot: true, onClick: this.handleCallback},\r\n        {icon: '\\ue600', style: {marginRight: 10}},\r\n    ]} \r\n/>复制代码<NavBar isBack leftIcon={'\\ue69f'} title='搜索栏' background='#42b983' color='#fcc' search\r\n    searchStyle={{\r\n        backgroundColor:'rgba(255,255,255,.6)', borderRadius: Taro.pxTransform(50), color: '#333'\r\n    }}\r\n    headerRight={[\r\n        {icon: '\\ue622', style: {color: '#6afff9'}},\r\n        {icon: '\\ue63a'},\r\n    ]} \r\n/>复制代码Taro自定义底部Tabbarimport Taro from '@tarojs/taro'\r\nimport { View, Text } from '@tarojs/components'\r\nimport classNames from 'classnames'\r\nimport './index.scss'\r\n \r\nexport default class TabBar extends Taro.Component {\r\n    // 默认参数配置\r\n    static defaultProps = {\r\n        current: 0,\r\n        background: '#fff',\r\n        color: '#999',\r\n        tintColor: '#6190e8',\r\n        fixed: false,\r\n        onClick: () => {},\r\n        tabList: []\r\n    }\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            updateCurrent: props.current\r\n        }\r\n    }\r\n    ...\r\n \r\n    render() {\r\n        const { background, color, tintColor, fixed } = this.props\r\n        const { updateCurrent } = this.state\r\n        \r\n        return (\r\n            <View className={classNames('taro__tabbar', fixed && 'taro__tabbar--fixed')}>\r\n                <View className={classNames('taro__tabbar-list', fixed && 'taro__tabbar-list--fixed')} style={{backgroundColor: background}}>\r\n                    {this.props.tabList.map((item, index) => (\r\n                        <View className=\"taro__tabbar-item taro__tabbar-item--active\" key={index} onClick={this.updateTabbar.bind(this, index)}>\r\n                            <View className=\"taro__tabbar-icon\">\r\n                                <Text className=\"iconfont taro__tabbar-iconfont\" style={{color: updateCurrent == index ? tintColor : color}}>{item.icon}</Text>\r\n                                {/* 圆点 */}\r\n                                {!!item.badge && <Text className=\"taro__badge taro__tabbar-badge\">{item.badge}</Text>}\r\n                                {!!item.dot && <Text className=\"taro__badge-dot taro__tabbar-badge--dot\"></Text>}\r\n                            </View>\r\n                            <Text className=\"taro__tabbar-title\" style={{color: updateCurrent == index ? tintColor : color}}>{item.title}</Text>\r\n                        </View>\r\n                    ))}\r\n                </View>\r\n            </View>\r\n        );\r\n    }\r\n}\r\n复制代码自定义tabbar也支持自定义背景、颜色、图标，点击选项事件返回索引值<TabBar current={currentTabIndex} background='#f8f8f8' color='#999' tintColor='#6190e8' fixed onClick={this.handleTabbar}\r\n    tabList={[\r\n        {icon: '\\ue627', title: '首页', badge: 8},\r\n        {icon: '\\ue61e', title: '商品'},\r\n        {icon: '\\ue605', title: '个人中心', dot: true},\r\n    ]}\r\n/>\r\n复制代码好了，今天就介绍到这里，后续会考虑使用Taro技术开发个多端实战项目。ReactNative聊天APP实战|仿微信聊天/朋友圈/红包界面" } { "title": "微信小程序推送消息简单Demo ", "author": "Rolan", "pub_time": "2019-11-27 00:45", "content": "在开始前，你需要准备：注册微信小程序一个简单的springBoot 项目微信开发者工具正式微信小程序发送消息主要通过WxMaTemplateMessage 类来推送public class WxMaTemplateMessage implements Serializable {\r\n    private String toUser;       // 给谁推送(用户openId)\r\n    private String templateId;  // 消息ID\r\n    private String page;    // 用户点开消息跳转到对应的小程序界面\r\n    private String formId;  // 表单formId\r\n    private List<WxMaTemplateData> data; // 消息的数据列表\r\n    private String emphasisKeyword;  \r\n...\r\n复制代码所以我们在推送前需要构造这些信息，formId 和toUser(openId) 是从前端传过来的。formId 可以通过表单或者支付来获取，表单比较简单，只需要把report-submit 设置为true 就可以获得。简单通过微信开发者工具来获取formId(openId 数据库存了)先建立一个前端项目，AppID 就是小程序的id，在微信公众号后台可以看到。修改index/index.js 和index.wxml (百度某位同学的)，通过表单来获取formId ，并发送到后台。// index.wxml\r\n<form bindsubmit='registerFormSubmit' report-submit='true'>\r\n  <view class='buttons'>\r\n    <button class='confirmbtn' form-type='submit'>确定</button>\r\n  </view>\r\n\r\n</form>\r\n<view>formid： {{formid}}</view>\r\n<button bindtap='push'>\r\n    发送\r\n</button>\r\n\r\n复制代码//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n\r\nPage({\r\n  \r\n  data: {\r\n    formid: \"\"\r\n  },\r\n  //事件处理函数\r\n  registerFormSubmit: function (e) {\r\n    //    打印formId\r\n    console.log(e.detail.formId);\r\n    this.setData({\r\n      formid: e.detail.formId\r\n    })\r\n   },\r\n  //测试推送\r\n push() {\r\n    let formid = this.data.formid;\r\n   let openid = 'oT-H-40ZHdRX1REZFKQhPg3jJZoQ';\r\n    wx.request({\r\n      url: 'http://localhost:8080/push?openId=' + openid + \"&formId=\" + formid,\r\n      success(res) {\r\n        console.log(\"推送结果：\", res)\r\n      },\r\n      fail(err) {\r\n        console.log(\"推送失败：\", err)\r\n      }\r\n    })\r\n  }\r\n})\r\n\r\n复制代码这里formid 在测试的时候获取不到，调到真机调试，或者用预览就行了。请求后台接口来发送消息（ctrl c v 百度某同学）import cn.binarywang.wx.miniapp.api.WxMaService;\r\nimport cn.binarywang.wx.miniapp.api.impl.WxMaServiceImpl;\r\nimport cn.binarywang.wx.miniapp.bean.WxMaTemplateData;\r\nimport cn.binarywang.wx.miniapp.bean.WxMaTemplateMessage;\r\nimport cn.binarywang.wx.miniapp.config.WxMaInMemoryConfig;\r\nimport me.chanjar.weixin.common.error.WxErrorException;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@RestController\r\npublic class PushController {\r\n\r\n    @GetMapping(\"/push\")\r\n    public String push(@RequestParam String openId, @RequestParam String formId) {\r\n        //1,配置小程序信息\r\n        WxMaInMemoryConfig wxConfig = new WxMaInMemoryConfig();\r\n        wxConfig.setAppid(\"你的appId\");\r\n        wxConfig.setSecret(\"你的secret\");\r\n\r\n        WxMaService wxMaService = new WxMaServiceImpl();\r\n        wxMaService.setWxMaConfig(wxConfig);\r\n\r\n        //2,设置模版信息（keyword1：类型，keyword2：内容）\r\n        List<WxMaTemplateData> templateDataList = new ArrayList<>(2);\r\n        WxMaTemplateData data1 = new WxMaTemplateData(\"keyword1\", \"获取老师微信\");\r\n        WxMaTemplateData data2 = new WxMaTemplateData(\"keyword2\", \"2501902696\");\r\n        WxMaTemplateData data3 = new WxMaTemplateData(\"keyword3\", \"2501902696\");\r\n        WxMaTemplateData data4 = new WxMaTemplateData(\"keyword4\", \"2501902696\");\r\n        templateDataList.add(data1);\r\n        templateDataList.add(data2);\r\n        templateDataList.add(data3);\r\n        templateDataList.add(data4);\r\n\r\n        //3，设置推送消息\r\n        WxMaTemplateMessage templateMessage = WxMaTemplateMessage.builder()\r\n                                                  .toUser(openId)\r\n                                                  .formId(formId)\r\n                                                  .templateId(\"你的消息id\") // 在微信公众号后台可以申请消息模版\r\n                                                  .data(templateDataList)\r\n                                                  .page(\"pages/index/index\")\r\n                                                  .build();\r\n\r\n        //4，发起推送\r\n        try {\r\n            wxMaService.getMsgService().sendTemplateMsg(templateMessage);\r\n        } catch (WxErrorException e) {\r\n            System.out.println(\"推送失败：\" + e.getMessage());\r\n            return e.getMessage();\r\n        }\r\n        return \"推送成功\";\r\n    }\r\n\r\n}\r\n复制代码" } { "title": "记《高校考勤系统》小程序（1） ", "author": "Rolan", "pub_time": "2019-11-28 00:03", "content": "引言这是我自学小程序并上线的第一个算是完整的项目(其实是♀朋友的毕业设计需求 )，前端萌新一枚.其中肯定会有许多不合理或需要改进的地方请大家指出，谢谢！:sunglasses::sunglasses:(前期准备工作就不介绍啦，我们直接进入正题)一.功能需求整理，思路规划1.用户注册登录.2.教师及学生课程表信息关联、课程表信息查看.3.校园信息发布、签到任务发布、请假管理、用户管理.4.自己顺手加的天气，海报生成功能.拿到需求想了想除了注册登录，主要划分两大块，一为普通学生用户功能，二为管理员教师功能.因为要在一个小程序中全部展示，所以思考在用户注册时添加‘status’字段作为后续用户权限判断依据来展示相对应的页面及功能。(也不知道这样做对不对:cry:，头大)根据理解画了流程图二.项目整体布局搭建小程序主要划分为四块，所以首先我们在app.json中创建对应的tabbar.其中素材用到了阿里巴巴图标库 ( www.iconfont.cn )实现效果：三.用户注册登录在此前我们需要开通云开发并在数据库中创建存储用户信息的集合.引入Vant Weapp 和ColorUI组件库（组件丰富，上手方便，色彩搭配beautiful:+1:） youzan.github.io/vant-weapp/… www.color-ui.com/这里我新建了三张页面分别为启动动画过渡页、登录页、注册页.启动动画过渡页:点击查看js代码Page({\r\n    data: {\r\n            openid: '', //获取用户_openid\r\n            panduan: '', //判断用是否存在\r\n            arr: []\r\n    },\r\n    onLoad: function(options) {\r\n            wx.cloud.callFunction({ //获取用户openid\r\n            name: 'login',\r\n            data: {},\r\n        }).then(res => {\r\n            this.openid = res.result.openid\r\n        }).then(res => {\r\n            const db = wx.cloud.database({ \r\n                env: 'env-urae8'  //数据库环境名\r\n            })\r\n            db.collection('users').get().then(res => { //获取用户数据\r\n                this.arr = res.data\r\n                for (let i = 0; i < this.arr.length; i++) { //循环判断用户数据中是否存在用户\r\n                    if (this.openid == this.arr[i]._openid) {\r\n                        this.panduan = 'true'\r\n                    }\r\n                }\r\n            }).then(res => {\r\n                if (this.panduan == 'true') { //存在用户跳转登录页面\r\n                    wx.reLaunch({\r\n                        url: '/pages/index/index',\r\n                    })\r\n                } else if (this.data.panduan == '') {\r\n                    wx.redirectTo({\r\n                        url: '/pages/login/login' //不存在用户跳转登录页\r\n                    })\r\n                }\r\n            })\r\n            }).catch(err => {\r\n                wx.showToast({\r\n                    icon: 'none',\r\n                    title: '用户信息获取失败，请检查网络',\r\n                })\r\n            })\r\n    }\r\n})\r\n复制代码用户登录页:点击查看js代码Page({\r\n    data: {\r\n        userid:'',\r\n        haveuserid:'no',\r\n        openid: '',\r\n        errMsg:''\r\n    },\r\n    onGotUserInfo(e){\r\n        this.data.errMsg = e.detail.errMsg\r\n        if (e.detail.errMsg == 'getUserInfo:ok'){\r\n        this.setData({\r\n            userBtn: true,\r\n            trueBtn:false\r\n        })\r\n    }\r\n    },\r\n    useridInput(e){\r\n        this.userid = e.detail.value\r\n    },\r\n    loginBtn(){\r\n        this.data.haveuserid = 'no'  //清除判断是否存在用户名\r\n        const db = wx.cloud.database({   //数据库新增用户注册信息\r\n            env: 'env-urae8'\r\n        })\r\n        db.collection('users').get().then(res => {\r\n            for (let i = 0; i < res.data.length; i++) {\r\n                if (res.data[i].userid === this.userid && res.data[i]._openid == this.openid) {\r\n                    this.data.haveuserid = 'yes'\r\n                }\r\n            }\r\n            var pattern = /^\\d{6,12}$/\r\n            if(this.userid == '000001'){\r\n                wx.switchTab({\r\n                    url: '/pages/index/index'\r\n                })\r\n            }else if (pattern.test(this.userid) && this.data.haveuserid == 'yes' && this.data.errMsg == 'getUserInfo:ok'){\r\n                wx.switchTab({\r\n                    url: '/pages/index/index'\r\n                })\r\n            }else if (this.data.errMsg == 'getUserInfo:fail auth deny' || this.data.errMsg == '') {\r\n                wx.showToast({\r\n                    title: '请授权后再登录',\r\n                    icon: 'none',\r\n                    duration: 2000\r\n                })\r\n            }else if (!pattern.test(this.userid)) {  //判断是否符合用户名\r\n                wx.showToast({\r\n                    title: '请输入6-12位数字',\r\n                    icon: 'none',\r\n                    duration: 1500\r\n                })\r\n            }else if (this.data.haveuserid == 'no') {\r\n                wx.showToast({\r\n                    title: '学号或工号错误或不存在,请重新输入或注册',\r\n                    icon: 'none',\r\n                    duration: 2000\r\n                })\r\n            } \r\n        })\r\n    },\r\n    registerBtn(){\r\n        wx.redirectTo({\r\n            url: '/pages/register/register'\r\n        })\r\n    },\r\n    onLoad: function (options) {\r\n        this.setData({\r\n            trueBtn:true  //用户授权框样式\r\n        })\r\n        wx.cloud.callFunction({ //获取用户openid\r\n            name: 'login',\r\n            data: {},\r\n            success: res => {\r\n                this.openid = res.result.openid\r\n            },\r\n            fail: err => {\r\n                wx.showToast({\r\n                    icon: 'none',\r\n                    title: '用户信息获取失败，请检查网络',\r\n                })\r\n            }\r\n        })\r\n    }\r\n})\r\n复制代码<view class=\"title\">登录</view>\r\n<view>\r\n    <view class=\"input\">\r\n        <image src=\"../../images/userimg.png\"></image>\r\n        <input class=\"inputBtn\" bindinput=\"useridInput\" placeholder=\"请输入学号或工号\"></input>\r\n    </view>\r\n    <view class=\"userBtn\">\r\n        <button hidden=\"{{ userBtn }}\" open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"onGotUserInfo\"\r\n            class=\"onGotUserInfo\"></button>\r\n        <image hidden=\"{{ trueBtn }}\" class=\"true\" src=\"../../images/true.png\"></image>\r\n        <text class=\"userTit\">用户授权</text>\r\n    </view>\r\n    <button class=\"loginBtn shadow bg-blue\" bindtap=\"loginBtn\">登 录</button>\r\n    <button class=\"registerBtn shadow bg-blue\" bindtap=\"registerBtn\">注 册</button>\r\n</view>\r\n复制代码点击查看wxss代码page {\r\n    position: relative;\r\n    background-color: white;\r\n}\r\n.title {\r\n    margin-top: 200rpx;\r\n    text-align: center;\r\n    font-size: 40rpx;\r\n}\r\n.input{\r\n    width: 60%;\r\n    margin: 0 auto;\r\n    margin-top: 120rpx;\r\n    padding: 20rpx;\r\n    border-radius: 10rpx;\r\n    background-color: #f6f6f6;\r\n    display: flex;\r\n    justify-content: start;\r\n}\r\n.input image{\r\n    width: 30rpx;\r\n    height: 30rpx;\r\n    margin-top: 6rpx;\r\n    display: block;\r\n}\r\n.inputBtn {\r\n    width: 100%;\r\n    height: 40rpx;\r\n    margin-left: 20rpx;\r\n}\r\n.loginBtn, .registerBtn {\r\n    width: 400rpx;\r\n    margin: 0 auto;\r\n    background-color: #07c160;\r\n    color: white;\r\n    font-weight: 600;\r\n}\r\n.loginBtn {\r\n    margin-bottom: 60rpx;\r\n    margin-top: 60rpx;\r\n}\r\n.userBtn {\r\n    margin-top: 160rpx;\r\n    margin-left: 190rpx;\r\n    display: flex;\r\n    justify-content: flex-start;\r\n}\r\n.onGotUserInfo {\r\n    width: 44rpx;\r\n    height: 44rpx;\r\n    border-radius: 20rpx;\r\n    padding: 0;\r\n    margin: 0;\r\n    border: 6rpx solid #07c160;\r\n}\r\n.true{\r\n    width: 44rpx;\r\n    height: 44rpx;\r\n}\r\n.userTit{\r\n    margin-left: 12rpx;\r\n}\r\n复制代码用户注册页:点击查看js代码const app = getApp()\r\nwx.cloud.init();\r\nPage({\r\n    data: {\r\n        steps: [{\r\n                text: '第一步',\r\n                desc: '授权登录'\r\n            },\r\n            {\r\n                text: '第二步',\r\n                desc: '输入信息'\r\n            },\r\n            {\r\n                text: '第三步',\r\n                desc: '完成注册'\r\n            }\r\n        ],\r\n        active: 0,\r\n        nextOne: true, //第一个下一步\r\n        hiddenName: false, //授权登录\r\n        userid: '', // 用户学号或者工号\r\n        nickName: '', //用户名\r\n        avatarUrl: '', //用户头像\r\n        userStatus: '0', //用户注册状态\r\n        step: 1,\r\n        openid: '',\r\n        haveuserid:'no'//判断是否存在用户名\r\n    },\r\n    nextOne() {\r\n        this.setData({\r\n            active: 1, //状态为步骤2\r\n            firstBoxHide: true, //隐藏步骤1框\r\n            secondBoxHide: false //显示步骤2框\r\n        })\r\n    },\r\n    onGotUserInfo(e) {\r\n        this.setData({\r\n            nickName: e.detail.userInfo.nickName, //获取用户名\r\n            avatarUrl: e.detail.userInfo.avatarUrl, //获取头像\r\n            nextOne: false, //下一步按钮显示\r\n            hiddenName: true, //授权按钮隐藏\r\n            firstHide: false //显示用户信息\r\n        })\r\n        this.nickName = e.detail.userInfo.nickName\r\n        this.avatarUrl = e.detail.userInfo.avatarUrl\r\n    },\r\n    useridInput(e) {\r\n        this.userid = e.detail.value\r\n    },\r\n    secondBtn() {\r\n        this.data.haveuserid = 'no'  //清除判断是否存在用户名\r\n        const db = wx.cloud.database({   //数据库新增用户注册信息\r\n            env: 'env-urae8'\r\n        })\r\n        db.collection('users').get().then(res => {\r\n            for(var i = 0;i < res.data.length ; i++){\r\n                if (res.data[i].userid === this.userid || res.data[i]._openid == this.openid){\r\n                    this.data.haveuserid = 'yes'\r\n                }\r\n            }   \r\n            var pattern = /^\\d{6,12}$/\r\n            if (!pattern.test(this.userid)) {  //判断是否符合用户名\r\n                wx.showToast({\r\n                    title: '请输入6-12位数字',\r\n                    icon: 'none',\r\n                    duration: 1500\r\n                })\r\n            } else if (this.data.haveuserid == 'yes') {  //判断数据库是否存在用户名\r\n                wx.showToast({\r\n                    title: '用户已存在,请直接登录',\r\n                    icon: 'none',\r\n                    duration: 1500\r\n                })\r\n                this.setData({\r\n                    backBtn: false, //显示返回登录按钮\r\n                })\r\n            } else {\r\n                this.setData({\r\n                    secondBtn: true, //隐藏确定按钮\r\n                    nextTwo: false //显示second框下一步按钮\r\n                })\r\n            }\r\n        })\r\n    },\r\n    backBtn(){ //返回登录页面\r\n        wx.redirectTo({\r\n            url: '/pages/login/login'\r\n        })\r\n    },\r\n    nextTwo() {\r\n        this.setData({\r\n            userid: this.userid,\r\n            nickName: this.nickName,\r\n            avatarUrl: this.avatarUrl,\r\n            secondBoxHide: true, //隐藏second框\r\n            thirdBoxHide: false, //显示third框\r\n            nextTwo: true, //隐藏下一步2按钮\r\n            active: 3, //初始状态为步骤3\r\n        })\r\n    },\r\n    thirdBtn() { //完成注册按钮\r\n        const db = wx.cloud.database({   //数据库新增用户注册信息\r\n            env: 'env-urae8'\r\n        })\r\n        db.collection('users').add({\r\n            data: {\r\n                userid: this.userid,\r\n                nickName: this.nickName,\r\n                userStatus: this.data.userStatus\r\n            },\r\n            success: res => {\r\n                wx.switchTab({\r\n                    url: '/pages/index/index'\r\n                })\r\n            }\r\n        })\r\n    },\r\n    onLoad: function(options) {\r\n        this.setData({\r\n            active: 0, //初始状态为步骤1\r\n            nextOne: true, //隐藏下一步按钮\r\n            firstHide: true, //隐藏用户框信息\r\n            firstBoxHide: false, //\r\n            secondBoxHide: true, //隐藏步骤2框\r\n            nextTwo: true, //隐藏second框下一步按钮\r\n            thirdBoxHide: true, //显示third框\r\n            backBtn:true,  //隐藏返回登录按钮\r\n        })\r\n        //获取用户openid\r\n        if (this.data.step === 1 && !this.data.openid) {\r\n            wx.cloud.callFunction({\r\n                name: 'login',\r\n                data: {},\r\n                success: res => {\r\n                    app.globalData.openid = res.result.openid\r\n                    this.step = 2,\r\n                    this.openid = res.result.openid\r\n                },\r\n                fail: err => {\r\n                    wx.showToast({\r\n                        icon: 'none',\r\n                        title: '用户信息获取失败，请检查网络',\r\n                    })\r\n                }\r\n            })\r\n        }\r\n    }\r\n})\r\n复制代码<view class=\"cont\">\r\n    <view class=\"title\">注册</view>\r\n    <view class=\"cont_box\">\r\n        <van-steps class=\"van-steps\" steps=\"{{ steps }}\" active=\"{{ active }}\" active-color=\"#07c160\"\r\n            inactive-icon=\"../../images/true.png\" />\r\n    </view>\r\n    <view class=\"first\" hidden=\"{{ firstBoxHide }}\">\r\n        <view class=\"user_box\" hidden=\"{{ firstHide }}\">\r\n        <image class=\"avatarUrl\" src=\"{{ avatarUrl }}\"></image>\r\n    </view>\r\n    <view class=\"nickName\" hidden=\"{{ firstHide }}\">{{ nickName }}</view>\r\n        <button hidden=\"{{hiddenName}}\" open-type=\"getUserInfo\" lang=\"zh_CN\"\r\n            bindgetuserinfo=\"onGotUserInfo\" class=\"loginBtn shadow bg-blue\">微信授权</button>\r\n        <button class=\"nextOne shadow bg-blue\" bindtap=\"nextOne\" hidden=\"{{ nextOne }}\">下一步</button>\r\n    </view>\r\n    <view class=\"second\" hidden=\"{{ secondBoxHide }}\">\r\n        <input class=\"useridInput\" bindinput=\"useridInput\" placeholder=\"请输入学号或工号\"></input>\r\n        <button class=\"secondBtn shadow bg-blue\" bindtap=\"secondBtn\" hidden=\"{{ secondBtn }}\">确定</button>\r\n        <button class=\"nextTwo shadow bg-blue\" bindtap=\"nextTwo\" hidden=\"{{ nextTwo }}\">下一步</button>\r\n        <button class=\"backBtn shadow bg-blue\" bindtap=\"backBtn\" hidden=\"{{ backBtn }}\">返回登录</button>\r\n    </view>\r\n    <view class=\"third\" hidden=\"{{ thirdBoxHide }}\">\r\n        <view class=\"user_box\" >\r\n            <image class=\"avatarUrl\" src=\"{{ avatarUrl }}\"></image>\r\n        </view>\r\n        <view class=\"nickName\">微信名：{{ nickName }}</view>\r\n        <view class=\"userid\">学号：{{ userid }}</view>\r\n        <button class=\"thirdBtn shadow bg-blue\" bindtap=\"thirdBtn\">完成注册</button>\r\n    </view>\r\n</view>\r\n复制代码点击查看wxss代码page {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n    background-color: white;\r\n}\r\n.register_bg {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n    top: 0;\r\n    left: 0;\r\n}\r\n.cont {\r\n    width: 100%;\r\n    margin-top: 200rpx;\r\n    color: black;\r\n    z-index: 1;\r\n    display: flex;\r\n    justify-content: start;\r\n    flex-direction: column;\r\n}\r\n.cont .title {\r\n    font-size: 46rpx;\r\n    text-align: center;\r\n    margin-bottom: 60rpx;\r\n}\r\n.van-steps {\r\n    width: 82%;\r\n    margin: 0 auto;\r\n}\r\n.first, .second, .third {\r\n    width: 100%;\r\n    height: 500rpx;\r\n    position: relative;\r\n    text-align: center;\r\n}\r\n.first .user_box, .third .user_box {\r\n    width: 160rpx;\r\n    height: 160rpx;\r\n    border-radius: 80rpx;\r\n    margin: 0 auto;\r\n    margin-top: 50rpx;\r\n    position: relative;\r\n    overflow: hidden;\r\n    box-shadow:0 2rpx 4rpx rgba(0, 0, 0, .3);\r\n}\r\n.nickName{\r\n    height: 40rpx;\r\n    line-height: 40rpx;\r\n    margin-top: 26rpx;\r\n    font-size: 30rpx;\r\n}\r\n.first .avatarUrl, .third .avatarUrl {\r\n    width: 160rpx;\r\n    height: 160rpx;\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n}\r\n.first .success {\r\n    margin-top: 20rpx;\r\n}\r\n.loginBtn, .nextOne, .nextTwo, .backBtn,.secondBtn,.thirdBtn {\r\n    width: 240rpx;\r\n    height: 80rpx;\r\n    background-color: #07c160;\r\n    color: white;\r\n    line-height: 80rpx;\r\n    text-align: center;\r\n    font-size: 30rpx;\r\n    font-weight: 600;\r\n    border: none;\r\n    position: absolute;\r\n    bottom: 0;\r\n    left: calc(50% - 120rpx);\r\n}\r\n.secondBtn{\r\n    bottom: 260rpx;\r\n}\r\n.backBtn {\r\n    bottom: 130rpx;\r\n}\r\n/* 清除button样式 */\r\nbutton {\r\n    font-size: 28rpx;\r\n    background-color: transparent;\r\n    border: none;\r\n    padding: 0;\r\n    margin: 0;\r\n    line-height: 1;\r\n}\r\nbutton::after {\r\n    border: none;\r\n    background-color: transparent;\r\n}\r\n.button-hover {\r\n    color: rgba(0, 0, 0, 0.8);\r\n    background-color: transparent;\r\n}\r\n.second .useridInput {\r\n    width: 60%;\r\n    height: 40rpx;\r\n    padding: 20rpx;\r\n    border-radius: 12rpx;\r\n    margin: 50rpx auto;\r\n    text-align: left;\r\n    background-color: #f6f6f6;\r\n}\r\n.third .userid {\r\n    margin-top: 30rpx;\r\n}\r\n复制代码三.首页页面搭建天气数据来自阿凡达数据，也是比较了许多接口，这个相对返回数据比较可观且收费也在承受范围之内 www.avatardata.cn/ .UI样式参考了许多其他小程序（墨迹天气、小天气等）; 天气小模块参考 juejin.im/post/5d2f3f… ; 腾讯地图api lbs.qq.com/qqmap_wx_js… ; 感谢他们给予的帮助及参考:+1::+1::+1:先来看看完成后的效果图1.获取当前定位城市信息.前期需要注册腾讯地图并认证，获取key，在项目中引入微信小程序JavaScript SDK，具体步骤可以参考腾讯地图api:point_up_2:（链接见上）getUserLocation() {\r\n    var qqmapsdk;\r\n    var _this = this;\r\n    wx.getSetting({ //判断是否授权\r\n    success(res) {\r\n    wx.getLocation({\r\n      type: 'gcj02', //返回可以用于wx.openLocation的经纬度\r\n      success(res) {\r\n        // console.log('已授权')\r\n        qqmapsdk = new QQMapWX({\r\n          key: \"****\", //自己申请的key\r\n        })\r\n        qqmapsdk.reverseGeocoder({\r\n          location: {\r\n            latitude: res.latitude,\r\n            longitude: res.longitude\r\n          },\r\n          success(addressRes) {\r\n            // console.log(addressRes) //这里就可以获取到当前经纬度所在城市的详细信息\r\n            _this.city = addressRes.result.ad_info.city; //获取当前所在城市\r\n            })\r\n          },\r\n          fail(res) {\r\n            console.log(res)\r\n          }\r\n        })\r\n      },\r\n      fail(res) {\r\n        // console.log('未授权')\r\n      }\r\n    })\r\n  }\r\n})\r\n},\r\n复制代码2.根据定位获取到的城市信息，调用天气接口获取当前城市天气数据.wx.request({\r\n    url: 'https://api.avatardata.cn/Weather/Query?key=你注册后的key值&cityname=' + 定位获取到的城市名,\r\n    header: {\r\n        'content-type': 'application/json' // 默认值\r\n    },\r\n    success(res) {\r\n        //返回城市天气数据\r\n    }\r\n})\r\n复制代码3.根据当前天气状况判断天气模块的显示隐藏. 例如：if (res.data.result.weather[i].info.day[1].indexOf('晴') >= 0) { //判断条件为接口返回数据\r\n        //晴天天气模块显示其他隐藏\r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('阴') >= 0 || \r\n    res.data.result.weather[i].info.day[1].indexOf('云') >= 0) {\r\n        //多云或阴天天气模块显示其他隐藏\r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('小雨') >= 0) {\r\n        //小雨气模块显示其他隐藏 \r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('大雨') >= 0) {\r\n        //大雨气模块显示其他隐藏           \r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('雪') >= 0) {\r\n        //下雪天气模块显示其他隐藏            \r\n    }\r\n复制代码4.因为返回的接口数据有些是自己不想要的，或者想自己添加一些新的图片文字，所以将数据重新编写成对象数组的形式，最后渲染出来就可以了.例如下面这个模块let weather = []\r\nweather.push({\r\n    date: date,\r\n    week: res.data.result.weather[i].week, //星期\r\n    daywea: res.data.result.weather[i].info.day[1], //白天天气\r\n    daytemp: res.data.result.weather[i].info.day[2], //白天温度\r\n    daywind: daywind, //风向\r\n    daywindli: res.data.result.weather[i].info.day[4], //风力\r\n    nightwea: res.data.result.weather[i].info.night[1], //晚上天气\r\n    nighttemp: res.data.result.weather[i].info.night[2], //晚上温度\r\n})\r\nconsloe.log(weather)//打印结果\r\n//(5) [{…}, {…}, {…}, {…}, {…}]\r\n//0: {date: \"11-27\", week: \"三\", daywea: \"小雨\", daytemp: \"10\", daywind: \"西风\",\r\n        daywindli: \"4-5级\"，nighttemp: \"8\"，nightwea: \"小雨\"，week: \"三\"}\r\n//1: {date: \"11-28\", week: \"四\", daywea: \"多云\", daytemp: \"10\", daywind: \"西风\", …}\r\n//2: {date: \"11-29\", week: \"五\", daywea: \"阴\", daytemp: \"11\", daywind: \"东北风\", …}\r\n//3: {date: \"11-30\", week: \"六\", daywea: \"小雨\", daytemp: \"13\", daywind: \"无风\", …}\r\n//4: {date: \"12-01\", week: \"日\", daywea: \"阴\", daytemp: \"11\", daywind: \"西风\", …}\r\n复制代码先写到这里，如果有什么写的不好的地方，请大家多多包涵，之后会继续分享后面的内容。大家也可以提前扫码查看小程序，欢迎指出不足，谢谢" } { "title": "小程序包大小优化(uni-app) ", "author": "Rolan", "pub_time": "2019-11-28 00:24", "content": "在开发微信小程序的过程中，随着业务逻辑日渐庞大之后，突显了一些问题。首先我们发现在 dev mode 时，本地包大小已经达到了 4m+，这种情况下，已经无法在 dev mode 使用真机调试了。其次此时，小程序 build 后也有 1.8M 左右。而且后续还有相当多的业务需求需要开发，包大小肯定会更大。这时候就想要优化小程序包大小。下面分享一下我的定位过程和解决思路。尽管我们使用 uni-app 开发，但思路是通用的，希望能给大家一些帮助吧。如何减小包大小代码分析首先分析包大在哪儿了。打开本地代码目录查看文件大小。可以发现 common/vendor.js 和 page,components 中 js 占了大部分。在 build 编译模式下，代码压缩已经启用了，需要思考别的优化方式。这时候可以使用\twebpack-bundle-analyzer 插件\t。它可以帮助分析 vendor.js 中都有哪些 js 模块，哪些模块比较大，以便我们进一步优化代码通过这个插件，发现了下面两个问题。问题一: uni-app 自定义组件模式编译 tree shaking 无效如果不是使用 uni-app 开发可以跳过这一段通过代码分析发现有些模块应该被 tree shaking 但却被打包进来了。基本确定是 tree shaking 没有生效。同样是 webpack4 + babel7。在不使用 uni-app，直接使用 vue-cli create 项目的前提下，tree shaking 是没有问题的。而使用 uni-app 去新建项目，tree shaking 却无效。排查 babel 配置时发现是由于 uni-app 在创建项目的时候，设置了 modules: 'commonjs'导致。修改后，demo 的 tree shaking ok。但是回到项目里一编译，又出错了。继续定位发现是\tuni-app 自定义组件模式编译问题 。目前uni-app\t已经修复 了我提的bug，虽然还未正式发布。当然你不使用 uni-app 自定义组件模式编译也可以解决，uni-app 还支持\ttemplate模板模式 ，但是会有一些开发差异和性能差距，有兴趣可以看下\t这篇文章问题二：部分库不支持 tree shaking有些库(比如 lodash)本身并没有使用 import/export，所以 webpack 并不能对它们 tree shaking。这些库我们可以分情况优化。首先可以找下网上是否有库对应的 esm 版本可以替代，如 lodash-es。其次可以从代码分析中看出，如果库的每个模块都在不同文件中，入口文件只是一个统一入口，那么我们就可以通过修改写法按需加载，如import add from \"lodash/add\";\r\nimport Button from 'ant-design-vue/lib/button';\r\n复制代码我们也可以使用\tbabel-plugin-import 插件针对那些库统一实现按需加载，它的本质是在编译时统一按配置修改加载路径，不需要自己手动去修改代码。最后如果都不行，那要么接受，要么自己重写为社区做贡献~规范模块开发为了免除无法 tree shaking 的烦恼，我们在开发 npm 模块的时候也需要遵循一定的规范，从而减少模块打包后的大小。同时支持 commonjs 和 es module我们的模块需要同时支持 commonjs 和 es module。这样才能既满足 commonjs 开发的用户，又支持 tree shaking。如何实现呢？如果你的代码是 typescript,以@sentry/browser 为例，可以在编译时编译 cjs 和 esm 两种规范代码，如下// package.json\r\n\"build\": \"run-s build:dist build:esm build:bundle\",\r\n\"build:bundle\": \"rollup --config\",\r\n\"build:dist\": \"tsc -p tsconfig.build.json\",\r\n\"build:esm\": \"tsc -p tsconfig.esm.json\",\r\n复制代码然后在 package.json 中指定两个入口以及无副作用标识\"main\": \"dist/index.js\",\r\n  \"module\": \"esm/index.js\",\r\n  \"sideEffects\": false,\r\n复制代码这样当 webpack 解析模块(\t解析规则 )，就会按需优先解析 esm 目录。并且当识别到无副作用时进行 tree shaking。如果你的代码本身就是 es6，你也可以这样\"module\": \"src/index.js\",\r\n复制代码第三方自定义组件如果使用了第三方\t微信自定义组件 ，由于引用是在 json 文件，所以 webpack 在编译时并不能通过 entry 分析到相关文件，因此不会对其进行编译、压缩等。这时候就需要我们自己处理。而且由于 webpack 不处理，tree shaking 自然也无法支持，因此建议\t尽量避免 这种方式引用组件。分包小程序分包 也是一种常规的优化方案。通过分析后，可以将一些较大的页面划分为子包。如果有单页依赖第三方自定义组件，而且第三方组件还挺大，也可以考虑将该页面划分为子包。也因此\t尽量避免将第三方自定义组件放在 globalStyle ，不然没法将它放到子包去。大图不要打包小程序中的大图，尽量避免打包进来，应该放到 CDN 通过 url 加载。我们的做法是在开发时加载本地图片，在 CI/CD 环节自动化发布图片，并改写地址。如何解决真机调试问题首先还是查看编译后的文件，发现\tcommon/vendor.js 巨大，足有 1.5M。其次\tpages 和\tcomponents 也有 1.4M，而这其中占了 js 的大小又占了绝大部分。为什么 js 文件这么大呢？主要是因为在 dev mode 默认并没有压缩，当然也没有 tree shaking。我的选择是\t修改编译配置，在 dev mode 压缩 js 代码 。本地代码减少到了 2M。预览大小则是减少到了 1.4M。参考配置如下：// vue.config.js\r\n    configureWebpack: () => {\r\n        if (isDev && isMp) {\r\n            return {\r\n                optimization: {\r\n                    minimize: true,\r\n                },\r\n            }\r\n        }\r\n    }\r\n复制代码这看上去并不是个好方案，但确实简单有效。也考虑过分包，但分包并不能解决 common/vendor.js 巨大的问题，预览时包还是很大。如果有其它好的办法也欢迎留言~" } { "title": "记《高校考勤系统》小程序（2） ", "author": "Rolan", "pub_time": "2019-11-29 00:12", "content": "这是其他几篇的地址：记《高校考勤系统》小程序（1）前面讲了用户注册和首页天气功能，下面讲讲课程表页的实现.五.课程表页这里参考了简书上面 轩辕夜空 位作者的案例,以及其参考 极乐叔 的课程表的思路.同样制作课程表需要用到云开发来存储数据，以及结合云函数对数据的修改，后面会讲到为什么要用到云函数.先来看看完成后的效果图1.先搭建整体结构头部和左侧因为样式是一样的，可以将数据写入data中，再通过for循环渲染出来，这里就直接展示了.（偷个懒:blush::blush:）<!-- 星期 -->\r\n<view class=\"top\">  \r\n    <view class=\"top-text\">\r\n        <text>节\\日</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>一</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>二</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>三</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>四</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>五</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>六</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>日</text>\r\n    </view>\r\n</view>\r\n<!-- 课程 -->\r\n<view class=\"cont\">\r\n    <view class=\"cont-left\">\r\n        <view class=\"left\"> 1 </view>\r\n        <view class=\"left\"> 2 </view>\r\n        <view class=\"left\"> 3 </view>\r\n        <view class=\"left\"> 4 </view>\r\n        <view class=\"left\"> 5 </view>\r\n        <view class=\"left\"> 6 </view>\r\n        <view class=\"left\"> 7 </view>\r\n        <view class=\"left\"> 8 </view>\r\n    </view>\r\n    <view class=\"cont-right\">\r\n    </view>\r\n</view>\r\n<view class=\"bottom\">\r\n    ————<text>读万卷书 行万里路</text>————\r\n</view>\r\n复制代码点击查看wxss代码page {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n.top {\r\n    padding: 16rpx 0;\r\n    border-top: 1px solid #e9e9e9;\r\n    border-bottom: 1px dashed #d3d3d3;\r\n    display: flex;\r\n    justify-content: flex-start;\r\n}\r\n.top-text {\r\n    width: 12.5%;\r\n    text-align: center;\r\n    font-size: 32rpx;\r\n    font-weight: 600;\r\n    align-items: center;\r\n}\r\n.top .top-text {\r\n    border-left: 1px dashed #d3d3d3;\r\n}\r\n.top .top-text:nth-child(1) {\r\n    font-size: 24rpx;\r\n    border-left: none;\r\n    line-height: 46rpx;\r\n}\r\n.cont {\r\n    display: flex;\r\n    justify-content: start;\r\n}\r\n.cont-left {\r\n    display: inline-block;\r\n}\r\n.left {\r\n    width: 90rpx;\r\n    height: 120rpx;\r\n    justify-content: center;\r\n    display: flex;\r\n    align-items: center;\r\n    border-bottom: 1px dashed #d3d3d3;\r\n    box-sizing: border-box;\r\n    color: #666;\r\n    font-size: 28rpx;\r\n    font-weight: 600;\r\n}\r\n.cont-right {\r\n    width: calc(100% - 90rpx);\r\n}\r\n.bottom {\r\n    width: 100%;\r\n    text-align: center;\r\n    position: absolute;\r\n    bottom: 20rpx;\r\n    font-size: 24rpx;\r\n    color: #ddd;\r\n    display: inline-block;\r\n}\r\n.bottom text {\r\n    margin-left: 20rpx;\r\n    margin-right: 20rpx;\r\n    color: #9b9b9b;\r\n}\r\n复制代码2.结合云开发编写课程表.这里需要考虑到云开发中单次获取数据上限是20条，所以我将课程表数据分为两部分（上午和下午），当然你可以直接使用云函数来提高获取数据的上限，在后面会有介绍，这里就先不做过多的解释了，上代码.单个数据结构{\r\n    //\"_id\": \"296065c95da529b2055b57301b5afa75\",  云开发导入数据会直接生成_id,这里不用自己编写\r\n    \"data_name\": \"Java高级开发技术(JavaEE)\",  //课程名\r\n    \"address\": \"@康庄行知楼301\",              //地点\r\n    \"weekNum\": \"10-15周\",                     //周数\r\n    \"pitchNum\": \"3-4\",                        //节数\r\n    \"teacher\": \"赵老师\",                      //任课老师\r\n    \"_openid\": \"oQnNa5NJfKqSZntKFLGZWnZuXNbo\"  //修改者的openid,本来是想做判断，后面使用了云函数，发现可有可无\r\n}\r\n复制代码下面是从云开发数据库中获取我们编写好的课程表数据,如果对操作不熟悉可以查看 官方文档. 1.打开云开发控制台. 2.创建两个集合对应上午下午课程表. 3.导入我们已经编写好的数据 (一个星期早上和下午的课程分别为14节，所以导入数据时需要注意，如果想要当前课程没有信息，也是需要导入空的字段数据来占一格) . 4.打开权限管理. 5.选中第一个.其中最后两个步骤一定不能忘记！点击查看js代码data: {\r\n    colorArr: [\"rgb(229,188,76, 0.8)\", \"rgb(104,172,246, 0.8)\", \"rgb(183,135,242, 0.8)\", \"rgb(149,226,48, 0.8)\", \"#ff7070\",\r\n        \"#e54d42\", \"#0081ff\", \"#7DC67D\", \"#E17572\", \"#C35CFF\", \"#33BCBA\", \"#FF8533\", \"#6E6E6E\", \"#ebd4ef\",\r\n        \"#428BCA\", \"#39b54a\", \"#FF674F\", \"#e03997\", \"#00CED1\", \"#9F79EE\", \"#FFC125\", \"#32CD32\", \"#00BFFF\", \"#8799a3\",\"#FF69B4\"\r\n    ],\r\n    // 存储随机颜色\r\n    randomColorArr: [],\r\n    randomColorArr2: [],\r\n    i: 25,\r\n    random: '',\r\n    random2: '',\r\n},\r\nonLoad: function(options) {\r\n    this.data.randomColorArr = [] // 重置颜色数组1为空\r\n    this.data.randomColorArr2 = [] // 重置颜色数组2为空\r\n    const db = wx.cloud.database({\r\n        env: '*****'  //你的云开发环境名\r\n    })\r\n\r\n    //获取课程表上午数据\r\n    db.collection('数据集合中你的表名').get().then((res) => {\r\n        this.kechengbiao = res.data\r\n        for (let j = 0; j <= 13; j++) { //for循环判断课名和地名为空则不加颜色\r\n            if (this.kechengbiao[j].data_name == '' && this.kechengbiao[j].address == '') {\r\n                this.random = 'none'\r\n                this.data.randomColorArr.push(this.random)\r\n            } else {\r\n                this.random = this.data.colorArr[Math.floor(Math.random() * this.data.i)] //随机颜色\r\n                this.data.randomColorArr.push(this.random)\r\n            }\r\n        }\r\n        this.setData({\r\n            loding: true,\r\n            kechengbiao: this.kechengbiao,\r\n            randomColorArr: this.data.randomColorArr\r\n        })\r\n    })\r\n    //获取课程表下午\r\n    db.collection('数据集合中你的表名').get().then((res) => {\r\n        this.kechengbiao2 = res.data\r\n        for (let j = 0; j <= 13; j++) { //for循环判断课名和地名为空则不加颜色\r\n            if (this.kechengbiao2[j].data_name == '' && this.kechengbiao2[j].address == '') {\r\n                this.random2 = 'none'\r\n                this.data.randomColorArr2.push(this.random2)\r\n            } else {\r\n                this.random2 = this.data.colorArr[Math.floor(Math.random() * this.data.i)] //随机颜色\r\n                this.data.randomColorArr2.push(this.random2)\r\n            }\r\n        }\r\n        this.setData({\r\n            kechengbiao2: this.kechengbiao2,\r\n            randomColorArr2: this.data.randomColorArr2\r\n        })\r\n    })\r\n},\r\n复制代码<view class=\"cont-right\">\r\n    <view>\r\n        <view class='appointent-date'>  //上午\r\n            <view class=\"appointent-date-div\" bindtap=\"select_date\" wx:for=\"{{kechengbiao}}\" wx:key=\"{{index}}\" data-key='{{index}}' style=\"background-color:{{randomColorArr[index]}}\">\r\n                <view class=\"flex-item\" >\r\n                    <text class='data_name'>{{item.data_name}}</text>\r\n                    <text class='address'>{{item.address}}</text>\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class='appointent-date'>  //下午\r\n            <view class=\"appointent-date-div\" bindtap=\"select_date2\" wx:for=\"{{kechengbiao2}}\" wx:key=\"{{index}}\" data-key='{{index}}' style=\"background-color:{{randomColorArr2[index]}}\">\r\n                <view class=\"flex-item\">\r\n                    <text class='data_name'>{{item.data_name}}</text>\r\n                    <text class='address'>{{item.address}}</text>\r\n            </view>\r\n        </view>\r\n    </view>\r\n</view>\r\n复制代码点击查看wxss代码.appointent-date {\r\n    display: flex;\r\n    justify-content: space-around;\r\n    flex-wrap: wrap;\r\n}\r\n.appointent-date-div {\r\n    height: 236rpx;\r\n    border-radius: 10rpx;\r\n    margin-bottom: 6rpx;\r\n    color: white;\r\n}\r\n.flex-item {\r\n    display: flex;\r\n    justify-content: flex-start;\r\n    flex-direction: column;\r\n    width: 76rpx;\r\n    height: 212rpx;\r\n    font-size: 24rpx;\r\n    padding: 6rpx;\r\n    border: 1rpx solid transparent;\r\n    text-align: left;\r\n    border-radius: 10rpx;\r\n    cursor: pointer;\r\n    overflow: hidden;\r\n}\r\n.data_name {\r\n    display: inline-block;\r\n}\r\n.address {\r\n    display: inline-block;\r\n}\r\n复制代码3.对课程实现增删改查首先来做最简单的 查 吧，我们需要在for循环中加入 data-='{{index}}' ，如上代码所示:point_up_2:我加了data-key='{{index}}'，其中key可以自定义，目的是为了在点击课程时，可以获取相循环中对应的下标，这样我就可以在数据库中搜索到当前点击的数据并渲染出来.查//点击课程内容弹出详细框\r\nselect_date: function(e) {\r\n  this.id = e.currentTarget.dataset.key //获取当前点击课程的下标\r\n  const db = wx.cloud.database({\r\n    env: '****'\r\n  })\r\n  db.collection('***').get().then(res => {\r\n    console.log(res.data[this.id])   //获取点击时课程表数据\r\n  })\r\n},\r\n复制代码获取到数据后我们可以根据自己的需求渲染在页面上，这里我结合了vant的tab组件，左上角为返回，右上角为删除课程表信息，下面就讲 删 除课程信息.这里的删除不是说真的将数据从我们的数据库中删除，而是将数据赋值为“”也就是空值，这样就做到了删除的功能，在此结合 云函数 来实现，因为云开发中的操作权限无法满足我们对数据操作的要求.删首先我们在云函数中创建一个新的 云函数 ，修改index.js文件这里会有一个问题也就是为什么我们要使用云函数，而不直接用云开发对数据进行处理，是因为云开发中的操作权限只能对自己提交到数据库中的数据进行修改，如果是别人那么就无法修改.正常情况下，管理员肯定不止一位，所以对数据操作不能只限定一个人.//修改课程表\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init({\r\n    env: '***',//你的开发环境\r\n    traceUser: true\r\n})\r\nconst db = cloud.database();\r\nexports.main = async (event, context) => { // 云函数入口函数\r\n    try {\r\n        return await db.collection('***').doc(event.id).update({  //需要修改的数据库\r\n            data: {\r\n                data_name: event.data_name,\r\n                address: event.address,\r\n                weekNum: event.weekNum,\r\n                pitchNum: event.pitchNum,\r\n                teacher: event.teacher\r\n          },\r\n        })\r\n    } catch (e) {\r\n        console.error(e)\r\n    }\r\n    return {\r\n        event,\r\n        openid: wxContext.OPENID,\r\n        appid: wxContext.APPID,\r\n        unionid: wxContext.UNIONID,\r\n    }\r\n}\r\n复制代码然后在js文件中编写对应的代码tapDialogButton(e) { //从课表删除课程\r\n    wx.cloud.callFunction({\r\n        name: '***',// 你的云函数名称\r\n        data: {\r\n          id: this._id,  //将数据进行空值赋值\r\n          data_name: \"\",\r\n          address: \"\",\r\n          weekNum: \"\",\r\n          pitchNum: \"\",\r\n          teacher: \"\"\r\n        },\r\n        success: res => {\r\n          // 关闭当前点击课程详情\r\n        }\r\n    })\r\n},\r\n复制代码改，增做完了删其实对改和增的实现应该也变得相对简单，这里也是需要用到云函数，道理和上面讲的一致.在获取当前点击的数据时先将此条数据存储在data中，需要修改时，可以将数据赋值给input的value,在通过云函数来修改数据库中对应的数据.增也是同样的道理.这里就拿改为例.wxml<!-- 编辑页 -->\r\n<view class=\"edit\" hidden=\"{{ editShow }}\">\r\n    <van-nav-bar title=\"编辑课程\" right-text=\"完成\" left-arrow bind:click-left=\"editLeft\" bind:click-right=\"editRight\" />\r\n    <view class=\"label className\">\r\n        <text>课名</text>\r\n        <input  value=\"{{ nowClass.data_name }}\" bindinput=\"bindKeyInput1\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>教室</text>\r\n        <input  value=\"{{ nowClass.address }}\" bindinput=\"bindKeyInput2\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>周数</text>\r\n        <input  value=\"{{ nowClass.weekNum }}\" bindinput=\"bindKeyInput3\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>节数</text>\r\n        <input  value=\"{{ nowClass.pitchNum }}\" bindinput=\"bindKeyInput4\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>老师</text>\r\n        <input  value=\"{{ nowClass.teacher }}\" bindinput=\"bindKeyInput5\"></input>\r\n    </view>\r\n</view>\r\n复制代码新建修改课程表数据的云函数//修改课程表\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init({\r\n    env: '***',//你的开发环境\r\n    traceUser: true\r\n})\r\nconst db = cloud.database();\r\nexports.main = async (event, context) => { // 云函数入口函数\r\n    try {\r\n        return await db.collection('***').doc(event.id).update({  //你要操作的数据库\r\n            data: {\r\n                data_name: event.data_name,\r\n                address: event.address,\r\n                weekNum: event.weekNum,\r\n                pitchNum: event.pitchNum,\r\n                teacher: event.teacher\r\n            },\r\n        })\r\n    } catch (e) {\r\n        console.error(e)\r\n    }\r\n    return {\r\n        event,\r\n        openid: wxContext.OPENID,\r\n        appid: wxContext.APPID,\r\n        unionid: wxContext.UNIONID,\r\n    }\r\n}\r\n复制代码js//  1.首先获取输入框的值，存在data中\r\nbindKeyInput1(e) { //课名\r\n    this.editClassName = e.detail.value\r\n},\r\nbindKeyInput2(e) { //教室\r\n    this.editAddress = e.detail.value\r\n},\r\nbindKeyInput3(e) { //周数\r\n    this.editWeekNum = e.detail.value\r\n},\r\nbindKeyInput4(e) { //节数\r\n    this.editPitchNum = e.detail.value\r\n},\r\nbindKeyInput5(e) { //老师\r\n    this.editTeacher = e.detail.value\r\n},\r\neditRight() { //  2.编辑完成，点击提交按钮时将输入框的值赋值给对应的字段名\r\n  wx.cloud.callFunction({\r\n    name: '***',// 修改课程表数据的云函数名称\r\n    data: {\r\n      id: this._id,\r\n      data_name: this.editClassName,\r\n      address: this.editAddress,\r\n      weekNum: this.editWeekNum,\r\n      pitchNum: this.editPitchNum,\r\n      teacher: this.editTeacher\r\n    },\r\n    success: res => {\r\n    },\r\n    fail: console.error\r\n  })\r\n\r\n},\r\n复制代码到这里课程表功能就做完了，如果有什么不懂得地方欢迎留言，或者写的不好的地方，请大家指出一起探讨，之后会继续分享后面的内容。大家也可以提前扫码查看小程序，欢迎指出不足，谢谢" } { "title": "最近很火的 倒放挑战 - ReverseVoice (微信小程序版 前后端源码) Ts Node Taro ... ... ", "author": "Rolan", "pub_time": "2019-11-29 00:21", "content": "项目地址: https://github.com/smackgg/reversevoice整个项目其实很简单，从本人在抖音和 B 站看到火起来到最终小程序上线也就几天的下班时间就搞定了，11月16日上线至今用户量还是蛮多的(主要当时做的快此类 app 比较少)，现在已经出现了大量的更简约更好的倒放挑战 app，本项目开源仅供大家学习~拥抱 TypeScript ~顺便小声吐槽一下 Taro 对 Ts 的支持还是不够啊，希望大家多去给 Taro 提 dts 的 PR ~体验小程序二维码挑战分享海报 (这个海报暂时有问题，修复代码因为资质问题还没有提交审核)功能介绍/实现原理功能及实现原理简述小程序端用户录音并保存本地录音后将录音文件上传至后端进行倒放处理，并返回处理后的音频 url小程序端下载 url 文件，提示用户反转成功，将数据做本地 map用户点击分享，生成分享链接，并将该分享正放、倒放视频均传至后端保存至七牛云同时新建分享 room 保存用户信息，返回 roomId用户分享（海报分享 canvas 动态生成分享码海报）其它用户参加挑战，存储原理同 4，只是增加将挑战者信息了存入 room 的逻辑音频倒放使用 ffmpeg 进行音频倒放，核心代码：// 详见 ./server/src/controllers/file.ts => function reverseVoice\r\nimport ffmpegPath from '@ffmpeg-installer/ffmpeg'\r\nimport ffprobePath from '@ffprobe-installer/ffprobe'\r\nimport ffmpeg from 'fluent-ffmpeg'\r\nffmpeg.setFfprobePath(ffprobePath.path)\r\nffmpeg.setFfmpegPath(ffmpegPath.path)\r\n\r\nffmpeg(filepath)\r\n    .format('mp4')\r\n    // 反转\r\n    .outputOptions([\r\n      '-vf reverse',\r\n      '-af areverse',\r\n      '-preset',\r\n      'superfast',\r\n      '-y',\r\n    ])\r\n    .on('progress', (progress) => {\r\n      // send upload progress\r\n      console.log('upload-file-progress', progress.percent)\r\n    })\r\n    .on('error', (err) => {\r\n      console.log(`Ffmpeg has been killed${err.message}`)\r\n    })\r\n    .toFormat('mp3')\r\n    // 保存\r\n    .save(publicPath + saveFilePath)\r\n    .on('end', () => {\r\n      // 获取音频信息（时长等）\r\n      ffmpeg.ffprobe(publicPath + saveFilePath, (err, metadata) => {\r\n        console.log(metadata.format.duration)\r\n      })\r\n    })小程序录音小程序录音使用官方 api，详细逻辑见 ./wechatapp/pages/index/index.tsx录音海报生成利用 canvas 动态合成分享海报 /wechatapp/pages/sharePoster需要动态请求页面小程序码，涉及微信AccessToken鉴权等，详见 /server/src/controllers/wechat.ts, 下面贴出部分核心代码// 画图\r\nconst draw = async () => {\r\n  // 绘制之前 loading\r\n  Taro.showLoading({\r\n    title: '海报生成中...',\r\n    mask: true,\r\n  })\r\n  // 获取图片信息\r\n  const [productImgInfo, qrcodeImgInfo] = await Promise.all([\r\n    this.getImageInfo(sharePoster), // 获取主图\r\n    this.getQrImgInfo(), // 获取二维码图片\r\n  ])\r\n\r\n  // product image 宽高\r\n  const pW = CANVAS_WIDTH\r\n  const pH = (pW / productImgInfo.width) * productImgInfo.height\r\n\r\n  // canvas 高度\r\n  let canvasHeight = pH\r\n\r\n  const ctx = Taro.createCanvasContext('canvas', null)\r\n\r\n  ctx.fillStyle = '#fff'\r\n  ctx.fillRect(0, 0, CANVAS_WIDTH, canvasHeight)\r\n\r\n  // 绘制背景图片\r\n  ctx.drawImage(sharePoster, 0, 0, pW, pH)\r\n\r\n  // 绘制二维码 （因为有角度，需要旋转画布，再旋转回来）\r\n  ctx.rotate(-Math.PI / 32)\r\n  ctx.translate(-25 * ratio, 10 * ratio)\r\n  ctx.drawImage(qrcodeImgInfo.path, QR_LEFT, QR_TOP, QR_WIDTH, QR_WIDTH)\r\n  ctx.rotate(Math.PI / 32)\r\n  this.setState({\r\n    canvasStyle: {\r\n      ...this.state.canvasStyle,\r\n      height: canvasHeight,\r\n    },\r\n  })\r\n  ctx.stroke()\r\n  setTimeout(() => {\r\n    Taro.hideLoading()\r\n    ctx.draw()\r\n  }, 500)\r\n}微信分享 HOC 函数 ./wechatapp/components/@withShare// 微信小程序每个页面几乎都需要配置分享的参数，并且需要动态更改分享参数\r\n// 所以抽离 HOC 组件，方便页面使用\r\nimport { ComponentClass } from 'react'\r\n\r\nimport Taro from '@tarojs/taro'\r\nimport { connect } from '@tarojs/redux';\r\nimport defaultShareImg from '@/assets/images/share.png'\r\n\r\ntype Options = {\r\n  title?: string\r\n  imageUrl?: string\r\n  path?: string\r\n}\r\n\r\nconst defalutOptions: Options = {\r\n  title: '你能听懂我说啥么？最近很火的反转录音来啦~',\r\n  imageUrl: defaultShareImg,\r\n  path: 'pages/index/index',\r\n}\r\n\r\nfunction withShare() {\r\n  return function demoComponent(Component: ComponentClass) {\r\n    @connect(({ user }) => ({\r\n      userInfo: user.userInfo\r\n    }))\r\n    class WithShare extends Component {\r\n      $shareOptions?: Options\r\n      async componentWillMount() {\r\n        Taro.showShareMenu({\r\n          withShareTicket: true,\r\n        })\r\n\r\n        if (super.componentWillMount) {\r\n          super.componentWillMount()\r\n        }\r\n      }\r\n\r\n      // 点击分享的那一刻会进行调用\r\n      onShareAppMessage() {\r\n        // const sharePath = `${path}&shareFromUser=${userInfo.shareId}`\r\n        let options = defalutOptions\r\n        if (this.$shareOptions) {\r\n          options = {\r\n            ...defalutOptions,\r\n            ...this.$shareOptions,\r\n          }\r\n        }\r\n        return options\r\n      }\r\n\r\n      render() {\r\n        return super.render()\r\n      }\r\n    }\r\n\r\n    return WithShare\r\n  }\r\n}\r\n\r\nexport default withShare使用@withShare()\r\nclass Room extends Component {\r\n  /**\r\n * 指定config的类型声明为: Taro.Config\r\n *\r\n * 由于 typescript 对于 object 类型推导只能推出 Key 的基本类型\r\n * 对于像 navigationBarTextStyle: 'black' 这样的推导出的类型是 string\r\n * 提示和声明 navigationBarTextStyle: 'black' | 'white' 类型冲突, 需要显示声明类型\r\n */\r\n  config: Config = {\r\n    navigationBarTitleText: '首页',\r\n  }\r\n\r\n  $shareOptions = {\r\n    title: '倒放挑战！你能听懂我倒立洗头~',\r\n    path: 'pages/index/index',\r\n    imageUrl: '',\r\n  }\r\n\r\n  /**\r\n    ....\r\n  */\r\n}\r\n微信用户登录流程微信官方文档登录流程具体实现可以去看源码项目运行 - 后端准备需要提前安装:Install Node.jsInstall MongoDB开始克隆项目并进入后端目录cd server安装依赖npm install设置 mongoDB# create the db directory\r\nsudo mkdir -p /data/db\r\n# give the db correct read/write permissions\r\nsudo chmod 777 /data/db\r\n\r\n# starting from macOS 10.15 even the admin cannot create directory at root\r\n# so lets create the db diretory under the home directory.\r\nmkdir -p ~/data/db\r\n# user account has automatically read and write permissions for ~/data/db.启动 mongoDB (Start your mongoDB server (you'll probably want another command prompt)mongod\r\n\r\n# on macOS 10.15 or above the db directory is under home directory\r\nmongod --dbpath ~/data/db打包并运行项目npm run build\r\nnpm start项目运行 - 小程序端准备需要提前安装:Install 微信开发者工具开始克隆项目并进入小程序目录cd wechatapp安装依赖npm install新建 .env 文件在 wechatapp/src/utils 目录下克隆 env.example.ts 文件至同目录命名为 .env.ts 文件\r\n此文件两个参数分别代表本地开发和线上部署的请求地址运行项目npm run dev:weapp // development mode\r\n或者 npm run build:weapp // production mode微信开发者工具选择导入项目，并选择 wechatapp/dist 目录\r\n若本地开发，需要在开发者工具中设置开启“不校验合法域名“LicenseMIT" } { "title": "从0到1开发一个小程序cli脚手架（三） --自定义命令 ", "author": "Rolan", "pub_time": "2019-11-29 00:52", "content": "本文主要讲述关于如何实现自定义命令\r\ngithub地址：github.com/jinxuanzhen…\r\n觉得有用的朋友帮忙给项目一个star，谢谢\r\n\r\n系列内容，推荐从第一篇开始阅读：从0到1开发一个小程序cli脚手架（一）--创建页面/组件模版篇从0到1开发一个小程序cli脚手架（二） --版本发布/管理篇从0到1开发一个小程序cli脚手架（三） --自定义命令\r\n\r\n背景\r\n在写不同小程序的时候，突然发现每个小程序面临的场景和需求或多或少会有些差异化，比如说程序A会有生成doc的功能，程序B会有开启数据埋点的debug模式等等\r\n为了保证脚手架的通用性，我们并不能将这些差异化的功能一一实现，这时候就需要让用户实现自定义了\r\n\r\n准备工作\r\n最好看过之前的两篇文章并搭建过demo，里面有介绍一些项目的结构，实现思路，第三方包使用相关的东西\r\n\r\n开始\r\n\r\n梳理大概流程\r\n这里不多说了，老套路: config注册方法 -> 脚手架路由读取注册方法 -> 执行回调函数\r\n\r\n注册自定义命令\r\n既然是给开发者在实际项目中进行配置，那么自然在配置文件 xdk.config.js 文件中动手了，在配置文件中预留出一个口子，方便我们读取配置文件时获取json，因为开发者可能会注册多个自定义命令，我这里字段类型直接给的数组类型\r\n\r\n将字段customScripts配置好后，就开始配置自定义命令了，首先确定需要的属性\r\n\r\n[name], 命令名称肯定是要的\r\n[desc], 描述本质上可有可无，不影响功能，但是比较方便记忆\r\n[callback], 输入完命令之后要执行什么(回调函数主体)\r\n\r\n\r\n大概是这个样子，后续我会以生成sass文档为例来写一个自定义命令\r\n\r\n读取配置项\r\n回到xdk-cli这个项目，找到入口文件index.js，如果看过前面两篇文章，会知道首先要配置路由，这里调用第三方包commander来解析命令\r\n\r\n配置路由\r\n\r\n这里先看第一行，我用了前缀 run <cmd> 来解析，也就是说我们使用的时候必须输入xdk-cli run <cmd>，那么为什么不直接xdk-cli <cmd>呢？\r\n主要是为扩展考虑，避免命名重复导致功能被覆盖，而且自定义指令本质上只是xdk-cli脚手架诸多功能中的一项，放在第一层级实在有些不合时宜\r\n有些情况下，不太清楚当前项目下的自定义命令都有哪些，可以直接xdk-cli -h查看\r\n\r\n加装方法\r\n通过run 命令我们可以准确到达当前的action，接下来要做什么？\r\n自然是执行自定义命令的回调，在执行之前我们可以给他加装一系列方法，更利于去二次开发，我这里采用的是改变this指向的方法，将当前函数作用于绑定到originPrototype上\r\n\r\n\r\n方法库列表\r\n我这里道导出了封装好log的开启子进程方法，log方法，还有交互命令行方法，当然也可以导出更多，主要看自己的需求\r\n\r\n到这里为止，这样一套流程就跑通了，下面我写一个小例子\r\n\r\n案例：生成sass文档\r\n可以看到我调用的子进程，和日志都是通过接口公开出来已经在脚手架进行过统一处理的方法，并没有去多做事情\r\n当然你也可以使用交互命令，让自定义命令更加友好，例如：\r\n\r\n配合package.json\r\n可以在package.json的scripts里注册命令，简化我们的调用\r\n直接可以简写为npm start\r\n\r\n最后\r\n这篇比较简单，基本上只是针对回调方法做了包装与回传，目标是为了方便让开发者去定制一些功能\r\n到此为止，三篇文章下来整个小程序开发脚手架的大概逻辑和框架已经非常清晰明了，后续的话有可能会针对npm支持, 和npm包的开发模板进行更新，觉得有帮助的同学可以关注下~~" } { "title": "如何使用不到50行代码实现一个小而美的依赖收集库？ ", "author": "Rolan", "pub_time": "2019-12-2 00:02", "content": "现代web开发，大多数都遵循着视图与逻辑分离的开发原则，一反面使得代码更加易懂且易扩展，另一方面带来的问题就是如何优雅的管理数据。因而，社区诞生了很多优秀的状态管理库，比如为React而生的 Redux ，专为 Vue 服务的 Vuex ，还有不限定框架的 Mobx 等等。在为使用这些库提升开发效率而叫好的同时，我觉得我们也应该从内部去真正的了解它们的核心原理，就比如今天这篇文章的主题 依赖收集 ，就是其中的一个很大的核心知识。这篇文章将会带您一步一步的以最少的代码去实现一个小而美的依赖收集库，同时给您展现如何将这个库运用到小程序中去实现跨页面的状态共享。二 实现过程1. 基本原理依赖收集的基本原理可以概括为以下3步：创建一个可观察（observable）对象视图或者函数（effect）引用这个对象的某个属性，触发依赖收集改变数据，视图或者函数自动更新或运行我们要实现的例子：import { observable, observe } from \"micro-reaction\";\r\n\r\nconst ob = observable({\r\n    a: 1\r\n});\r\n\r\nobserve(() => console.log(ob.a));\r\n\r\n// logs: 1\r\n// logs: 2\r\nob.a = 2;\r\n复制代码下面开始我将一步一步的进行实现过程讲解2. 创建一个可观察对象首先，我们需要创建一个可观察对象，其本质就是将传入的对象进行代理，并且返回这个代理对象，这里我们使用 es6 的 Proxy 来修改对象的一些行为，从而实现在返回真正对象前作一些拦截操作。我们定义了一个名叫 observable 方法来代理对象，代码如下：export function observable(obj = {}) {\r\n    return createObservable(obj)\r\n}\r\n\r\nfunction createObservable(obj) {\r\n    const proxyObj = new Proxy(obj, handlers());\r\n    return proxyObj\r\n}\r\n复制代码可以看到 observable 方法内部就是通过 new Proxy（obj,handler） 生成一个代理对象，传参分别是原始对象和代理操作方法 handlers ， handlers 返回一个对象，定义了对象的原始方法，例如 get 、 set ，通过重新定义这两个方法，我们可以修改对象的行为，从而完成代理操作，我们来看看 handlers 方法。function handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            return result\r\n        },\r\n        set: (target, key, value, receiver) => {\r\n            const result = Reflect.set(target, key, value, receiver);\r\n            return result\r\n        }\r\n    }\r\n}\r\n复制代码如上，我们在 get 和 set 方法里面没有做任何操作，取值赋值操作都是原样返回。3. 关联副作用函数effect完成了对数据的初始定义，我们明确下我们的目的，我们的最终目的是数据改变，副作用函数 effect 自动运行，而这其中的关键就是必须有个地方引用我们创建的代理对象，从而触发代理对象内部的 get 或者 set 方法，方便我们在这两个方法内部做一些依赖收集和依赖执行的工作。因而，这里我们定义了一个 observe 方法，参数是一个 Function ，我们先看看这个方法的实现：export function observe(fn) {\r\n    <!--这一行可以先忽略，后面会有介绍-->\r\n    storeFns.push(fn);\r\n    <!--Reflect.apply()就相当于fn.call(this.arguments)-->\r\n    Reflect.apply(fn, this, arguments)\r\n}\r\n复制代码可以看到，内部执行了传入的函数，而我们传入的函数是 () => console.log(ob.a.b) ，函数执行，输出 ob.a ，引用了代理对象的 a 属性值，就触发了代理对象内部的 get 方法。 在 get方法内部我们就可以进行依赖收集。function handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            <!--触发依赖收集-->\r\n            depsCollect({ target, key })\r\n            return result\r\n        },\r\n        set: (target, key, value, receiver) => {\r\n            const result = Reflect.set(target, key, value, receiver);\r\n            return result\r\n        }\r\n    }\r\n}\r\n复制代码depsCollect 依赖收集方法需要做的操作就是将当前的依赖也就是 () => console.log(ob.a)这个函数 fn 保存起来，那 fn 怎么传过来呢？ get 方法本身的入参是没有这个 fn 的，回顾之前的 observe 方法，这个方法有传入 fn ，其中内部有个 storeFns.push(fn) 这样的操作，就是通过一个数组将当前依赖函数临时收集起来。可光收集没用，我们还要和对应的属性进行映射，以便后续某个属性变化时，我们能够找出对应的 effect ，故我们定义了一个 Map 对象来存储相应的映射关系，那需要怎样的一个映射关系呢？一个对象有多个属性，每个属性可能都有对应的 effect ，结构看起来应该是这样的：{\r\n    obj:{\r\n        \"key-1\":fn1,\r\n        \"key-2\":fn2,\r\n        ....\r\n    }\r\n}\r\n复制代码我们定义了一个全局变量 storeReactions 来存储整个映射关系，它的 key 是 obj ，就是原始对象， obj 的值也是个 Map 结构，存储了其属性和 effect 的映射关系。我们的最终目的其实也就是建立一个这样的关系。理清楚了数据存储，再来看看我们的 depsCollect 方法，其实就是将临时保存在 storeFns 里面的函数取出和属性 key 映射。// 存储依赖对象\r\nconst storeReactions = new WeakMap();\r\n// 中转数组，用来临时存储当前可观察对象的反应函数，完成收集之后立即释放\r\nconst storeFns = [];\r\nfunction depsCollect({ target, key }) {\r\n    const fn = storeFns[storeFns.length - 1];\r\n    if (fn) {\r\n        const mapReactions = storeReactions.get(target);\r\n        if (!mapReactions.get(key)) {\r\n            mapReactions.set(key, fn)\r\n        }\r\n    }\r\n}\r\n复制代码至此，我们的依赖收集算是完成了，接下来就是要实现如何监听数据改变，对应 effect 自动运行了。4. 数据变更，effect自动运行数据变更，就是重新设置数据，类似 a=2 的操作，就会触发代理对象里面的 set 方法，我们只需要在 set 方法里面取出对应的 effect 运行即可。set: (target, key, value, receiver) => {\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        executeReactions({ target, key })\r\n        return result\r\n    }\r\n    \r\nfunction executeReactions({ target, key }) {\r\n    <!-- 一时看不懂的，回顾下我们的映射关系 -->\r\n    const mapReactions = storeReactions.get(target);\r\n    if (mapReactions.has(key)) {\r\n        const reaction = mapReactions.get(key);\r\n        reaction();\r\n    }\r\n}\r\n复制代码ok，我们的例子的实现过程讲解完了，整个实现过程还是很清晰的，最后看看我们的整个代码，去掉空行不到50行代码。const storeReactions = new WeakMap(),storeFns = [];\r\n\r\nexport function observable(obj = {}) {\r\n  const proxyObj = new Proxy(obj, handlers());\r\n  storeReactions.set(obj, new Map());\r\n  return proxyObj\r\n}\r\n\r\nexport function observe(fn) {\r\n  if (storeFns.indexOf(fn) === -1) {\r\n    try {\r\n      storeFns.push(fn);\r\n      Reflect.apply(fn, this, arguments)\r\n    } finally {\r\n      storeFns.pop()\r\n    }\r\n  }\r\n}\r\n\r\nfunction handlers() {\r\n  return {\r\n    get: (target, key, receiver) => {\r\n      depsCollect({ target, key })\r\n      return Reflect.get(target, key, receiver)\r\n    },\r\n    set: (target, key, value, receiver) => {\r\n      Reflect.set(target, key, value, receiver)\r\n      executeReactions({ target, key })\r\n    }\r\n  }\r\n}\r\n\r\nfunction depsCollect({ target, key }) {\r\n  const fn = storeFns[storeFns.length - 1];\r\n  if (fn) {\r\n    const mapReactions = storeReactions.get(target);\r\n    if (!mapReactions.get(key)) {\r\n      mapReactions.set(key, fn)\r\n    }\r\n  }\r\n}\r\n\r\nfunction executeReactions({ target, key }) {\r\n  const mapReactions = storeReactions.get(target);\r\n  if (mapReactions.has(key)) {\r\n    const reaction = mapReactions.get(key);\r\n    reaction();\r\n  }\r\n}\r\n复制代码5. 多层级数据结构到目前为止，我们实现的还只能观察单级的对象，如果一个对象的层级深了，类似 ob.a.b 的结构，我们的库就无法观察数据的变动， effect 也不会自动运行。那如何支持呢？核心原理就是在 get 方法里面判断返回的值，如果返回的值是个对象，就递归调用 observable 方法，递归调用完，接着运行 observe 方法就会构建出完整的一个属性 key 和反应 effect 的映射关系。function handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            depsCollect({ target, key })\r\n            if (typeof result === 'object' && result != null && storeFns.length > 0) {\r\n                return observable(result)\r\n            }\r\n            return result\r\n        }\r\n    }\r\n}\r\n复制代码回到 ob.a.b 这样的结构，此时实际的代理对象应该是这样的 {proxy(proxy(c))} ，如果这个时候我们去修改数据，比如 ob.a.b = 2 这样。ob.a.b = 2 的运行过程会是怎样？要知道js这门语言是先编译后执行的，所以js引擎首先会去分析这段代码（编译阶段），先分析左边的表达式 ob.a.b ，故先会编译 ob.a ，触发了第一次 get 方法，在 get 方法中， result 得到的值是个对象，如果按照上述代码，又去重新观察这个对象，会导致 observe 方法中构建好的映射关系丢失，其中就是对象 {b:1} 中 key 为 b 对应的 fn 丢失，因为我们存储 fn 是在 observe 方法中执行的，那怎么办呢？方法是我们应该在第一次 observable 方法执行的时候，将每一个 key 对应的代理对象都保存起来，在赋值操作再一次触发 get 方法的时候，如果已经代理过，直接返回就行，不需要重新代理。// 存储代理对象\r\nconst storeProxys = new WeakMap();\r\nexport function observable(obj = {}) {\r\n    return storeProxys.get(obj) || createObservable(obj)\r\n}\r\nfunction createObservable(obj) {\r\n    const proxyObj = new Proxy(obj, handlers());\r\n    storeReactions.set(obj, new Map())\r\n    storeProxys.set(obj, proxyObj)\r\n    return proxyObj\r\n}\r\nfunction handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            depsCollect({ target, key })\r\n            <!--如果代理存储中有某个key对应的代理直接返回即可-->\r\n            const observableResult = storeProxys.get(result);\r\n            if (typeof result === 'object' && result != null && storeFns.length > 0) {\r\n                return observable(result)\r\n            }\r\n            return observableResult || result\r\n        }\r\n    }\r\n}\r\n复制代码如此， ob.a.b = 2 ，控制台就会依次输出 1 和 2 ，另外说一句，数组也是对象，故动态增加数组的值或者赋值操作都能触发响应的 effect 。const ob = observable({\r\n  a: {\r\n    b: 1,\r\n    c: []\r\n  }\r\n});\r\n\r\nobserve(() => console.log(ob.a.c.join(\", \")));\r\n//logs: 2\r\nob.a.c.push(2);\r\n复制代码三 如何结合小程序使用全部完整代码我已发布到我的github中，名字叫做 micro-reaction ，这个库完全无依赖的，纯粹的，故可以为其它界面框架状态管理提供能量，由于小程序跨页面状态共享相关的库不多，故这里以小程序举例，如何结合 micro-reaction 实现跨页面状态共享。1. 核心原理描述下场景，有两个页面 A 和 B ，全局数据 C ， A 和 B 都引用了 C ，之后，页面 A 中某个交互改变了 C ， A 和 B 都需要自动渲染页面。结合我们的库， C 肯定是需要 observable的， observe 方法传入的 fn 是会动态执行的，小程序渲染页面的方式是 setData 方法，故 observe 方法里面肯定执行了 setData() ，因而只要我们在 observe 方法里面引用 C ，就会触发依赖收集，从而在下次 C 改变之后， setData 方法重新运行渲染页面。2. 关键步骤首先，我们需要拿到每个小程序页面的 this 对象，以便自动渲染使用，故我们需要代理 Page方法里面传入的参数，我们定一个了 mapToData 方法来代理，代码如下：<!--全局数据-->\r\nimport homeStore from \"../../store\"\r\n<!--将数据映射到页面，同时出发依赖收集，保存页面栈对象-->\r\nimport { mapToData } from \"micro-reaction-miniprogram\"\r\nconst connect = mapToData((store) => ({ count: store.credits.count }), 'home')\r\n\r\nPage(connect({\r\n  onTap(e) {\r\n    homeStore.credits.count++\r\n  },\r\n  onJump(e) {\r\n    wx.navigateTo({\r\n      url: \"/pages/logs/logs\"\r\n    })\r\n  }\r\n}))\r\n复制代码mapToData 方法返回一个函数， function mapToData(fn,name){return function(pageOpt){}}，这里用到了闭包，外部函数为我们传入的函数，作用是将全局数据映射到我们的页面 data 中并触发依赖收集，内部函数传入的参数为小程序页面本身的参数，里面包含了小程序的生命周期方法，因而我们就可以在内部重写这些方法，并拿到当前页面对象并存储起来供下一次页面渲染使用。import { STORE_TREE } from \"./createStore\"\r\nimport { observe, observable } from 'micro-reaction';\r\n\r\nfunction mapToData(fn, name) {\r\n  return function (pageOpt) {\r\n    const { onLoad } = pageOpt;\r\n    pageOpt.onLoad = function (opt) {\r\n      const self = this\r\n      const dataFromStore = fn.call(self, STORE_TREE[name], opt)\r\n      self.setData(Object.assign({}, self.data, dataFromStore))\r\n\r\n      observe(() => {\r\n        <!--映射方法执行，触发依赖收集-->\r\n        const dataFromStore = fn.call(self, STORE_TREE[name], opt)\r\n        self.setData(Object.assign({}, self.data, dataFromStore))\r\n      })\r\n\r\n      onLoad && onLoad.call(self, opt)\r\n    }\r\n    return pageOpt\r\n  }\r\n}\r\n\r\nexport { mapToData, observable }\r\n复制代码然后，页面 A 改变了数据 C ， observe 方法参数 fn 自动执行，触发 this.setData 方法，从而页面重新渲染，完整代码点击 micro-reaction-miniprogram ，也可以点击查看 在线Demo。四 总结希望我的文章能够让您对依赖收集的认识更深，以及如何举一反三的学会使用，此外，最近在学习周爱民老师的《JavaScript核心原理解析》这门课程，其中有句话对我触动很深，引用的是金庸射雕英雄传里面的文本： 教而不得其法，学而不得其道 ，意思就是说，传授的人没有用对方法，学习的人就不会学懂，其实我自己对学习的方法也一直都很困惑，前端发展越来越快，什么 SSR ，什么 serverless ，什么 前端工程化 ，什么 搭建系统 各种知识概念越来越多，不知道该怎么学习，说不焦虑是不可能的，但坚信只有一个良好的基础，理解一些技术的本质，才能在快速发展的前端技术浪潮中，不至于被冲走，与局共勉！最后，在贴下文章提及的两个库，欢迎star试用，提pr，感谢~依赖收集库 micro-reaction小程序状态管理库 micro-reaction-miniprogram" } { "title": "小程序图像处理：图片配色分析 ", "author": "Rolan", "pub_time": "2019-12-2 00:10", "content": "背景\r\n小程序的canvas是微信基于原生组件自行封装的，因此接口跟web的canvas有不少区别，早期更是没有支持像素级的处理能力。\r\n在18年初的小程序基础库1.9.0版本更新中，出现了wx.canvasGetImageData和wx.canvasPutImageData两个重要的API，补全了像素处理能力，因此，小程序在客户端进行图片处理成为了可能。\r\n具体可以参考：\r\n偷偷迭代的重磅功能---小程序的像素处理能力\r\nwx.canvasGetImageData\r\n图片配色分析小程序：小色卡\r\n为了尝试小程序的图像处理能力，我做了个用于图片配色分析的小程序-小色卡。\r\n功能主要是：用户选择一张图片，程序会分析图片的配色，并把配色展示为一张色卡给用户。用户可以保存、编辑、复制自己的色卡。这个功能对初级的UI设计师有一定的帮助（可能吧...）。\r\n源码：github：mini-color-card\r\n体验小程序：\r\n\r\n原理\r\n小程序实现配色分析主要步骤如下：\r\n\r\n用户选择图片，拿到imgPath后绘制到canvas上。\r\n通过wx.canvasGetImageData这个接口读取图片数据\r\n对图片数据进行预处理，剔除alpha比较小并且不是白色的点。（非必要）\r\n对图片像素数据进行聚类。每个像素的颜色可以作为一个三维向量来看。\r\n\r\n基本逻辑如下：\r\nwx.chooseImage({\r\n  count: 1,\r\n  sizeType: ['original', 'compressed'],\r\n  sourceType: ['album', 'camera'],\r\n  success: (res) => {\r\n    wx.getImageInfo({\r\n      src: res.tempFilePaths[0],\r\n      success: (imgInfo) => {\r\n        let {\r\n          width,\r\n          height,\r\n          imgPath\r\n        } = imgInfo;\r\n        let ctx = wx.createCanvasContext(this.canvasID);\r\n        ctx.drawImage(imgPath,0,0,width,height);\r\n        ctx.draw(false,()=>{\r\n          wx.canvasGetImageData({\r\n            canvasId: this.canvasID,\r\n            x: 0,\r\n            y: 0,\r\n            width: width,\r\n            height: height,\r\n            success(res) {\r\n              var pixels = res.data;\r\n              var pixelCount = width*height;\r\n              var pixelArray = [];\r\n              // 对像素数据进行预处理\r\n              for (var i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\r\n                offset = i * 4;\r\n                r = pixels[offset + 0];\r\n                g = pixels[offset + 1];\r\n                b = pixels[offset + 2];\r\n                a = pixels[offset + 3];\r\n                if (a >= 125) {\r\n                  if (!(r > 250 && g > 250 && b > 250)) {\r\n                    pixelArray.push([r, g, b]);\r\n                  }\r\n                }\r\n              }\r\n              var cmap = MMCQ.quantize(pixelArray, colorCount);//聚类，MMCQ是个用于图像分析的库\r\n              var palette = cmap ? cmap.palette() : null;\r\n              console.log('配色为：',palette);\r\n            }\r\n          })\r\n        })\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码小结\r\n一开始我是不想把canvas显示出来的，只想用它获取图像内容，但是实践下来是不可行的。小程序的canvas并不允许离屏渲染，想要用它进行图片处理，就要老老实实用它进行展示。\r\n这里只实践了wx.canvasGetImageData读取数据进行图像分析，不过结合wx.canvasPutImageData，滤镜之类的图像处理应该都是可以做了。小程序的想象空间还是挺大的。" } { "title": "微信小程序把base64的图片保存到手机相册 ", "author": "Rolan", "pub_time": "2019-12-2 00:17", "content": "var file = wx.getFileSystemManager();\r\nconsole.log('1')\r\nfile.writeFile({\r\n    //读写文件路径filePath需要使用wx.env.USER_DATA_PATH + '/tmp.txt'才可以读写成功。\r\n    filePath:  wx.env.USER_DATA_PATH + '/poster.png',\r\n    data: self.preurl.slice(22),\r\n    encoding:'base64',\r\n    success:async()=>{\r\n        console.log('123')\r\n        const res2 = await wepy.saveImageToPhotosAlbum({\r\n            filePath: wx.env.USER_DATA_PATH + '/poster.png'\r\n        })\r\n        wepy.$toast('图片已保存到相册，赶紧晒一下吧~')\r\n        self.isShow = false\r\n        self.$apply();\r\n    },\r\n    fail:function(e){\r\n        console.log(e)\r\n    }\r\n})wx.getFileSystemManager()  是获取文件管理器对象；aa.writeFile  是写文件，详细参数可\t点击查看 官方文档说明。String wx.env.USER_DATA_PATH文件系统中的用户目录路径wx.env.USER_DATA_PATH +'/test.png'  这里是创建一个临时文件的文件名。that.data.scene.slice(22)   这里是把 data:image/png;base64这一段去除，需要注意的是去除这一段之后 base64 编码之间放到image组件的src里面是不能显示图片的。" } { "title": "闲鱼前端基于 serverless 的一种多端开发解决方案 ", "author": "Rolan", "pub_time": "2019-11-18 00:27", "content": "背景前端的发展太快了，前端框架和技术的发展也层出不穷，还包括不同智能设备的出现，对前端开发同学来说是个很大的跳转，简单列举下：前端框架：vue、react、angular小程序：微信小程序、支付宝小程序、字节跳动小程序智能设备：苹果设备、天猫精灵、小度这样就滋生了一些问题，比如我要开发一个通用的页面，兼容不同的端侧和小程序，显然目前是做不到的，我们只能开发多套页面去适配不同的场景，这样的话成本就太高了。很多同学都在尝试解决这个问题，也催生了类似 taro 这样的多端统一开发框架，这是一个好的解决方案，但是比较被动，缺乏一定的扩展性。这篇文章我们要探讨的是，看能不能换个角度去解决这个问题，提升开发效率。ViewModel当我们在开发一个页面的时候，不管用的是哪一种框架，通常都会抽象出一层 viewmodel 层，它主要有 2 个作用和服务端进行交互，接受后台返回的数据，进行加工并传递给 view 层渲染接受 view 层的回调，加工数据并返回给 view 层渲染从上图中我们可以看出，viewmodel 是一段独立的通用代码逻辑，起到了承前启后的作用。它和 view 层关系更加紧密，因此通常会放在前端测。既然 viewmodel 是独立的，那我们能不能把它放在后端呢？这样一个最大的好处就是 viewmodel 可以进行复用，不需要在重复编写，而且只需要改动一个 viewmodel，就可以全量生效。似乎是一个很美好的想法，但是这部分代码由谁去开发呢，总不可能寄希望于后端同学吧，当然只能是我们自己，也感谢于 serverless 架构的出现，让这件事情变成了可能。有些同学可能会问，既然 viewmodel 后移了，那 view 呢？后续会考虑结合我们的 ui2code 技术，那真的就比较完美了。什么是 serverless我们先简单介绍一下什么是 serverless，serverless 的基础是云技术，它是云技术发展到一定阶段而出现的一种革命性的高端架构。serverless 并不是说不需要服务器，而是指不需要开发者去关心底层服务器的状态、资源和扩容等，开发者只需要关注于业务逻辑实现。架构上，我们可以把 serverless 分为 FaaS 和 BaaS。FaaS 是用于创建、运行、管理函数服务的计算平台，它支持多种开发语言，比如 java、nodejs、dart 等，这有利于不同端侧的开发同学介入开发。FaaS 是基于事件驱动的思想，只有当一个函数被事件触发时才会占用服务器资源执行，不然都是无需占用服务器资源的。BaaS 提供了用于函数调用的第三方基础服务，比如身份校验、日志、数据库等，它是由服务商直接提供，开发者无需关系实现，直接调用即可。业务落地我们是通过 gaia 平台 开发后端接口，gaia 可以理解为上文提到的 FaaS 平台。日常开发中有这样一个需求，下面是这个需求的一个页面。因为这个页面上的数据比较多，先把它切分成一个个小的模块，后台返回数据的时候也根据模块来返回数据。我们是根据 viewmodel 来设计接口，首先肯定有一个首屏数据接口；然后是页面上的交互，比如切换卡片、切换芝麻信用按钮，切换会引起页面数据变化，我们可以统一封装一个页面更新的接口；最后是一个开通的接口。后端接口前后端交互最重要的数据结构的设计，我们省略了中间的业务逻辑处理，看下接口的数据结构。首屏接口返回的数据主要有几个特征：根据前端的页面模块定义返回结构字段的颗粒度很细，页面上的每个元素都对应一个字段值有两个字段来控制模块的显示和刷新更新接口的返回数据结构和首屏接口类似，但是入参有所不同，主要包括 2 个字段：data：当前页面的数据，为了避免数据的重复获取action: 定义的页面操作前端处理从后端返回的数据可以看到，数据是及其详细的，无需我们做任何的业务逻辑处理，直接映射到页面即可。这样，前端已经变成了很薄的一层数据，没有任务的业务逻辑处理，变的很简单，当需要迁移到其他端时，只需要迁移视图层即可。当有任何的业务变动时，只需要修改后端的接口，就能生效。收益与总结通过具体的实践，我们发现，对于前端开发同学来说，变的简单了，开发效率有很大的提升，前端同学甚至都不需要去理解具体的业务逻辑，就能完成页面的开发。而且，提取的 viewmodel 可以复用到不同的端侧，设置还包括 native 端。我们还可以将 viewmodel 拆分成更小粒度的 viewmodel，方便在不同的页面接口中进行复用。我们有同学还在 FaaS 侧基于 redux 的思想封装了一个通用的状态管理框架，规范了前后端的交互。后面， 还有一些问题待我们去解决，比如开发成本、viewmodel 的逻辑拆分、具体接口问题定位等。本文转载自公众号闲鱼技术（ID：XYtech_Alibaba）。原文链接：https://mp.weixin.qq.com/s/VLsVTe4ZyOJ9rNyVf5aXyg" } { "title": "小程序 swiper 如何多页面高度自适应 ", "author": "Rolan", "pub_time": "2019-11-18 00:40", "content": "轮播，这个概念只要做过 UI 的都不会陌生，盲猜市场上 90% 的应用都有这个需求，在 iOS 和 Android 上都有很完善的控件，比如 Android 的 ViewPager 和 iOS 的 UIScrollview。\r\n\r\n小程序这么牛逼，肯定也要有控件支持这个特性啊， swiper 就这么诞生了。\r\n但是 swiper 有一个很严重的问题，就是高度默认 150px，且不可以自适应内容调整高度。\r\n这就有问题了，我现在有一个多 Tab 的页面，最少高度要满屏，还要超出内容可以往下滚动，此时就蒙蔽了，怎么给 swiper 设置高度呢？\r\n首先看一下我搜索到的一些方法：\r\n\r\n\r\n在初始化的时候获取到屏幕的高度，然后将高度设置到 swiper 上，至于滚动的问题，在里面再嵌入一个 scroll-view\r\n这个问题有很多坑，首先 屏幕的高度要比内容区的高度大，这么设置以后就算内容较少，页面也能滑动一点；其次，小程序的 scroll-view 在实现上拉加载更多的时候，坑更多。\r\n\r\n\r\n每个 item 的高度都一致，根据 item 的数量和统一的高度计算出内容的高度，然后设置进去\r\n这个方案感觉完全是 zz 方案，局限性太大了\r\n\r\n\r\n我的方案\r\n\r\n一句话解释：给 swiper-item 内部添加三个锚点，最上面一个，最下面一个，还有一个锚点始终位于屏幕最底下。根据这三个锚点计算出内容高度和内容显示区高度。\r\nPS：锚点，宽高为 0 的不可见的 view，用于获取定位\r\n\r\n如果还有不理解可以看下面这个示意图：\r\n\r\n这三个锚点的具体作用是用来计算 swiper 内容高度和 swiper 距离屏幕底部的具体，计算方式如下：\r\n\r\n使用 swiper-item 内部的两个锚点计算出内容区高度\r\n通过屏幕底部和 swiper-item 顶部的锚点计算出离屏幕底部的距离\r\n\r\n接下来看看代码具体实现\r\n代码实现\r\npage.wxml\r\n<view>\r\n\t<swiper style=\"height: {{anchor.deviceHeight + 'px'}}\">\r\n\t\t<swiper-item>\r\n\t\t\t<view class=\"anchor-top\"></view>\r\n\t\t\t<!-- 你的内容 -->\r\n\t\t\t<view class=\"anchor-bottom\"></view>\r\n\t\t</swiper-item>\r\n\t</swiper>\r\n\t<view class=\"anchor-screen-bottom\"></view>\r\n</view>\r\n复制代码\r\npage.wxss\r\n.anchor-top {\r\n    width: 0;\r\n    height: 0;\r\n}\r\n\r\n.anchor-bottom {\r\n    width: 0;\r\n    height: 0;\r\n}\r\n\r\n.anchor-screen-bottom {\r\n    position: absolute;\r\n    bottom: 0;\r\n    width: 0;\r\n    height: 0;\r\n}\r\n复制代码\r\npage.js\r\nPage({\r\n\tdata: {\r\n\t\tanchor: {\r\n\t\t\tdeviceHeight: 0,\r\n      anchorTop: 0,\r\n      anchorBottom: 0,\r\n      anchorScreenBottom: 0\r\n\t\t}\r\n\t},\r\n\tonReady: function() {\r\n\t\tthis.computeSwiperHeight(0)\r\n\t},\r\n\tcomputeSwiperHeight(pageIndex) {\r\n\t  let getSwiperHeight = () => {\r\n      let min = this.data.anchor.anchorScreenBottom - this.data.anchor.anchorTop;\r\n      let value = this.data.anchor.anchorBottom - this.data.anchor.anchorTop\r\n      return Math.max(min, value)\r\n\t  }\r\n\t  wx.createSelectorQuery()\r\n      .select('.anchor-screen-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorScreenBottom = res[0].bottom\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-top')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorTop = res[0].top\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorBottom = res[0].bottom\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t},\r\n})\r\n复制代码\r\n适配多页面\r\n当然，肯定要适配每个页面的高度不一样的情况。方案也很简单，屏幕底部的锚只需要一个了，给每个 swiper-item 的都添加两个锚点，和之前一样一个在上面一个在下面，在切换页面的时候，根据当前页面的锚点重新计算一下高度，然后设置进去。\r\n只需要在原有基础上改一下代码：\r\npage.wxml\r\n<view>\r\n\t<swiper style=\"height: {{anchor.deviceHeight + 'px'}}\" bindchange=\"swiperChange\">\r\n\t\t<swiper-item>\r\n\t\t\t<view class=\"anchor-top\"></view>\r\n\t\t\t<!-- 你的内容 -->\r\n\t\t\t<view class=\"anchor-bottom\"></view>\r\n\t\t</swiper-item>\r\n\t\t<swiper-item>\r\n\t\t\t<view class=\"anchor-top\"></view>\r\n\t\t\t<!-- 你的内容 -->\r\n\t\t\t<view class=\"anchor-bottom\"></view>\r\n\t\t</swiper-item>\r\n\t</swiper>\r\n\t<view class=\"anchor-screen-bottom\"></view>\r\n</view>\r\n复制代码\r\npage.wxss\r\nCSS 不需要改动\r\npage.js\r\nPage({\r\n\tdata: {\r\n\t\tanchor: {\r\n\t\t\tdeviceHeight: 0,\r\n      anchorTop: 0,\r\n      anchorBottom: 0,\r\n      anchorScreenBottom: 0\r\n\t\t}\r\n\t},\r\n\tonReady: function() {\r\n\t\tthis.computeSwiperHeight(0)\r\n\t},\r\n\tswiperChange(e) {\r\n    this.computeSwiperHeight(e.detail.current)\r\n  },\r\n\tcomputeSwiperHeight(pageIndex) {\r\n\t  let getSwiperHeight = () => {\r\n      let min = this.data.anchor.anchorScreenBottom - this.data.anchor.anchorTop;\r\n      let value = this.data.anchor.anchorBottom - this.data.anchor.anchorTop\r\n      return Math.max(min, value)\r\n\t  }\r\n\t  wx.createSelectorQuery()\r\n      .select('.anchor-screen-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorScreenBottom = res[0].bottom\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-top')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorTop = res[0][pageIndex].top\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorBottom = res[0][pageIndex].bottom\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t},\r\n})\r\n复制代码\r\n实现效果\r\n\r\nswiper 的高度高度根据内容自适应\r\nswiper 的高度最小占满屏幕，最大和内容一样高（为了用户滑动体验（如果划页后高度突然变小，用户在原来的位置就划不回去了）\r\n适配不同高度的页面\r\n\r\n这个方案是了实现为自己的需求而写的，应该不适应全部的场景，不过希望可以为你提供一点思路。\r\n感想\r\n小程序里的坑真的很多，而且有些 API 设计的很奇怪，真的不知道当初开发人员怀着怎样的心路历程设计出的 API。\r\n个人感觉小程序就是给前端新造了一个轮子，更新还很不及时，有很多陈年老 Bug，比如本文讲的 swiper。\r\n前端娱乐圈发展这么快，感觉小程序可能会跟不上潮流。\r\n最后\r\n给我正在开发的小程序预热一下～\r\n\r\n欢迎关注～" } { "title": "云开发如何实现管理员通知消息 ", "author": "Rolan", "pub_time": "2019-11-19 00:03", "content": "需求描述小程序目前的主要能力还都在小程序端实现，但是我们在进行开发的小程序不可能只有小程序端能力，我们也会有一些管理端能力。比如说，当用户在小程序中提交了消息以后，我们的小程序应该可以通知到小程序的管理员，以便让管理员进行下一步操作。解决方案架构说明由于小程序本身不支持长久性的消息通知能力，因此，我们可以考虑借助一些第三方的服务和能力，来完成我们自己的需求。这个需求很适合使用小程序新发布的 长期订阅消息 能力，但是目前该能力开放的类目还不足以支持我们的需要。一般而言，使用短信是我们目前到达率比较高的能力，且更为普遍的能力，其他通道的能力大多受限或不符合国情，为了确保通知信息的到达率，我们这篇文章就使用短信来完成需求。架构图示具体操作1. 开通腾讯云短信服务并获取配置信息我们想要发送短信，就需要先有一个短信服务，用于发送短信，这里我们可以使用腾讯云提供的云短信服务来发送短信。开通腾讯云短信，并创建应用首先，你需要访问 https://console.cloud.tencent... ,点击开通腾讯云·云短信。在开通完成后，点击界面中的【 添加应用 】，添加一个新的短信应用，你可以根据自己的实际情况，添加短信应用的名称和简介。获取 AppID、App Key添加完成后，点击你创建好的应用，进入到应用详情页,在应用的详情页中的应用信息栏目中，你可以找到 AppID 和 AppKey ，复制并保存这两个值，稍候我们会用到。2. 配置短信模板、短信签名开通了腾讯云短信服务以后，我们需要去创建短信模板，以及短信签名短信签名则是原来让收到短信的用户知道他所收到的短信来自于他的那一个服务，一般来说，设置为产品的品名。在腾讯云控制台中，进入到【云短信】控制台创建短信签名首先，点击【 国内短信 】，进入到短信的页面，点击【 创建签名 】，然后在弹出的窗口中输入你的签名的具体信息，比如这里我就是以公众号【程序百晓生】来创建签名。签名创建完成后，你需要等待腾讯云官方的审核，审核通过以后，你添加的签名才可以被使用。创建短信模板创建完签名，你需要创建一个短信的正文模板，用于发送短信。输入模板名称、短信类型，然后选择标准模板中的模板，这里我们选择“您有新的{1}订单，请注意查收！”这个模板。除了使用标准模板，你也可以自己编写一个模板，为了方便文章撰写，这里使用标准模板。然后点击提交，等待审核就可以了。3.编写云函数发送短信在完成了基础的配置后，我们在微信开发者工具中实现一个云函数，用于调用腾讯云的短信服务，实现具体的通知。首先，我们创建一个新的云函数，名为 notifyAdmin ，意为用于通知管理员的云函数。然后，选择我们刚刚创建的 notifyAdmin 云函数，在函数上右击，选择【在终端中打开】，进入到控制台，并输入如下命令，安装所需的短信 SDK。npm install --save sms-node-sdk然后，修改云函数的 index.js ，加入如下代码// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\nconst {\r\n  SmsClient\r\n} = require('sms-node-sdk');\r\n\r\n\r\nconst AppID = 1400286810;  // SDK AppID是1400开头\r\n\r\n// 短信应用SDK AppKey ，替换为你自己的 AppKey\r\nconst AppKey = 'xxxx';\r\n\r\n// 需要发送短信的手机号码\r\nconst phoneNumber = '10000000';\r\n\r\n// 短信模板ID，需要在短信应用中申请\r\nconst templId = 476457;\r\n// 签名，替换为你自己申请的签名\r\nconst smsSign = '程序百晓生';\r\n\r\n// 实例化smsClient\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  let orderId = event.orderId;\r\n  let smsClient = new SmsClient({ AppID, AppKey });\r\n  return await smsClient.init({\r\n    action: 'SmsSingleSendTemplate',\r\n    data: {\r\n      nationCode: '86',\r\n      phoneNumber,\r\n      templId: templId,\r\n      params: [orderId],\r\n      sign: smsSign // 签名参数未提供或者为空时，会使用默认签名发送短信\r\n    }\r\n  })\r\n}完成代码的修改后，就可以部署你的云函数了，右键你的云函数，选择【上传并部署云函数：云端安装依赖】4. 在小程序端触发短信在前面我们提到，在一些特定的场景下，我们希望用户的操作可以给管理员发送消息通知。在具体的实现的时候，我们可以根据自己的实际业务需求，来设定我们的通知发送的条件，比如说，在用户支付成功后发送消息，则相关代码如下：let orderId = 'this is a orderId';\r\nwx.requestPayment({\r\n    success:res => {\r\n        console.log(\"User Payment Success\");\r\n        // 调用云函数发送短信\r\n        wx.cloud.callFunction({\r\n            name:\"notifyAdmin\",\r\n            data:{\r\n                orderId: orderId\r\n            }\r\n        });\r\n    }\r\n})总结经过本次的分享，我们了解到了如何借助短信服务，实现云开发的后台通知能力，实际上，除了短信服务，你还可以借助一些其他的工具，比如邮件、企业微信机器人等能力，实现后台管理信息的推送。明天，我们将分享 如何借助通过微信发送订单消息 。" } { "title": "简单说说微信小程序的底层原理 ", "author": "Rolan", "pub_time": "2019-11-19 00:12", "content": "小程序选择了 Hybrid 的渲染方式，将UI渲染跟 JavaScript 的脚本执行分在了两个线程。双线程模型小程序的渲染层和逻辑层分别由两个线程管理：渲染层：界面渲染相关的任务全都在\tWebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个\tWebView 线程。逻辑层：采用\tJsCore 线程运行JS脚本，在这个环境下执行的都是有关小程序业务逻辑的代码。双线程之间的通信我们都知道小程序是避免DOM操作，而是采用数据驱动来渲染页面的，那么他到底是怎么通过更改数据来更新DOM呢。逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。在渲染层会把WNML转化成Js对象，Js对象会模拟DOM树逻辑层更新数据的时候，通过setData方法将数据从逻辑层转发到Native,Native再转发到渲染层这时候，比较两虚拟DOM树的差异，最后将差异应用到真实DOM树上，更新页面。Virtual DOM 相信大家都已有了解，大概是这么个过程：用JS对象模拟DOM树 -> 比较两棵虚拟DOM树的差异 -> 把差异应用到真正的DOM树上。小程序的生命周期小程序的生命周期借鉴了Android的生命周期，如果你了解过Android的APP开发，那么理解小程序的就会很简单。界面线程有四大状态：初始化状态：初始化界面线程所需要的工作，包括工作机制，基本和我们开发者没有关系，等初始化完毕就向“服务线程”发送初始化完毕信号，然后进入等待传回初始化数据状态。首次渲染状态：收到“服务线程”发来的初始化数据后（就是 json和js中的data数据），就开始渲染小程序界面，渲染完毕后，发送“首次渲染完毕信号”给服务线程，并将页面展示给用户。持续渲染状态：此时界面线程继续一直等待“服务线程”通过this.setdata（）函数发送来的界面数据，只要收到就重新局部渲染，也因此只要更新数据并发送信号，界面就自动更新。结束状态：结束渲染。服务线程五大状态：初始化状态：无需和其他模块交流，跟小程序开发也没多大关联，此阶段就是启动服务线程所需的基本功能，比如信号发送模块。系统的初始化工作完毕，就调用自定义的onload和onshow， 然后等待界面线程的“界面线程初始化完成”信号。onload是只会首次渲染的时候执行一次，onshow是每次界面切换都会执行，简单理解，这就是唯一差别。等待激活状态：接收到“界面线程初始化完成”信号后，将初始化数据发送给“界面线程”，等待界面线程完成初次渲染。激活状态：收到界面线程发送来的“首次渲染完成”信号后，就进入激活状态既程序的正常运行状态，并调用自定义的onReady()函数。此状态下就可以通过 this.setData 函数发送界面数据给界面线程进行局部渲染，更新页面。后台运行状态：如果界面进入后台，服务线程就进入后台运行状态，从目前的官方解读来说，这个状态挺奇怪的，和激活状态是相同的，也可以通过setdata函数更新界面的。毕竟小程序的框架刚推出，应该后续会有很大不同吧。运行机制启动热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。销毁只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。更新机制开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。所以如果想让用户使用最新版本的小程序，可以利用\twx.getUpdateManager 做个检查更新的功能。" } { "title": "使用Taro小程序框架开发一个学习做题聊天交流的微信小程序 ", "author": "Rolan", "pub_time": "2019-11-19 00:41", "content": "项目介绍当代大学生上课缺少积极性，学习缺乏效率。同为大学生的我深有体会。所以特别开发出这样一款学习类的微信小程序帮助学生进行学习、巩固知识，同时增加对战PK模块来加强学生们的学习积极性。这是一个为学生提供在线学习课程、题库练习、考试答题、做题PK、上课签到、资料查阅、成绩分析等功能的微信小程序希望大佬们走过路过给个star~技术选型前端：Taro + 微信小程序 + Echarts后端：Node.js + MySql + websocket其他：七牛云存储项目功能在线学习课程专项题库练习课程考试答题知识趣味竞赛上课签到系统专业资料查阅学生成绩分析运行截图1. 主页2. 个人中心3. 课程详情4. 做题练习5. 学习交流群6. 聊天室7. 课程列表8. 习题列表9. 排行榜10. 论坛项目分析项目采用前后端分离的技术，前端采用了Taro微信小程序框架，因为本人比较喜欢React，所以采用了Taro这款类React语法的框架，后端则采用了Node.js,koa2框架。聊天室页面采用websocket来进行连接今天，我们首先来聊一聊聊天室使用的小技巧（并不）首先我们的后端数据库采用的是mysql，我们建了一个聊天记录的表（萌新勿喷~）1. 后端部分数据库部分我们将所有的聊天记录存放到一张表上方便管理，因为我们有多个聊天群组，我们该如何区分这些不同的聊天群组呢？答案是，通过room_name来区分，获取聊天记录的时候就直接查询这个群组名即可，这样就不用开很多的表，将不同的群聊记录存放到不同的表中啦！同时因为我们的聊天记录内需要存储emoji等信息，所以，我们需要将数据库的字符集调整为 utf8mb4 -- UTF-8 Unicode ，排序规则选择 utf8mb4_unicode_ci ，这个可以通过自行百度，或者navicat中设置。然后我们将数据表以及字段类型也设置为 utf8mb4 ，便于存储emoji信息后端处理聊天记录的方法。router.get('/chatlog/:to', async (ctx) => {\r\n  const to = ctx.params.to\r\n  const response = []\r\n  const res = await query(`SELECT * FROM chatlog WHERE room_name = '${to}' ORDER BY current_time DESC`);\r\n  res.map((item, index) => {\r\n    const { room_name, user_name, user_avatar, current_time, message } = item\r\n    response[index] = {\r\n      to: room_name,\r\n      userName: user_name,\r\n      userAvatar: user_avatar,\r\n      currentTime: formatTime(current_time),\r\n      message,\r\n      messageId: `msg${current_time}${Math.ceil(Math.random() * 100)}`\r\n    }\r\n  })\r\n  ctx.response.body = parse(response)\r\n})这是获取指定群聊的后端接口，to代表的是群组名，使用get的方法即可获取到指定群聊的聊天记录啦！继续聊聊我们如何为所有连接到聊天室的网友们发送信息，这里我们采用的是广播的方式，不同于socket.io内已经封装好广播的方法，小程序规定只能使用websocket，所以我粗略的封装了一下广播（十分丑陋的代码）let onlineUserSocket = {}\r\nlet onlineUserInfo = {}\r\n\r\nconst handleLogin = (ws, socketMessage) => {\r\n  const { socketId, userName, userAvatar } = socketMessage\r\n  onlineUserSocket[socketId] = ws\r\n  onlineUserInfo[socketId] = { userName, userAvatar }\r\n  ws.socketId = socketId\r\n}\r\n\r\n// 广播消息\r\nconst broadcast = (message) => {\r\n  const { from, userName } = message\r\n  Object.values(onlineUserSocket).forEach((socket) => {\r\n    socket.send(JSON.stringify({\r\n      ...message,\r\n      isMyself: userName === onlineUserInfo[socket.socketId].userName\r\n    }))\r\n  })\r\n}我们再登录的时候，就将前端传来的消息存入对象中，以及他的socket对象，然后广播的时候就可以遍历所有的socket对象，为所有在线用户广播消息，其中的 isMyself 代表的是否为本人，例如我发的消息，自己的socket对象接受广播的时候就是 true 。别人的就是 false ，这样做是为了方便区分，自己的聊天消息和被人的聊天消息2. 前端部分接下来聊聊前端的聊天室部分handleSocketMessage(): void {\r\n    const { socketTask } = this\r\n    socketTask.onMessage(async ({ data }) => {\r\n      const messageInfo: ReceiveMessageInfo = JSON.parse(data)\r\n      const { to, messageId, isMyself, userName, userAvatar, currentTime, message } = messageInfo\r\n      const time: string = formatTime(currentTime)\r\n\r\n      this.messageList[to].push({\r\n        ...messageInfo,\r\n        currentTime: time\r\n      })\r\n      /* 设置群组最新消息 */\r\n      this.contactsList.filter(contacts => contacts.contactsId === to)[0].latestMessage = {\r\n        userName, message, currentTime: time\r\n      }\r\n      this.scrollViewId = isMyself ? messageId : ''\r\n      await Taro.request({\r\n        url: 'http://localhost:3000/chatlog',\r\n        method: 'PUT',\r\n        data: {\r\n          to,\r\n          userName,\r\n          userAvatar,\r\n          currentTime,\r\n          message,\r\n        }\r\n      })\r\n    })\r\n  }我们先接受消息，然后先更新指定群组名的聊天群组的聊天记录，然后再使用 PUT 的方式访问接口添加聊天记录到数据库中。可以看到我们的聊天记录是分为左边以及右边的，自己发的消息即为右边，我们可以通过简单的flex布局来实现// 这里是覆盖默认样式，显示自己消息的样式\r\n.myself {\r\n  justify-content: flex-end;\r\n\r\n  .avatar {\r\n    order: 1;\r\n  }\r\n\r\n  .info {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: flex-end;\r\n\r\n    .header {\r\n      justify-content: flex-end;\r\n\r\n      .username {\r\n        order: 1;\r\n        margin-right: 0 !important;\r\n        margin-left: .5em;\r\n      }\r\n    }\r\n\r\n    .content {\r\n      color: #333 !important;\r\n      border: #e7e7e7 1px solid;\r\n      background: #fff !important;\r\n      box-shadow: 0 8px 20px -8px #d7d7d7;\r\n    }\r\n  }\r\n}\r\n\r\n// 以下是默认样式，就是左边的样式\r\n.message-wrap {\r\n  display: flex;\r\n  margin: 20px 0;\r\n\r\n  .avatar {\r\n    width: 14vw;\r\n    height: 14vw;\r\n    margin: 10px;\r\n    border-radius: 50%;\r\n    background-image: linear-gradient(120deg, #a1c4fd 0%, #c2e9fb 100%);\r\n  }\r\n\r\n  .info {\r\n\r\n    .header {\r\n      display: flex;\r\n      align-items: center;\r\n      max-width: 40vw;\r\n      padding: 10px 0;\r\n      color: #666;\r\n      font-size: .8em;\r\n\r\n      .username {\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n        max-width: 40vw;\r\n        margin-right: .5em;\r\n        color: #555;\r\n        font-size: 1.2em;\r\n        font-weight: bold;\r\n      }\r\n    }\r\n\r\n    .content {\r\n      display: inline-block;\r\n      max-width: 60vw;\r\n      padding: 10px 20px;\r\n      color: #fff;\r\n      word-break: break-all;\r\n      border-radius: 20px;\r\n      background: #66a6ff;\r\n    }\r\n  }\r\n}最后我们聊一下websocket的断线重连handleSocketClose(): void {\r\n    const { socketTask } = this\r\n    socketTask.onClose((msg) => {\r\n      this.socketTask = null\r\n      this.socketReconnect()\r\n      console.log('onClose: ', msg)\r\n    })\r\n  }\r\n\r\n  handleSocketError(): void {\r\n    const { socketTask } = this\r\n    socketTask.onError(() => {\r\n      this.socketTask = null\r\n      this.socketReconnect()\r\n      console.log('Error!')\r\n    })\r\n  }我们这里先监听一下websocket关闭或者异常的情况，调用重连方法，以及清空socketTask的对象，接下来是重连的方法socketConnect() {\r\n    // 生成随机特有的socketId\r\n    this.generateSocketId()\r\n\r\n    /* 使用then的方法才能正确触发onOpen的方法，暂时不知道原因 */\r\n    Taro.connectSocket({\r\n      url: 'ws://localhost:3000',\r\n    }).then(task => {\r\n      this.socketTask = task\r\n      this.handleSocketOpen()\r\n      this.handleSocketMessage()\r\n      this.handleSocketClose()\r\n      this.handleSocketError()\r\n    })\r\n  }\r\n\r\n  socketReconnect(): void {\r\n    this.isReconnected = true\r\n    clearTimeout(this.timer)\r\n\r\n    /* 3s延迟重连，减轻压力 */\r\n    this.timer = setTimeout(() => {\r\n      this.socketConnect()\r\n    }, 3000)\r\n  }我们每三秒调用一遍socket连接的方法，重新再设置好socketId，以及socketTask，重新监听各种方法。这里有一个奇特的地方，就是Taro的connectSocket方法，不能使用 async/await 的方法来获取socketTask，也就是说不能这样 const socketTask = await Taro.connectSocket({...}) 来获取socketTask，只能通过then的方法才能获取到，卑微的我暂时不知道如何解决这个问题......具体后续请关注一下我的github，将持续更新项目！猛戳~" } { "title": "开发|微信小程序与tensorflow.js准备工作 ", "author": "Rolan", "pub_time": "2019-11-20 00:01", "content": "本文首发于微信公众号： \"算法与编程之美\"，欢迎关注，及时了解更多此系列文章。问题描述这篇文章主要讲解如何将 t ensorflow 与微信小程序结合，使得 t ensorflow 的模型能够在微信小程序上呈现出来。解决方案下载微信小程序稳定版，版本号最新的就行。新建一个小程序项目, AppID 必须是正式的没有可以注册一个。打开项目后点击右上角详情 — > 本地设置 - -> 调试基础库 -- > 选择最新版本并勾选使用 n pm 模块。打开以下网址，登录自己的小程序账号添加 t ensorflowJS 插件。安装 t ensorflowJS 库，安装 L TS 版本 ( 安装过程不需要配置，一直点下一步即可 )https://nodejs.org/en/安装成功后，打开 P owerShell( 管理员 ) ，如下图输入 node –version 和 npm –version 查看版本号检测是否安装成功接下来使用 n pm 安装 t fjs 所用的一些包先切换到小程序项目的目录下，输入 npm init 对环境进行初始化之后会要求输一些配置信息，没什么特别需求直接回车，最后输入 y es 即可分别安装以下包npm install @tensorflow/tfjs-corenpm install @tensorflow/tfjs-converternpm install fetch-wechat回到微信小程序页面，点击工具 -- > 构建 npm进入 p ackage.json 可以查看已经安装的包，每次新建项目都要重复初始化和安装包的操作删除一些微信小程序自带的代码， a pp.js 内的代码可以都删除。删除 Index.js 内的内容删除 l ogs 文件夹app.json 内指向 l ogs 的部分也删除 , 删除代码时前后相应的逗号别忘了删除，不然会报错。之后用代码导入包，进入之前添加 t ensorflowJS 插件的网页，下方有引入插件的代码及相关说明复制到 a pp . json 内，只复制红线部分复制红线内代码到 a pp.js之后用 t ensorflow 打印一个常量，检测是否能正常运行结语导入 tfjs 需要注意的地方基础库需要切换到2.7.0以上的版本（一般是最新版本）Npm 的初始化和安装需要在项目目录下操作每次安装 n pm 包之后，需要重新构建 n pmEND实习编辑   |   王文星责       编   |   马原涛 where2go 团队微信号： 算法与编程之美" } { "title": "uni-app对微信小程序云函数的适配 ", "author": "Rolan", "pub_time": "2019-11-20 00:05", "content": "版权说明本文首发于个人博客-指尖魔法屋（www.thinkmoon.cn)。原文地址： uni-app对微信小程序云函数的适配引言熟悉uni-app的人应该都知道，uni-app并未对微信小程序云函数（本文统称云函数）进行相应的适配。但是，如果我们在某些业务场景的下需要使用云函数呢？我们知道，云函数可以复制到微信开发者工具，这样的话我们不得不每次编译一次就手动复制一次，不得不说麻烦至极。本文就问题做出以下解决方案。本文环境Hbuilder X微信开发者工具创建云函数目录首先，我们需要在uni-app项目文件夹下，创建一个云函数目录，路径随意，我这里是 functions 。然后先随便在里面放一些文件，这里以 new_file.css 为例。修改 manifest.json在uni-app根目录下，修改 manifest.json 中的微信小程序项，结构如下\"mp-weixin\" : {\r\n        /* 小程序特有相关 */\r\n        \"appid\" : \"wxd7de467f6e6cf741\",\r\n        \"cloudfunctionRoot\": \"./functions/\", // 这一行就是标记云函数目录的字段\r\n        \"setting\" : {\r\n            \"urlCheck\" : false\r\n        },\r\n        \"usingComponents\" : true\r\n    }编写 vue.config.jsvue.config.js\r\nconst path = require('path')\r\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\r\n\r\nmodule.exports = {\r\n    configureWebpack: {\r\n        plugins: [\r\n            new CopyWebpackPlugin([\r\n                {\r\n                    from: path.join(__dirname, 'functions'),\r\n                    to: path.join(__dirname, 'unpackage/dist', process.env.NODE_ENV === 'production' ? 'build' : 'dev', process.env.UNI_PLATFORM, 'functions')\r\n                }\r\n            ])\r\n        ]\r\n    }\r\n}编译运行发现提示如下内容说明未安装 copy-webpack-plugin 插件，我们手动安装一下。然后编译运行，发现微信开发者工具里面出现以下内容。截止目前，已打通Hbuilder X到微信开发者工具的自动复制，即已解决本文的核心内容。以下为进一步测试。创建云函数我们在云函数根目录上右键，在右键菜单中，可以选择创建一个新的 Node.js 云函数，我们将该云函数命名为check。开发者工具在本地创建出云函数目录和入口 index.js 文件，同时在线上环境中创建出对应的云函数。创建成功后，工具会提示是否立即本地安装依赖，确定后工具会自动安装 wx-server-sdk。我们会看到以下内容。创建好后将其同步复制到uni-app项目，即可为以后自动同步行方便，又可避免在输出文件夹中云函数的意外丢失。至此，相关文件编写工作转至 Hbuilder X ，云函数上传部署依旧在微信开发者工具。编写云函数默认的云函数只是一个返回用户基本数据的内容，我们将其修改至满足我们的业务需求，以内容安全云调用为例。在云函数文件中写入以下内容// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    console.log('待检测文本:' + event.content);\r\n    let result = await cloud.openapi.security.msgSecCheck({\r\n      content: event.content\r\n    })\r\n    console.log('result:' + JSON.stringify(result));\r\n\r\n    if (result && result.errCode.toString() === '87014') {\r\n      return {\r\n        code: 300,\r\n        msg: '内容含有违法违规内容',\r\n        data: result\r\n      }\r\n    } else {\r\n      return {\r\n        code: 200,\r\n        msg: 'ok',\r\n        data: result\r\n      }\r\n    }\r\n\r\n  } catch (err) {\r\n    if (err.errCode.toString() === '87014') {\r\n      return {\r\n        code: 300,\r\n        msg: '内容含有违法违规内容',\r\n        data: err\r\n      }\r\n    }\r\n    return {\r\n      code: 400,\r\n      msg: '调用security接口异常',\r\n      data: err\r\n    }\r\n  }\r\n}权限申明在函数目录下，创建一个 config.json ,文档说会自动创建，但是我实际操作时未自动创建。 config.json 内容如下。{\r\n    \"permissions\": {\r\n        \"openapi\": [\r\n            \"security.msgSecCheck\"\r\n        ]\r\n    }\r\n}然后在函数目录右键，上传并部署。小程序调用云函数wx.cloud.init()\r\n                wx.cloud.callFunction({\r\n                    name: 'check',\r\n                    data: {\r\n                        \"content\": this.contents.join()\r\n                    }\r\n                }).then(res => {\r\n                    console.log(res.result)\r\n                    if (res.result.code == 300) {\r\n                        uni.showModal({\r\n                            title: \"温馨提示\",\r\n                            content: \"你所输入的内容可能含有违法违规内容，不支持进行下一步操作\"\r\n                        })\r\n                        return\r\n                    } else {\r\n                        ... // 你要进行的操作\r\n                    }\r\n                })效果展示" } { "title": "小程序 - 可搜索的地址选择 ", "author": "Rolan", "pub_time": "2019-11-20 00:41", "content": "最终实现效果：新建index文件夹index.wxml<!--pages/index/index.wxml--><view class='container'>  <view bindtap='onChangeAddress'>    <input value=\"{{address}}\" name=\"address\" placeholder=\"选择地点\">  </view></view>index.js// pages/index/index.jsPage({  data: {    address: ''  },  onChangeAddress() {    var _page = this;    wx.chooseLocation({      success: (res) => {        _page.setData({          address: res.name        });      },      fail: (err) => {        console.log(err);      }    });  }})新建map文件夹map.wxml<!--pages/map/map.wxml--><view class=\"container\">  <map    id=\"myMap\"    style=\"width: 100%; height: 100%;\"    latitude=\"{{latitude}}\"    longitude=\"{{longitude}}\"    markers=\"{{markers}}\"    show-location  ></map></view>map.js// pages/map/map.jsPage({  data: {    latitude: 31.22786,    longitude: 121.46658,    markers: [{      id: 1,      latitude: 31.22786,      longitude: 121.46658,      name: '上海招商局广场'    }]  },  onReady(e) {    this.mapCtx = wx.createMapContext('myMap')  }})" } { "title": "微信小程序 模拟打电话 实践 ", "author": "Rolan", "pub_time": "2019-11-20 00:50", "content": "模拟电话模拟打电话功能，拨下指定的号码如10086，等待1.5秒后开始播放本地音频文件并计时。使用小程序官方API createInnerAudioContext()创建 InnerAudioContext对象。小程序官方推荐使用更为强大的音频上下文对象InnerAudioContext，官方已经停止了对组件的维护。上述这个demo效果的具体实现，如下代码：<template><view class=\"task\">  <view class=\"call\">    <!-- 顶部区域 -->    <view class=\"top\" wx:if=\"{{phone.length > 0}}\">      <view class=\"phone\">{{phone}}</view>      <view class=\"tip\" wx:if=\"{{calling}}\">        <view wx:if=\"{{tipShow}}\">正在呼叫...</view>        <view wx:else>{{formatMmSs}}</view>      </view>    </view>    <!-- 中间区域 -->    <view class=\"middle\">      <view class=\"nums\" wx:if=\"{{showNums}}\" @tap=\"numClick\">        <view class=\"row\">          <view class=\"num\" data-num='1'>1</view>          <view class=\"num\" data-num='2'>2</view>          <view class=\"num\" data-num='3'>3</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='4'>4</view>          <view class=\"num\" data-num='5'>5</view>          <view class=\"num\" data-num='6'>6</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='7'>7</view>          <view class=\"num\" data-num='8'>8</view>          <view class=\"num\" data-num='9'>9</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='*'>*</view>          <view class=\"num\" data-num='0'>0</view>          <view class=\"num\" data-num='#'>#</view>        </view>          </view>      <view class=\"icons\" wx:else>        <view class=\"icon\">          <image src=\"{{img.ringIcon1}}\"></image>          <view>静音</view>        </view>        <view class=\"icon\">          <image src=\"{{img.ringIcon2}}\" @tap=\"handle('back')\"></image>          <view>拔号</view>        </view>        <view class=\"icon\">          <image src=\"{{img.ringIcon3}}\"></image>          <view>免提</view>        </view>      </view>    </view>    <!-- 底部区域 -->    <view class=\"bottom\">      <image wx:if=\"{{!calling}}\" class=\"btn\" src=\"{{img.call}}\" @tap=\"handle('call')\"></image>      <image wx:else class=\"btn\" src=\"{{img.cancel}}\" @tap=\"handle('cancel')\"></image>      <image wx:if=\"{{!calling && phone.length>0}}\" class=\"del\" src=\"{{img.delete}}\" @tap=\"handle('delete')\"></image>    </view>  </view></view> </template><script>import wepy from 'wepy'import img from '@/assets'export default class Test extends wepy.page {  config = {    navigationBarTitleText: '模拟电话'  }  data = {    img: img,    phone: '',        // 10086    tipShow: false,   // 显示呼叫中    calling: false,   // 是否拔通电话    showNums: true,   // 显示数字面板    seconds: 0        // 计时  }  computed = {    // 通话计时 格式化    formatMmSs() {      return this.mmss(this.seconds)    }  }  // 格式化时间  mmss(count) {    count = count % 3600  // 不考虑 HH    let mm = Math.floor(count / 60)    let ss = count % 60    if (mm < 10) mm = '0' + mm    if (ss < 10) ss = '0' + ss    return mm + ':' + ss  }  onLoad() {    // 音频上下文    wepy.setInnerAudioOption({      mixWithOther: false,    // 终止其他应用或微信内的音乐      obeyMuteSwitch: false   // 在静音模式下，也能播放声音    })    let ctx = wepy.createInnerAudioContext()    ctx.src = '/assets/media/10086.mp3'    ctx.loop = true    ctx.onPlay(() => {      console.log('开始播放')    })    ctx.onError((res) => {      console.log(res.errMsg)    })    this.ctx = ctx  }  methods = {    // 点击数字    numClick(e) {      console.log(e)      console.log(e.target.dataset.num)      const num = e.target.dataset.num      this.phone = this.phone + num    },    handle(type) {      switch (type) {        case 'call':          // 拔打电话          if (this.phone !== '10086') {            wepy.showToast({ title: '请拔打10086', icon: 'none' })          } else {            this.calling = true            this.tipShow = true            // 延迟1.5秒后开始计时，并播放音频文件            setTimeout(() => {              this.ctx.play()              this.showNums = false              this.timer = setInterval(() => {                this.tipShow = false                this.seconds = this.seconds + 1                this.$apply()              }, 1000)            }, 1500)          }          break        case 'cancel':          // 挂掉电话          clearInterval(this.timer)          this.ctx.seek(0)          this.ctx.stop()          this.phone = ''          this.calling = false          this.showNums = true          this.seconds = 0          break        case 'delete':          // 删除电话号码的最后一位          let phone = this.phone          let arr = phone.split('')          arr.pop()          this.phone = arr.join('')          break        case 'back':          // 返回至数字键盘          this.showNums = true          break        default:          break      }    }  }}</script><style lang='less'>.task {  position: absolute;  top: 0;  bottom: 0;  left: 0;  right: 0;  overflow: hidden;  background: rgba(0, 0, 0, 1);  // 打电话区域  .call {    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    z-index: 2;    .top {      position: absolute;      top: 48rpx;      left: 0;      right: 0;      color: #FDFDFD;      text-align: center;      .phone {        font-size: 72rpx;        line-height: 100rpx;      }      .tip {        font-size: 36rpx;        line-height: 54rpx;      }    }    .middle {      position: absolute;      top: 232rpx;      left: 0;      right: 0;      // 数字面板      .nums {        .row {          width: 540rpx;          margin: 0 auto;          height: 158rpx;          overflow: hidden;          .num {            float: left;            margin: 0 30rpx;            width: 120rpx;            height: 120rpx;            border-radius: 50%;            background:rgba(229,229,229,1);            text-align: center;            line-height: 120rpx;            font-size: 60rpx;            color: black;          }          .num:active {            background:rgba(229,229,229,0.5);          }        }      }      // 免提等      .icons {        margin: 0 auto;        width: 540rpx;        height: 250rpx;        overflow: hidden;        padding-top: 196rpx;        .icon {          float: left;          width: 120rpx;          margin: 0 30rpx;          &>image {            display: block;            width: 120rpx;            height: 120rpx;            border-radius: 50%;          }          &>image:active {            opacity: 0.7;          }          &>view {            font-size: 32rpx;            color: #FDFDFD;            text-align: center;            line-height: 68rpx;          }        }      }    }    .bottom {      position: absolute;      top: 940rpx;      left: 0;      right: 0;      text-align: center;      .btn {        display: inline-block;        width: 120rpx;        height: 120rpx;        border-radius: 50%;      }      .del {        display: inline-block;        width: 75rpx;        height: 56rpx;        position: absolute;        top: 46rpx;        right: 138rpx;      }      .btn:active {        opacity: 0.7;      }      .del:active {        opacity: 0.7;      }    }  }}</style>" } { "title": "在腾讯Q3财报中站C位的品牌小程序，BAT态度大不同！ ", "author": "Rolan", "pub_time": "2019-11-22 00:12", "content": "昨天，腾讯2019年Q3财报如“约”而至。其中，小程序数据格外亮眼，不仅日活跃用户超过3亿，商业化也表现强劲，中长尾小程序日均商业交易笔数同比增加超过一倍。值得注意的是，这组数据中，“品牌”二字尤其“夺目”，财报显示：品牌自营类小程序数量同比增长1倍以上；8%的品牌自营类小程序交易额同比增长100倍以上、56%的品牌自营类小程序交易额同比增长50%以上，在头部领跑下，中腰部正在崛起；超过1亿人次访问品牌自营类小程序。这一定程度上说明了越来越多的品牌选择了微信小程序作为重要阵地。因此，要让用户在众多品牌中一眼就能发现自己，品牌曝光是首要环节。对于企业而言，如果没做好品牌曝光，自家品牌就会淹没在“芸芸众生”之中，而这一局面，在搜索场景下尤为突出。比如，用户输入一个关键词，结果“数不胜数”，无论用户看多少眼，也不一定会注意到。于是，BAT三巨头接踵而至地基于自家搜索推出一个能力：品牌主页。直白点说，“品牌主页”就是：在搜索结果页中，将企业各类信息与服务放在一起整体展示，比如企业认证信息、小程序、服务等等，入口更直接。微信“品牌主页”叫作品牌官方区，于去年4月基于搜一搜推出，在公众号后台便可开通；相比之下，支付宝与百度则慢了好几拍，都是最近才推出小程序能力，前者叫品牌直达，后者称百度品牌名片。虽然叫法不同（以下统称时，称为“品牌主页”），但其目的是一致的，都是为了帮助企业更好地建立品牌效应、将服务充分触达用户，从而提升收益。但BAT三平台的属性不同，“品牌主页”的能力开放程度、玩法等也有所差异，并非都能满足所有企业的需求，企业们在选择上也就“不知所云”。对此，晓程序观察（yinghoo-tech）就来一次测评与PK，帮助企业们选择适合自己的“品牌主页”。1流量曝光：微信品牌官方区完胜？既然“品牌主页”是用来帮助企业更好地触达用户，对于企业与品牌而言，最关心的还是流量，比如：用户输入哪些关键词，才能直达“品牌主页”？如果品牌名称输入错误，“品牌主页”能不能显示？“品牌主页”在搜索结果中是怎么排序的？实际上，对于搜索平台来说，这些都是影响流量曝光不可忽略的因素。流量曝光第一环：入口微信：三种样式、三种入口，A级最突出在搜一搜的搜索结果页中，微信品牌官方区的有三种展示样式，如图，依次为A、B、C三种：A级与B级的品牌官方区可以添加公众号、小程序、服务和商品；C级样式仅允许将公众号展示。此外，A级与B级都有品牌详情页，C级样式并没有。在众多搜索结果中，A级样式会有一种“鹤立鸡群”的感觉，更容易建立品牌认知，尤其是小程序、公众号、服务、商品等都是卡片形式，入口更加“抢眼”。不过，A级样式并不是所有品牌都能开通的，三种样式各有不同的门槛。如图，要求中包括公众号与官方区点击量、是否有微信认证与商标认证、公众号注册时间等条件。值得注意的是，开通A级样式还有推广搜一搜的要求，即品牌主在投放广告时或在自有宣传渠道上，要有“微信搜一搜”搜索框露出。线上线下渠道都可以，比如：电梯间广告、户外大屏广告、易拉宝、门店宣传、自有小程序曝光、公众号文章广告、朋友圈广告等等。 支付宝&百度：品牌主页没有特殊展示，入口很“隐蔽”相较于微信官方区，支付宝品牌直达与百度品牌名片的样式则显得尤为“简陋”。展示上，支付宝品牌直达与其他搜索结果并无差别，而百度品牌名片本身即是一个小程序。所以，在入口上，支付宝品牌直达与百度品牌名片都不够突出。对于企业来说，“品牌主页”的作用，就是为了让用户在众多搜索结果中一眼就能看到自家品牌，而“与众不同”的样式，入口也就更“夺目”，这一点，微信官方区是合格的。从品牌曝光来看，支付宝与百度的“品牌主页”在入口上都没有明显优势。如此看来，微信品牌官方区完胜。流量曝光第二环：关键词配置对比完三家“品牌主页”的样式，再来看关键词配置。毕竟，用户输入什么关键词，才能将“品牌主页”搜索出来才是最重要的。微信：级别越高，可配置关键词数量越多刚刚提到，微信品牌官方区有A、B、C三种不同级别。所以，可配置的关键词数量也是不一样的，分别为5个、3个、1个。所以，这对企业来说，可操作空间不大，但仍旧需要将与品牌相关的常见关键词都加上。比如，开通A级官方区的“同程旅游网”，其相关的关键词有同程旅游、同程、同程艺龙等，但晓程序观察（yinghoo-tech）测试后发现，输入“同程艺龙”，并不会出现“同程旅游网”品牌官方区，说明其没有配置关键词“同程艺龙”。同样的问题，也出现在开通B级官方区的“麦当劳”上，搜索英文名称McDonald，就不会出现其品牌官方区。支付宝&百度：“关键词要与品牌名称完全一致”支付宝品牌直达与百度品牌名片的关键词完全不用主动配置，但是，对企业、对用户都极其不友好。因为，只有在用户精确搜索品牌词时，搜索结果中才会出现“品牌主页”。百度品牌名片更甚，据百度官方介绍，用户需要输入“品牌名+品牌名片”（如齐家网品牌名片），或者输入开发者在后台填写的企业全称。对此，晓程序观察也测试了一番，输入“齐家网”后，在搜索结果中，整个第一页都没有看到“齐家网品牌名片”的身影。因此，在“品牌主页”的关键词配置上，微信有一定的运营空间，而百度与支付宝则完全没有。流量曝光第三环：搜索排名对于搜索平台的逻辑来说，决定流量价值的，除了关键词，当然就是搜索结果页排名了。BAT三家“品牌主页”的排名规则，又有什么不一样？微信：“品牌主页”始终占据首位在搜一搜结果页中，微信官方区始终是以首位展示。比如，输入“同程”后，结果页中排在第一位的便是“同程旅游网”品牌官方区，而后才是文章、公众号、小程序、朋友圈等内容。当然前提是，需要针对特定搜索词才能保证官方区首位展示。不同级别的官方区，指定关键词数量也是不一样的。此外，搜索词申请也有一定的要求：须为品牌词汇：针对通用词汇，比如汉堡、保险等，不开放置顶申请；须具有品牌独占性：针对非品牌独占词汇，比如阿拉丁等，不开放置顶申请。支付宝：可通过运营手段来提升搜索排名相比于微信官方区首位展示，支付宝品牌直达的搜索排名则由算法决定。算法维度主要包括：搜索结果中品牌直达的访问和点击用户数、开通品牌直达后搜索带来的增量用户数等，而这些数据都可以利用运营手段来提升。需要注意的是，支付宝品牌直达内包括了小程序、生活号等内容；所以，企业们只需运营品牌直达即可，这样便能同时提升小程序与生活号的排名竞争力。比如，在运营活动中，就可以引导用户“上支付宝搜XXX”，从而改善搜索UV、搜索UV增量数据。百度：广告排在品牌主页前面作为一个搜索引擎平台，百度品牌名片的排名同样根据算法得到，至于逻辑目前还不太清楚。不过，据我们的测试来看，百度品牌名片并不会排在首位，“取而代之”的则是与关键词相关的广告内容。如图，输入“齐家网品牌名片”之后，出现在首位是与齐家网毫无关系的广告内容。综上，微信官方区首位展示，显然是最能帮助企业实现品牌曝光的。而支付宝与百度，还需要开发者在运营规范中自行摸索算法。比如，支付宝品牌直达的搜索UV就是其算法中一个很重要的因素。2在至关重要的拉新与转化上百度输了？对于企业而言，“品牌主页”能带来流量曝光是远远不够的，其更加看重的，仍是拉新与转化。这一点，目前只有微信品牌官方区与支付宝品牌直达能够做到。事实上，BAT三家“品牌主页”看似差别不大，都可以在“品牌主页”内添加小程序等入口，但在拉新与转化上，百度则略逊一筹。原因是微信与支付宝“品牌主页”具备以下两个能力：1.可在品牌主页内直接添加服务与商品在微信与支付宝的“品牌主页”内，开发者能够配置其小程序的服务或商品。品牌在搜索结果页中就能直接触达用户，转化能力更强。用户点击服务或商品后，落地页都是品牌关联的小程序，比如，在NIKE的微信品牌官方区内，点击商品，进入的就是“Nike耐克”小程序的商品详情页。目前，微信品牌官方区最多可在搜索结果页展示4个服务与3个商品；而支付宝品牌直达，仅可添加1-2个小程序服务。2.品牌主页可与功能直达打通在微信与支付宝“品牌主页”中，可与“功能直达”打通，也是其一项重要开放能力。（关于BAT三家功能直达，我们此前已有过测评对比，请点击阅读）在微信搜一搜中，品牌官方区的服务和商品也会出现在相关搜索结果中，拥有更多曝光；同样，用户在支付宝搜索的关键词与某功能关键词匹配时，便会触发功能直达，小程序内的服务便可直接出现在结果页中。相比之下，百度不仅在搜索结果页没有服务入口，在品牌详情页内也不可添加小程序内某个服务，目前只能起到展示作用。综上，无论是“品牌主页”样式，还是流量曝光，微信官方区都要更加完善；而支付宝与百度则处于刚刚起步的阶段，尤其是百度品牌名片，并没有将百度的搜索价值利用至最大化。那么，企业开发者们，BAT三家“品牌名片”，你们会怎么运营？欢迎留言哦~" } { "title": "微信-小程序开发基础知识笔记 ", "author": "Rolan", "pub_time": "2019-11-22 00:41", "content": "绑定事件的方法：1.bindtab和catchtab，catchtab可以阻止事件冒泡\r\n<view bindtap='onClick'></view>\r\n\r\n<view catchtap='onClick'></view>\r\n2.互斥事件绑定 mut-bind一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。在想要规定冒泡区间时可以用到。\r\n<view mut-bind:tap='onClick'></view>\r\n在基础库版本 2.7.1 以上，可以使用 mark 来识别具体触发事件的 target 节点\r\n<view mark:myMark=\"last\" bindtap=\"bindViewTap\">\r\n\r\n<button mark:anotherMark=\"leaf\" bindtap=\"bindButtonTap\">按钮</button>\r\n\r\n</view>\r\n在上述 WXML 中，如果按钮被点击，将触发 bindViewTap 和 bindButtonTap 两个事件，事件携带的 event.mark 将包含 myMark 和 anotherMark 两项。\r\nPage({\r\n\r\nbindViewTap: function(e) {\r\n\r\ne.mark.myMark === \"last\" // true\r\n\r\ne.mark.anotherMark === \"leaf\" // true\r\n\r\n}\r\n\r\n})\r\nmark 和 dataset 很相似，主要区别在于：1.mark可以冒泡，如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。2.在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark。3.不同于 dataset ，节点的 mark 不会做连字符和大小写转换。.wxs文件的应用个人理解 .wxs文件就相当于cocos的prefab。执行起来比js性能要快。但是wxs是一门语言，平行于JavaScript。wxs基础语法有频繁用户交互的效果在小程序上表现是比较卡顿的，这时建议使用wxs，为什么？因为小程序分为视图层和逻辑层，比如需要拖动的功能，touchmove事件从视图层抛到逻辑层，逻辑层经过处理，通过this.setData到视图层。1. 一次 touchmove 的响应需要经过 2 次的逻辑层和渲染层的通信以及一次渲染，通信的耗时比较大。2. 此外 setData 渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。WXS 函数的除了纯逻辑的运算，还可以通过封装好的ComponentDescriptor 实例来访问以及设置组件的 class 和样式，对于交互动画，设置 style 和 class 很方便。代码示例：\r\nvar wxsFunction = function(event, ownerInstance) {\r\n\r\nvar instance = ownerInstance.selectComponent('.classSelector') // 返回组件的实例\r\n\r\ninstance.setStyle({\r\n\r\n\"font-size\": \"14px\" // 支持rpx\r\n\r\n})\r\n\r\ninstance.getDataset()\r\n\r\ninstance.setClass(className)\r\n\r\n// ...\r\n\r\nreturn false // 不往上冒泡，相当于调用了同时调用了stopPropagation和preventDefault\r\n\r\n}\r\n自定义组件上边在分析复杂交互时我们知道，频繁的调用this.setData会使页面卡顿，甚至导致小程序僵死。那么不想写或者说不会写wxs的开发者该怎么办呢？此时可以通过将页面的 setData 改为 自定义组件 中的 setData 来提升性能。原因：自定义组件中的setData不会进行深复制。（深复制会在这个值被组件间传递时才发生）自定义组件的规范1.在组件wxss中不应使用ID选择器、属性选择器和标签名选择器，就只使用class选择器准没错。2.在自定义组件的 js 文件中，需要使用 Component() 来注册组件。3.使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。4.自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。5.<slot></slot>相当于react的this.props.children。\r\n<!-- component-tag-name组件 -->\r\n\r\n<view class=\"wrapper\">\r\n\r\n<view>这里是组件的内部节点</view>\r\n\r\n<slot></slot>\r\n\r\n</view>\r\n\r\n<!-- 引用组件的页面模板 -->\r\n\r\n<view>\r\n\r\n<component-tag-name>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot> 的位置上 -->\r\n\r\n<view>这里是插入到组件slot中的内容</view>\r\n\r\n</component-tag-name>\r\n\r\n</view>\r\n6.默认情况下，一个组件的wxml中只能有一个slot。需要使用多slot时，可以在组件js中声明启用。\r\nComponent({\r\n\r\noptions: {\r\n\r\nmultipleSlots: true // 在组件定义时的选项中启用多slot支持\r\n\r\n},\r\n\r\nproperties: { /\\* ... \\*/ },\r\n\r\nmethods: { /\\* ... \\*/ }\r\n\r\n})\r\n此时，可以在这个组件的wxml中使用多个slot，以不同的 name 来区分。\r\n<!-- 组件模板 -->\r\n\r\n<view class=\"wrapper\">\r\n\r\n<slot name=\"before\"></slot>\r\n\r\n<view>这里是组件的内部细节</view>\r\n\r\n<slot name=\"after\"></slot>\r\n\r\n</view>\r\n使用时，用 slot 属性来将节点插入到不同的slot上。\r\n<!-- 引用组件的页面模板 -->\r\n\r\n<view>\r\n\r\n<component-tag-name>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot name=\"before\"> 的位置上 -->\r\n\r\n<view slot=\"before\">这里是插入到组件slot name=\"before\"中的内容</view>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot name=\"after\"> 的位置上 -->\r\n\r\n<view slot=\"after\">这里是插入到组件slot name=\"after\"中的内容</view>\r\n\r\n</component-tag-name>\r\n\r\n</view>\r\n7.设置自定义组件的捕获和冒泡机制需要使用 triggerEvent 方法。\r\n// 组件 my-component.js\r\n\r\nComponent({\r\n\r\nmethods: {\r\n\r\nonTap: function(){\r\n\r\nthis.triggerEvent('customevent', {}, { bubbles: true, composed: true })\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n组件中的behaviors个人理解：多个页面可能会共用一个功能，这个功能抽象后称为组件。多个组件共用一个方法或者多个方法，这类方法的集合称为behaviors。就tm理解成高阶组件就完了。组件间关系relations官方说：有时需要实现这样的组件：\r\n<custom-ul>\r\n\r\n<custom-li> item 1 </custom-li>\r\n\r\n<custom-li> item 2 </custom-li>\r\n\r\n</custom-ul>\r\n说custom-ul 和 custom-li 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。具体怎么个复杂需要单独拎出来一个ralations属性来处理，咱也不知道。使用方法：\r\n// path/to/custom-ul.js\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'./custom-li': {\r\n\r\ntype: 'child', // 关联的目标节点应为子节点\r\n\r\nlinked: function(target) {\r\n\r\n// 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后\r\n\r\n},\r\n\r\nlinkChanged: function(target) {\r\n\r\n// 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后\r\n\r\n},\r\n\r\nunlinked: function(target) {\r\n\r\n// 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后\r\n\r\n}\r\n\r\n}\r\n\r\n},\r\n\r\n// path/to/custom-li.js\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'./custom-ul': {\r\n\r\ntype: 'parent', // 关联的目标节点应为父节点\r\n\r\nlinked: function(target) {\r\n\r\n// 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后\r\n\r\n},\r\n\r\nlinkChanged: function(target) {\r\n\r\n// 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后\r\n\r\n},\r\n\r\nunlinked: function(target) {\r\n\r\n// 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n注意：必须在两个组件定义中都加入relations定义，否则不会生效。还有一种情况，如果你两个自定义组件都用了相同的behaviors，你可以使用这个behavior来代替组件路径作为关联的目标节点。\r\n// path/to/custom-form.js\r\n\r\nvar customFormControls = require('./custom-form-controls')\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'customFormControls': {\r\n\r\ntype: 'descendant', // 关联的目标节点应为子孙节点\r\n\r\ntarget: customFormControls\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n组件中的observers官方定义他叫数据监听器，呵呵。使用方法：\r\nComponent({\r\n\r\nattached: function() {\r\n\r\nthis.setData({\r\n\r\nnumberA: 1,\r\n\r\nnumberB: 2,\r\n\r\n})\r\n\r\n},\r\n\r\nobservers: {\r\n\r\n'numberA, numberB': function(numberA, numberB) {\r\n\r\n// 在 numberA 或者 numberB 被设置时，执行这个函数\r\n\r\nthis.setData({\r\n\r\nsum: numberA + numberB\r\n\r\n})\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n如果需要监听所有子数据字段的变化，可以使用通配符 。\r\nComponent({\r\n\r\nobservers: {\r\n\r\n'some.field.**': function(field) {\r\n\r\n// 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发\r\n\r\n// （除此以外，使用 setData 设置 this.data.some 也会触发）\r\n\r\nfield === this.data.some.field\r\n\r\n},\r\n\r\n},\r\n\r\nattached: function() {\r\n\r\n// 这样会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some.field': { /* ... */ }\r\n\r\n})\r\n\r\n// 这样也会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some.field.xxx': { /* ... */ }\r\n\r\n})\r\n\r\n// 这样还是会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some': { /* ... */ }\r\n\r\n})\r\n\r\n}\r\n\r\n})\r\n特别地，仅使用通配符 可以监听全部 setData 。**纯数据字段就是局部变量，不参与渲染，也不会传递。官方说这样声明后再用能提高性能，要不我才不用。使用方式：\r\nComponent({\r\n\r\noptions: {\r\n\r\npureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段\r\n\r\n},\r\n\r\ndata: {\r\n\r\na: true, // 普通数据字段\r\n\r\n_b: true, // 纯数据字段\r\n\r\n},\r\n\r\nmethods: {\r\n\r\nmyMethod() {\r\n\r\nthis.data._b // 纯数据字段可以在 this.data 中获取\r\n\r\nthis.setData({\r\n\r\nc: true, // 普通数据字段\r\n\r\n_d: true, // 纯数据字段\r\n\r\n})\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n抽象节点又一个新名词，呵呵呵。说白了就是有一个父容器组件A，因为条件不同有可能A中会渲染组件B，也可能渲染组件C。举个例子，当页面需要单选和多选组件的时候,方法1是按条件引用两个封装好的组件（<单选/>，</多选>），方法2是你也可以只引用一个组件<啦啦啦/>，只不过这个<啦啦啦/>组件去帮你按需渲染<单选/>或者<多选/>。需要在父容器组件A的.json文件声明：\r\n{\r\n\r\n\"componentGenerics\": {\r\n\r\n\"selectable\": true\r\n\r\n}\r\n\r\n}\r\n在使用组件时，必须指定父组件具体是渲染哪个子组件：<啦啦啦 generic:selectable=\"单选\" /><啦啦啦 generic:selectable=\"多选\" />在页面的.json文件<啦啦啦/>，<单选/>，<多选/>都要引用。代码\r\n//page下页面的.json文件中\r\n\r\n{\r\n\r\n\"usingComponents\": {\r\n\r\n\"啦啦啦\": \"path/*/*\",\r\n\r\n\"多选\": \"*/checkbox\",\r\n\r\n\"单选\": \"*/radio\"\r\n\r\n}\r\n\r\n}\r\n当然，你也可以在容器组件.json中指定默认用哪个组件：\r\n{\r\n\r\n\"componentGenerics\": {\r\n\r\n\"selectable\": {\r\n\r\n\"default\": \"*/checkbox\"// 多选\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n计算属性今天真是开眼了，学到了这么多新词汇。。( 计算属性的作用）：是为了解决HTML代码中复杂的js代码（HTML代码中可以嵌套js代码），把复杂的js代码通过计算属性来解决这是计算属性的应用？？？ 听着词这么厉害干这事真是大才小用了。计算属性会使用缓存机制，如果这个数据的值没有改变，则计算属性将不会调用方法这点应该是它实际有价值的地方。实现原理很简单，就是对已有的 setData 进行二次封装，在每次 setData 的时候计算出 computed 里各字段的值，这期间可以增加缓存机制，属性值没有变化的复用。自定义组件拓展在react中想拓展一个组件怎么办，会用高阶组件。小程序中，自然是使用behaviors。\r\n// behavior.js\r\n\r\nmodule.exports = Behavior({\r\n\r\ndefinitionFilter(defFields) {\r\n\r\ndefFields.data.from = 'behavior'\r\n\r\n},\r\n\r\n})\r\n\r\n// component.js\r\n\r\nComponent({\r\n\r\ndata: {\r\n\r\nfrom: 'component'\r\n\r\n},\r\n\r\nbehaviors: [require('behavior.js')],\r\n\r\nready() {\r\n\r\nconsole.log(this.data.from) // 此处会发现输出 behavior 而不是 component\r\n\r\n}\r\n\r\n})\r\nBehavior() 构造器提供了新的定义段 definitionFilter ，用于支持自定义组件扩展。" } { "title": "uniapp登录流程详解uni.login ", "author": "Rolan", "pub_time": "2019-11-25 00:16", "content": "uni.login(OBJECT)登录H5平台登陆注意事项：微信内嵌浏览器运行H5版时，可通过js sdk实现微信登陆，需要引入一个单独的js，详见普通浏览器上实现微信登陆，并非开放API，需要向微信申请，仅个别开发者有此权限H5平台的其他登陆，比如QQ登陆、微博登陆，uni-app未封装，请在条件编译里按普通H5写法编写。OBJECT 参数说明参数名 类型 必填 说明 平台差异说明provider String 否 登录服务提供商，通过 uni.getProvider 获取，如果不设置则弹出登录列表选择界面scopes String/Array 见平台差异说明 授权类型，默认 auth_base。支持 auth_base（静默授权）/ auth_user（主动授权） / auth_zhima（芝麻信用） 支付宝小程序timeout Number 否 超时时间，单位ms 微信小程序、百度小程序success Function 否 接口调用成功的回调fail Function 否 接口调用失败的回调函数complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行）success 返回参数说明参数名 说明authResult 登录服务商提供的登录信息，服务商不同返回的结果不完全相同errMsg 描述信息uni.login({\r\n  provider: 'weixin',\r\n  success: function (loginRes) {\r\n    console.log(loginRes.authResult);\r\n  }\r\n});uni.checkSession检查登录状态是否过期属性 类型 必填 说明success function 否 接口调用成功的回调函数fail function 否 接口调用失败的回调函数complete function 否 接口调用结束的回调函数（调用成功、失败都会执行）uni.getUserInfo(OBJECT)获取用户信息。UNI-APP 开发微信公众号（H5）JSSDK 的使用方式在 uniapp 中可以使用模块方式引用微信 js-sdk ，微信官网直接下载的使用有问题，可以使用 jweixin-module。安装下载使用方式下载地址： https://unpkg.com/jweixin-mod...使用、var jweixin = require('jweixin-module')  \r\njweixin.ready(function(){  \r\n    // TODO  \r\n});一、小程序:1、使用 button 组件，并将 open-type 指定为 getUserInfo 类型，获取用户基本信息。详情参考文档:https://developers.weixin.qq....2、使用 open-data 展示用户基本信息。详情参考文档:https://developers.weixin.qq....provider String 否 登录服务提供商，通过 uni.getProvider 获取withCredentials Boolean 否 是否带上登录态信息。 微信小程序、头条小程序lang Number 否 指定返回用户信息的语言，默认为 en。更多值请参考下面的说明。 微信小程序timeout Number 否 超时时间，单位 ms。 微信小程序success Function 否 接口调用成功的回调fail Function 否 接口调用失败的回调函数complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行）userInfo 参数说明参数 类型 说明 平台差异说明nickName String 用户昵称openId String 该服务商唯一用户标识 5+AppavatarUrl String 用户头像uni.login({\r\n  provider: 'weixin',\r\n  success: function (loginRes) {\r\n    console.log(loginRes.authResult);\r\n    // 获取用户信息\r\n    uni.getUserInfo({\r\n      provider: 'weixin',\r\n      success: function (infoRes) {\r\n        console.log('用户昵称为：' + infoRes.userInfo.nickName);\r\n      }\r\n    });\r\n  }\r\n});说明：调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 和 会话密钥 session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。注意：会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。临时登录凭证 code 只能使用一次uni.getProvider(OBJECT)获取服务供应商。仅App平台支持。在App平台，可用的服务商，是打包环境中配置的服务商，与手机端安装了什么app没有关系。云打包在manifest中配置相关模块和SDK信息，离线打包在原生工程中配置。某个服务商配置被打包进去，运行时就能得到相应的服务供应商。关于目前文章内容即涉及前端，PHP知识点，如果有兴趣即可关注，很荣幸，能被您发现，真是慧眼识英！也感谢您的关注，在未来的日子里，希望能够一直默默的支持我，我也会努力写出更多优秀的作品。我们一起成长，从零基础学编程，将 Web前端领域、数据结构与算法、网络原理等通俗易懂的呈现给小伙伴。分享 Web 前端相关的技术文章、工具资源、精选课程、热点资讯。若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我们进行整改即可，会在第一时间进行处理。请点赞！因为你们的赞同/鼓励是我写作的最大动力！" } { "title": "小程序云开发：菜鸟也能全栈做产品 ", "author": "Rolan", "pub_time": "2019-11-25 00:25", "content": "我想独立实现一个全栈产品为什么这么难#日常生活中，我们会使用很多软件产品。在使用这些产品的时候，我们看得见的东西称为“前端界面”如一个输入框、一个按钮，点击按钮之后发生的一切看不见的东西称为“后端服务”。与之对应的创造者分别称为“前端程序员”、“后端程序员”，然而，一个完整产品的开发不仅仅是只有前端和后端，还有设计师，架构师，运维等。有没有可能这些所有的事情都一个人干呢？有可能，事实上如今就有很多的“全栈工程师”，他们身兼数职，是多面手。能独立完成一个产品的方方面面。这种人固然十分了得，他们通常具有多年的经验，涉猎广泛，是老手，也是高手，当有一个产品想法的时候，他们可以用自己的全面专业技能，尽情的发挥去实现自己的想法。所以，从某种意义上讲“全栈也是一种自由”，你可以自由的实现你的想法，这简直太美妙了！然而，很多时候当我们有一个产品想法的时候，我们往往发现，前端写完了，后端怎么搞？数据库怎么搞？域名怎么搞？域名还要备案？应用部署怎么搞？我的买什么样的服务器啊？静态资源 CDN 怎么搞？文件上传服务器怎么搞？万一访问用户多了能撑住吗？等等……问题很多，导致你的一个个想法，都只是在脑海中昙花一现，从来都无法将她们实现，或者说你激情饱满的实现了其中自己最擅长的一部分，当碰到其他难题的时候就止步了。于是仰天长啸：我就想独立做一个完整的产品为什么这么难？年轻人，这一切都不怪你……破局：小程序云开发#为什么使用小程序云开发来破局？#为啥是用“小程序云开发”来破局？首先，我们的目的是全栈实现一个产品。全栈可以有多种技术方案，你可用任何你能会的技能来达到全栈的目的。你可以开发安卓，IOS，或者 PC 站，然而小程序是最实际的！为啥？手机上能做的事情为啥要用 PC 版？OK,既然手机版比较好，那能不能再简单一点？能，就是小程序，不需要开发IOS，安卓两个版本。可以快速产出，快速试错。其次，前面说到了，全栈实现一个产品并不容易，对很多人来说甚至是巨难！选择了小程序已经是比较划算的方案。而再集成云开发，全栈立马就有了。这就是为什么选择“小程序云开发”来破局。小程序云开发是什么?#小程序云开发是什么？官方文档是这么说的：开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。看完上面的描述，也许你仍然无法非常清楚的知道什么是“小程序云开发”，没关系，你只需要注意加粗的部分，大概知道它“无需搭建服务器”，从传统观念将，这个似乎“毁三观”咋可能没服务器啊？是的，可以没有传统意义上的服务器，这种模式是 serveless 的。那么，小程序云开发提供了哪些东西来破局呢？且看下面的表格：能 力作 用说 明云函数无需自建服务器在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码数据库无需自建数据库一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库存储无需自建存储和 CDN在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理云调用原生微信服务集成基于云函数免鉴权使用小程序开放接口的能力，包括服务端调用、获取开放数据等能力上面的表格中提到了“云开发”中的一些能力：“云函数”，“数据库”，“存储”，“云调用”，我们可以将这些词带入你曾经开发过的应用，看看它们分别代表了哪些部分。对于程序员来说，如果有疑问的话，没有什么是一个 helloword 解决不了的。实战：独立开发一个简易的零售小程序#哆嗦再多，不如实战。下面我们就来使用小程序云开发实现一个简单的零售小程序。项目构思#既然是一个零售小程序，那么我们可以思考一下零售小程序的大致业务流程，以及粗略的梳理一下，其功能点。现根据自己的想法，大致画一下草图，如果没有灵感可以参考一下别的 APP 是如何设计的。我根据自己的想法设计之后是这样的：功能模块：首页，商品列表页，购物车，确认订单，个人中心，个人订单，管你模块（商品添加，分类添加）其中商品需要上传图片。梳理完功能之后，我们对于要实现的东西已经有个初步的概念了。接下来，我们需要大概画一下页面设计、及功能流转。初次设计可能没有太多经验，没关系，开始做就行了，做着做着就会想法越来越多，然后优化的越来越好。。我也是经过了多番修改调整，最终找到了一些思路。我的（拙劣）设计如下，图片如果看不清楚可复制图片链接在新窗口打开查看：说明，以上图片是根据成品（我真的开发了一个云小程序并上线使用了）截图的，而实际我再设计的时候也是经过几番修改才最终定成这样。同时，补充说明一下，这里前端页面使用的是 vant-weapp控件，非常好用。推荐！如果你和我一样是一个纯后端程序员，建议使用 vant-weapp 来作为 ui，非常方便。否则自己写页面样式的话可能就做不出来了。全栈不是那么好干的啊。选择自己能驾驭的，能实现最终功能，就是一个合格的全栈。创建小程序云开发项目#我们先下载微信小程序开发工具，下载地址在这里,安装好了之后，新建项目，界面如下，APPID 需要你自己去注册一个。然后注意，选择“小程序云开发”，如下图所示：创建好了之后，项目目录如下,先看 1 标注的地方：如果你曾经有过小程序的开发经验，那么miniprogram文件夹下面的结构你肯定熟悉了，miniprogram下面的子目录分别是小程序对应的组件、图片、页面、样式以及app.js,app.json,sitemap.json,其中components下面的vant-weapp就是上面提到的 ui 组件。最后一个比较重要的文件夹就是cloudfunctions，这个目录是用来存放“云函数的”，云函数就是我们的后端。每一个云函数提供一个服务。一个个的云函数组成了我们整体的后端服务。云函数可以看做是 FaaS（function as a service）。途中，2 标记的位置的“云开发”按钮，我们点进去，就可以看到“云开发的控制台”，如下图所示：如果上图看不清楚，可以复制链接到新的浏览器窗口查看，如图，小程序云开发默认的免费套餐有一定的额度可供使用。首页便是使用统计。然后我们能看到，有“数据库”，“存储”，“云函数”。这里的“数据库”其实就是类似于一个 MongoDB，你可以点进去创建一个个的 collection（即：关系型数据库中的table）;这里的“存储”其实就是“文件夹”，我们可以通过微信提供的 api把图片上传到“存储”中；这里的“云函数”就是我们需要实现的后端业务逻辑，他就是一个个的函数（函数由我们自己写好后上传）。一般开发过程中我们在开发者工具中的cloudfunctions目录下创建云函数（比方说是:user-add）开发完成之后在云函数目录点击右键——上传即可。然后就可以在小程序的代码中调用这个user-add云函数。云开发之——3 分钟实现文件上传#注意：在开始云开发之前，我们现在 小程序代码的 app.js 中加入wx.cloud.init,如下：CopyApp({\r\n  onLaunch: function () {\r\n    if (!wx.cloud) {\r\n      console.error('请使用 2.2.3 或以上的基础库以使用云能力')\r\n    } else {\r\n      wx.cloud.init({\r\n        // env 参数说明：\r\n        //   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源\r\n        //   此处请填入环境 ID, 环境 ID 可打开云控制台查看\r\n        //   如不填则使用默认环境（第一个创建的环境）\r\n        env: 'your-env-id',\r\n        traceUser: true,\r\n      })\r\n    }\r\n    this.globalData = {}\r\n  }\r\n})上面的图中，我们已经看到了“商品添加”页面的效果，它需要我们输入商品名称、价格、并上传图片，然后保存。传统架构中，上传图片需要前端页面摆一个控件，然后后端提供一个 api用来接收前端传来的文件，通常来说这个后端 api 接收到图片之后，会将图片文件保存到自己的文件服务器或者是阿里云存储、或者是七牛云存储之类的。然后返回给你一个文件链接地址。非常麻烦，然而，小程序云开发上传文件超级简单，上代码：Copy页面代码：\r\n<van-notice-bar\r\n  scrollable=\"false\"\r\n  text=\"发布商品\"\r\n/>\r\n  <van-field\r\n    value=\"{{ productName }}\"\r\n    required\r\n    clearable\r\n    label=\"商品名称\"\r\n    placeholder=\"请输入商品名称\"\r\n    bind:change=\"inputName\"\r\n  />\r\n    <van-field\r\n    value=\"{{ productPrice }}\"\r\n    required\r\n    clearable\r\n    label=\"价格\"\r\n    icon=\"question-o\"\r\n     bind:click-icon=\"onClickPhoneIcon\"\r\n    placeholder=\"请输入价格\"\r\n    error-message=\"{{phoneerr}}\"\r\n    border=\"{{ false }}\"\r\n    bind:change=\"inputPrice\"\r\n  />\r\n\r\n<van-action-sheet\r\n  required\r\n  show=\"{{ showSelect }}\"\r\n  actions=\"{{ actions }}\"\r\n  close-on-click-overlay=\"true\"\r\n  bind:close=\"toggleSelect\"\r\n  bind:select=\"onSelect\" cancel-text=\"取消\"\r\n/>\r\n  <van-field\r\n    value=\"{{ productCategory }}\"\r\n    center\r\n    readonly\r\n    label=\"商品分类\"\r\n    border=\"{{ false }}\"\r\n    use-button-slot\r\n  >\r\n    <van-button slot=\"button\" size=\"small\" plain type=\"primary\"  \r\n     bind:click=\"toggleSelect\">选择分类</van-button>\r\n  </van-field>\r\n  \r\n  <van-button class=\"rightside\" type=\"default\" bind:click=\"uploadImage\" >上传商品图片</van-button>\r\n  <view class=\"imagePreview\">\r\n    <image src=\"{{productImg}}\" />\r\n  </view>\r\n <van-submit-bar\r\n  price=\"{{ totalShow }}\"\r\n  button-text=\"提交\"\r\n  bind:submit=\"onSubmit\"\r\n  tip=\"{{ false }}\"\r\n >\r\n </van-submit-bar> \r\n<van-toast id=\"van-toast\" />\r\n<van-dialog id=\"van-dialog\" />这里有个控件，绑定了uploadImage方法，其代码为：Copy  uploadImage:function(){\r\n    let that = this;\r\n    wx.chooseImage({\r\n      count: 1,\r\n      sizeType: ['compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success(res) {\r\n        wx.showLoading({\r\n          title: '上传中...',\r\n        })\r\n        const tempFilePath = res.tempFilePaths[0]\r\n        const name = Math.random() * 1000000;\r\n        const cloudPath = name + tempFilePath.match(/\\.[^.]+?$/)[0]\r\n        wx.cloud.uploadFile({\r\n          cloudPath:cloudPath,//云存储图片名字\r\n          filePath: tempFilePath,//临时路径\r\n          success: res => {\r\n            let fileID = res.fileID;\r\n            that.setData({\r\n              productImg: res.fileID,\r\n            });\r\n            wx.showToast({\r\n              title: '图片上传成功',\r\n            })\r\n          },\r\n          fail: e =>{\r\n            wx.showToast({\r\n              title: '上传失败',\r\n            })\r\n          },\r\n          complete:()=>{\r\n            wx.hideLoading();\r\n          }\r\n        });\r\n      }\r\n    })\r\n  }这里，wx.chooseImage用于调起手机选择图片（相册/相机拍照），然后wx.cloud.uploadFile用于上传图片到上面说到的云开发能力之一的“存储”中。上传图片成功之后返回一个文件 ID，类似：Copycloud://release-0kj63.7265-release-0kj63-1300431985/100477.13363146288.jpg  这个链接可以直接在小程序页面展示：Copy<image src=\"cloud://release-0kj63.7265-release-0kj63-1300431985/100477.13363146288.jpg  \" />也可以通过微信 api，装换成 http 形式的图片链接。云开发之——操作数据库，1 分钟写完保存商品到数据库的代码#上面我们实现了商品图片上传，但是，商品图片并没有保存到数据库。正常录入商品的时候，我们会填好商品名称，价格等，然后上传图片，最终点击“保存”按钮，将商品保存到数据库。传统模式下，前端仍然是需要调用一个后端接口，通过 post 提交数据，最终由后端服务（比如 java 服务）将数据保存到数据库。小程序云开发使得操作数据库十分简单，首先我们在云开发控制台创建“商品表”，即一个 collection,取名为：products。然后我们就可以保存数据到数据库了，代码如下：CopyonSubmit:function(){\r\n    // 校验代码，略\r\n    let product = {};\r\n    product.imgId = this.data.productImg;\r\n    product.name= this.data.productName;\r\n    product.categoryId = this.data.productCategoryId;\r\n    product.price = this.data.productPrice;\r\n    // 其他赋值，略\r\n    const db = wx.cloud.database();\r\n    db.collection('products').add({\r\n     data: product,\r\n     success(res) {\r\n       wx.showToast({\r\n         title: '保存成功',\r\n       })\r\n     }\r\n   });\r\n  }以上就实现了数据入库，就这点代码，超简单，1 分钟写完，诚不欺我。其中这里的products就是我们的“商品表”，之前说过，类似 MongoDB 数据库，这里操作的是db.collection，这和 MongoDB 的语法差不多。云开发之——使用云函数完成后端业务逻辑，订单创建#小程序云开发提供了几大能力：“数据库”，“存储”，“云函数”，前两项我们已经有所体会了。下面我们能创建一个云函数来实现订单创建。这里说明，云函数其实就是 一段JavaScript 代码，上传至云服务器之后，最终也是运行在 nodejs 环境的，只是这一切，我们不需要关心。我们只需要关心我们这个云函数提供的功能是什么就可以了。创建云函数很简单，直接在开发工具中右键“新建Node.js 云函数”。然后以创建订单为例，假设我们创建一个云函数名为c-order-add,创建好了之后，目录是这样：云函数的主要代码在 index.js 中，其完整代码是这样：Copy// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init({\r\n  env: 'release-xxx'// your-env-id\r\n})\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const wxContext = cloud.getWXContext();\r\n  console.log(\"云函数 c-order-add : \")  \r\n  // 这里是一些逻辑处理...\r\n  \r\n  return await db.collection('uorder').add({\r\n    data: {\r\n      openid: event.userInfo.openId,\r\n      address: event.address,\r\n      userName: event.userName,\r\n      phone: event.phone,\r\n      shoppingInfo: event.shoppingInfo,\r\n      totlePrice: event.totlePrice,\r\n      shoppingStr: event.shoppingStr,\r\n      remark:event.remark,\r\n      createTime: now,\r\n      // ...\r\n    }\r\n  });\r\n}这个云函数写好之后，需要上传到服务器，直接在云函数目录点击右键，然后点击“上传并部署”即可，这就相当于部署好了后端服务。前端小程序页面调用的写法是这样的：Copylet orderData={};\r\norderData.userName = this.data.userName;\r\norderData.phone = this.data.phone;\r\norderData.address = this.data.address;\r\n// ....\r\nwx.cloud.callFunction({\r\n      // 云函数名称\r\n      name: 'c-order-add',\r\n      // 传给云函数的参数\r\n      data: orderData,\r\n      complete: res => {\r\n        Dialog.alert({\r\n          title: '提交成功',\r\n          message: '您的订单成功，即将配送，请保持手机通畅。'\r\n        }).then(() => {\r\n          // ....\r\n          wx.redirectTo({\r\n            url: '../uorder/uorder'\r\n          });\r\n        });\r\n      }\r\n})这里，向程序前端，通过wx.cloud.callFunction完成了对云函数的调用，也可以理解为对后端服务的调用。至此我们我们介绍完了，小程序云开发的功能。虽然，我只贴出了少量的代码，即保存商品，和提交订单。由于时间和篇幅有限，我不可能把整个完整的程序代码贴出来。但是你可以参照这个用法示例，将剩下的业务逻辑补充完整，最终完成“项目构思”一节中展示的成品截图效果。小程序审核的一点经验#我开发的小程序审核在提交审核的时候遭遇了两次退回，第一次是因为：“小程序具备电商性质，个人小程序号不支持”。所以，我只好申请了一个企业小程序号，使用的是超市的营业执照。服务类目的选择也被打回了一次，最后选择了食品还提交了食品经营许可证。第二次打回是因为：“用户体验问题”。其实就是“授权索取”的问题，微信不让打开首页就“要求授权”，同时不能强制用户接受授权，得提供拒绝授权也能使用部分功能。上面两条解决之后，更新新了好几版，都没有出现过被拒的情况。并且，有次我是夜晚 10 左右提价的审核，结果10 点多就提示审核通过，当时没看具体时间，就是接盆水泡了个脚的时间审核通过了。所以，我推断小程序审核初次审核会比较严，之后如果改动不大应该直接机审就过了。总结及对比#这里我们可以对小程序云开发和传统模式做一个对比：就对比这么多吧，总之，我非常喜欢小程序云开发，小程序真的可以让你轻松干全栈。或者咱们别动不动就提“全栈”，姑且说，小程序云开发可以让你更简单、更快速、更便宜的实现你的产品落地。我自己开发的云小程序上线之后，使用了一两个月，没出现任何问题。我也不用操心服务器什么的。所以，我已经给身边很多人安利了小程序云开发了。这里我就不贴出我的小程序码了，因为已经正式给我同学的超市使用了，所以不方便让别人去产生测试数据。如果你感兴趣想看的话，可以联系我。作者： 逃离沙漠出处：https://www.cnblogs.com/demingblog/p/11914354.html本站使用「CC BY 4.0」创作共享协议，转载请在文章明显位置注明作者及出处。如果本文对您有帮助，不妨点个「推荐」及「赞赏」" } { "title": "小程序页面统计埋点设计思路 ", "author": "Rolan", "pub_time": "2019-11-7 00:02", "content": "需要对小程序的页面访问进行统计，但小程序并没有页面或者路由拦截，如果要重写page或者写mixs函数太麻烦，所以希望有个之后扩展方便，改动成本低的方式进行页面埋点统计。思路埋点页面中的请求方法我们知道在不同页面中写入同一功能的代码是件很烦恼的事情，重复的工作量，各个页面间的差异性处理，都很糟心。所以在小程序这资源有限的环境里，我们希望尽量减少这部分的工作量，最好每个页面的功能代码都一样，并且精。，考虑到每个页面的差异可以用路由体现，并且能拿到当前页面的路由参数，于是采用了这个策略。page({\r\n    ...\r\n    onLoad() {\r\n        app.countViewer(this.route) //数据埋点\r\n        ...\r\n    }\r\n    ...\r\n})\r\n复制代码路由——页面id映射表后端接口需要格式大概是：{\r\n    id: 0, // 页面id\r\n    detailId: 255 // 具体业务情况下的id，例如商品的id、广告的id等\r\n}\r\n复制代码所以我们需要维护的映射表大概会长这样：const RouteList = [\r\n    {\r\n      id: 1,\r\n      route: 'page/index/index',\r\n      name: '活动专题',\r\n    },\r\n    {\r\n      id: 2,\r\n      route: 'page/active/inde',\r\n      name: '活动专题',\r\n    },\r\n]\r\n复制代码封装成个类，构造函数接受当前页的route，和具体的业务id作为参数，并向外提供获得完整RouteList的方法，和当前页面对映信息的方法：// router.js\r\nclass Route {\r\n    RouteList = [\r\n    {\r\n      id: 1,\r\n      route: 'page/index/index',\r\n      name: '活动专题',\r\n    },\r\n    {\r\n      id: 2,\r\n      route: 'page/active/inde',\r\n      name: '活动专题',\r\n    }]\r\n    \r\n    constructor(route, detailId) {\r\n        const currentRoute = this.RouteList.find(item => item.route === route) || {} // 查找符合的当前route的对象， 如果没找到返回空对象，避免报错\r\n        this.page_id = currentRoute.id\r\n        this.page_detail_id = page_detail_id\r\n    }\r\n    \r\n    getRouteList() { // 返回完成对映表\r\n        return RouteList\r\n    }\r\n    \r\n    getData() { // 返回当前对映项\r\n        return {\r\n          page_id: this.page_id,\r\n          page_detail_id: this.page_detail_id\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = Route\r\n\r\n复制代码发送方法// countViewer.js 假设$request是已经封装好的方法\r\n\r\nlet Router = require('./router.js')\r\n\r\nexport default function countViewer(router, detailId = 0) { // 给业务id一个默认值\r\n  const app = getApp() // 获得全局的$request封装好的小程序请求\r\n  const params = new Router(router, detailId).getData() //获得当前路由对映的参数信息\r\n\r\n  app.$request('countviewer', params)\r\n}\r\n\r\n复制代码并将该方法绑定到全局的app实例上，页面中使用就不用引入了。页面深度不同，小程序里引入真的很麻烦。// app.js\r\n\r\nimport countViewer from \"./utils/countViewer.js\"\r\n\r\nApp({\r\n    ...\r\n    countViewer,\r\n    ...\r\n})\r\n复制代码结尾好久不更新了，最近正好来了个需求，想想之前刚接手这个小程序的时候想写个路由/页面拦截器，发现网上提供的方法都挺麻烦的，每个页面戳进去改一大段page简直难过，所以一开始听到这个需求是有点想哭的。当任务真砸到头上，还是能想出办法的。怎么说呢，开发原则大概就是，避免去戳页面和糟糕的重复代码，实在要重复，就尽量抽出公共部分把之后更改的时候的工作量降低扒。" } { "title": "小程序入门看这篇就够了 ", "author": "Rolan", "pub_time": "2019-11-7 00:10", "content": "文章为实战中踩坑经历，以及解决方案。同时是自己的一个项目回顾，在这里分享给大家，希望能帮助到大家，如果觉得文章对你有用，请点个赞:+1:，谢谢！原谅我也是个标题党：）登录授权授权（基本信息，手机号码 ）必须使用小程序原生的的button组件，然后指定open-type 后通过回调才能拿到用户信息。代码入下：index.wxml\r\n<view class=\"authorization\" wx:if=\"{{!getUserInfo}}\">\r\n       <view class=\"clue\">你还未登录，请先授权登录</view>\r\n            <button open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"bindGetUserInfo\">\r\n                授权登录\r\n            </button>\r\n        </view>\r\n        <view class=\"authorization\" wx:if=\"{{getUserInfo && !getPhone}}\">\r\n            <view class=\"clue\">你还未绑定手机号，请先去绑定</view>\r\n            <button open-type=\"getPhoneNumber\" bindgetphonenumber=\"getPhoneNumber\">\r\n                立即绑定\r\n            </button>\r\n</view>\r\nindex.js\r\npage({\r\n    // ... \r\n    data: {\r\n        hasUserInfo: false,\r\n        canIUse: wx.canIUse('button.open-type.getUserInfo'),\r\n        userInfo: {},\r\n        getUserInfo: false,\r\n        getPhone: false,\r\n        hasAuth: false\r\n    },\r\n    onLoad: async function () {\r\n        var that = this;\r\n        // 查看是否授权\r\n        wx.getSetting({\r\n            success: function (res) {\r\n                if (res.authSetting['scope.userInfo']) {\r\n                    wx.login({\r\n                        success: loginRes => {\r\n                            // 获取到用户的 code 之后：loginRes.code\r\n                            wx.getUserInfo({\r\n                                success: async function (res) {\r\n                                    // 这里处理业务逻辑\r\n                                }\r\n                            })\r\n                        }\r\n                    })\r\n                } else {\r\n                    // 用户没有授权\r\n                }\r\n            }\r\n        });\r\n    },\r\n    bindGetUserInfo: function (e) {\r\n        // 需要什么信息都从e中拿到 以下部分业务逻辑\r\n        if (e.detail.userInfo) {\r\n            //用户按了允许授权按钮\r\n            var that = this;\r\n            // 获取到用户的信息\r\n            wx.login({\r\n                success: async res => {\r\n                    const aUserModel = new UserModel();\r\n                    const params = {\r\n                        code: res.code,\r\n                        encryptedData: e.detail.encryptedData,\r\n                        iv: e.detail.iv\r\n                    }\r\n                    const { data } = await aUserModel.login({ ...params })\r\n                    if(data.roles){\r\n                        // do ...\r\n                    }\r\n                    if (data.mobile) {\r\n                        // do ...\r\n                    }\r\n                }\r\n            });\r\n            //授权成功后,通过改变 isHide 的值，让实现页面显示出来，把授权页面隐藏起来\r\n            that.setData({\r\n                isHide: false\r\n            });\r\n        } else {\r\n            //用户按了拒绝按钮\r\n            wx.showModal({\r\n                title: '警告',\r\n                content: '拒绝授权，您将无法使用小程序',\r\n                showCancel: false\r\n            });\r\n        }\r\n    },\r\n    getPhoneNumber: async function (e) {\r\n        if (e.detail.encryptedData) {\r\n            //用户按了允许授权按钮\r\n            const aUserModel = new UserModel();\r\n            const params = {\r\n                userId: userInfo.id,\r\n                encryptedData: e.detail.encryptedData,\r\n                iv: e.detail.iv\r\n            }\r\n            // do ...\r\n        } else {\r\n            //用户按了拒绝按钮\r\n            wx.showModal({\r\n                title: '警告',\r\n                content: '拒绝授权，您将无法使用小程序',\r\n                showCancel: false\r\n            })\r\n        }\r\n    },\r\n    // ...\r\n})\r\n复制代码路由路由跳转的各个方法可以去官网学习，这里提遇到的坑，navigateTo路由跳转最多只能10层，所以使用的时候需要考虑是不是确定需要历史记录。为什么要这么说呢。 场景：一个列表页面（如下图），用户的档案是可以修改的，如果用navigateTo跳转（/page/archivesEdit?id=1923XXXX）,修改保存用navigateTo（/page/archivesList），这样来回编辑跳转10次就不让点击跳转了。解决：思考那我用2个redirectTo 行不行？redirectTo是关闭当前历史记录跳转到下一页面。造成了我跳转到修改页面点击微信自带的返回是直接跳过列表页面跳转到首页。这个时候测试小姐姐就又要提bug单了。。。完美姿势： 就是用navigateTo和navigateBack。我再编辑保存的时候返回用navigateBack返回。这样小程序的路由栈就一会在2-3层之间。当然有时候在列表页面会遇到要重新条用接口，这时候路由跳转提供了几个重要的钩子函数onShow，onHide，我们可以在onShow的时候可以条用一下列表的接口。这2个钩子函数足够我们简单的跳转，更复杂的场景下可以通过存Storage这种存取参数来返回到上一个页面进行操作，感觉不是优雅，但是没有好的办法解决了。Storage场景：storage有2种方式获取，当你直接wx.getStorageSync('xxx')获取一个id，去请求接口的可能是获取不到就已经发送请求了，导致出现bug。因为wx.getStorageSync('xxx')是异步的 我们可以利用 async/await去方便的使用onLoad: async function (options) {\r\n        const editListParams = await wx.getStorageSync('editListParams')\r\n        this.findReportDetails(editListParams)\r\n}\r\n复制代码webViewwebview不是在某个页面使用的，当时我以为是类似iframe这种东西嵌入到页面。正确的使用态度是新建一个page页面，然后跳转到这个page去使用。例如跳转到小程序关联的公众号文章：other.wxml\r\n<navigator url=\"/pages/webView/webView\"  hover-class=\"none\">跳转到webView</navigator>\r\nwebView.wxml\r\n<web-view src=\"https://mp.weixin.qq.com/s/xxxx\"></web-view>\r\n复制代码request微信自带的网络下的request，虽然能拿来就用，如果不封装就会造成代码冗余。大家可自行参考如下封装ajax.js\r\n\r\nimport { baseURL } from '../config/interfaceURL' // baseUrl\r\n\r\nclass AJAX {\r\n    AJAX ({ url, methods = 'GET', data = {} }) {\r\n        return new Promise((resolve, reject) => {\r\n            this.request(url, resolve, reject, methods, data)\r\n        })\r\n    }\r\n    request (url, resolve, reject, methods, data) {\r\n        wx.request({\r\n            url: baseURL + url,\r\n            method: methods,\r\n            data: data,\r\n            header: {\r\n                'content-type': 'application/json'\r\n            },\r\n            success: res => {\r\n                const code = res.statusCode.toString()\r\n                if (code.startsWith('2')) {\r\n                    resolve(res)\r\n                } else {\r\n                    reject()\r\n                    const errorMessage = res.data.message\r\n                    AJAX.showError(errorMessage)\r\n                }\r\n            },\r\n            fail: err => {\r\n                reject()\r\n                AJAX.showError(\"网络异常，请稍后重试！\")\r\n            }\r\n        })\r\n    }\r\n    static showError (errorMessage) {\r\n        wx.showToast({\r\n            title: errorMessage,\r\n            icon: 'error',\r\n            duration: 2000\r\n        })\r\n    }\r\n    static serializeLink (obj) { // 序列化get请求\r\n        let temp = '?'\r\n        for (let index in obj) {\r\n            if(obj.hasOwnProperty(index)){\r\n                temp += (index + '=' + obj[index] + '&')\r\n            }\r\n        }\r\n        return temp.substr(0, temp.length - 1)\r\n    }\r\n}\r\nexport default AJAX\r\n\r\n// model层调用\r\nUserModel.js\r\nimport AJAX from '../utils/AJAX'\r\n\r\nexport class UserModel extends AJAX {\r\n    // 小程序授权登陆\r\n    login (params) {\r\n        return this.AJAX({\r\n            url: `/service/api/users/applet/login`,\r\n            data: params,\r\n            methods: 'POST'\r\n        })\r\n    }\r\n}\r\n// control调用\r\nindex.js\r\nasync onLoad (options){\r\n    const aUserModel = new UserModel()\r\n    const params = {\r\n        code: loginRes.code,\r\n        encryptedData: res.encryptedData,\r\n        iv: res.iv\r\n    }\r\n    const { data } = await aUserModel.login({ ...params })\r\n    // 其他\r\n}\r\n\r\n复制代码npm生态以及第三方ui框架直接通过初始化的微信小程序项目里面没有package.json文件。所以在使用npm install xxx 是没有卵用。所以我们要自己在文件夹根目录下执行npm init 。这时候才能通过微信开发者工具构建npm，构建成功会生成一个目录。推荐用有赞的vant小程序版,社区较活跃，使用起来不会有很多坑。双向绑定对于习惯使用vue的开发者来说，少了这个v-model语法糖。在处理表单的双向绑定会显得比较蛋疼。所以还是有必要说下小程序里面的双向绑定是怎么样的。file:index.js\r\n\r\nPage({\r\n    data: {\r\n       list: []\r\n    },\r\n    onLoad: function (options) {\r\n      // do ...\r\n    },\r\n    onInput (e) {\r\n        let value = e.detail.value\r\n        let temp = e.target.dataset.name.split(',')\r\n        let tempKey = temp[1]\r\n        let tempIndex = temp[0]\r\n        let tempSubIndex = temp[2]\r\n        let targetKey = `list[${tempIndex}].children[${tempSubIndex}].${tempKey}`\r\n        this.setData({\r\n            [targetKey]: value\r\n        })\r\n    }\r\n})\r\n\r\nfile:index.wxml\r\n<block  wx:for=\"{{item.children}}\"  wx:for-item=\"subItem\"  wx:key=\"{{index}}\">\r\n    <view class=\"td\" style=\"height: {{ 100 / item.children.length}}%;\">\r\n      <input placeholder-style=\"color:#ccccccc;\"  type=\"text\" placeholder=\"未填写\" value=\"{{subItem.testResult}}\" data-name=\"{{idx}},testResult,{{index}}\"  bindinput=\"onInput\"/>\r\n    </view>\r\n</block>\r\n\r\n复制代码下载图片和下载图片授权这里场景是下载一个固定的静态资源图片，网络图片需先配置download域名才能生效,方法如下：savePhoto () {\r\n        const _this = this;\r\n        wx.getImageInfo({\r\n            src: '/static/images/home/Qr.png',\r\n            success: function (res) {\r\n                wx.saveImageToPhotosAlbum({\r\n                    filePath: res.path,\r\n                    success (result) {\r\n                        _this.setData({ show: false });\r\n                        wx.showToast({\r\n                            title: '保存成功',\r\n                            icon: 'success',\r\n                            duration: 2000\r\n                        })\r\n                    },\r\n                    fail (err) {\r\n                        if (err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n                            wx.openSetting({\r\n                                success (settingdata) {\r\n                                    if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n                                        _this.savePhoto()\r\n                                    } else {\r\n                                        wx.showToast({\r\n                                            title: '获取权限失败,无法保存图片',\r\n                                            icon: 'success',\r\n                                            duration: 2000\r\n                                        })\r\n                                    }\r\n                                }\r\n                            })\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n        })\r\n    }\r\n复制代码保存图片也是需要授权的，看代码就完事了。其他textarea 在ios上表现会有padding值。我曹 这个就坑了。我采用要不全是textarea或者全是input 这种去实现表单的填写。 其他样式问题也蛮多的，有点ie的味道。:smiley:！！ 多用flex float去解决一些差异吧~结语文章每个点都是开发小程序的时候遇到的问题，本人能力有限，欢迎大家提出自己的问题，也可以加入微信群和我们团队一起交流学习。小程序坑还是蛮多的，而且写博客也蛮难得，码子不易，点个赞吧！ :）逃~~~~~" } { "title": "在小程序中自定义弹窗组件 ", "author": "Rolan", "pub_time": "2019-11-8 00:08", "content": "component\r\n{\r\n    \"component\": true\r\n}\r\n复制代码表明它是一个组件，我们称之为“子组件” 3. 注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。（只使用class）如何使用组件便于区分，引用子组件的页面我们称之为“父组件，” 在父组件的json里先引用子组件：{\r\n  \"usingComponents\": {\r\n    \"component-tag-name\": \"path/to/the/custom/component\"\r\n  }\r\n}\r\n复制代码父组件传值给子组件因为这个自定义的弹窗组件会应用于很多不同的页面，所以显示的弹窗标题也是不同的，这就是需要父组件给子组件自定义标题，也就是子组件的标题应该从父组件中接受到的。 子组件里： wxml<view class=\"page\">\r\n  <view>{{popupTitle}}</view>\r\n</view>\r\n复制代码jsComponent({\r\n  properties: {\r\n    // 这里定义了innerText属性，属性值可以在组件使用时指定\r\n    popupTitle: { //弹窗标题\r\n      type: String,\r\n      value: '默认值', \r\n    }\r\n  },\r\n})\r\n复制代码父组件里： wxml<popup popup-title=\"{{pagetitle}}\"/>\r\n复制代码jsdata: {\r\n    pagetitle: '我是页面标题',\r\n}\r\n复制代码. 在子组件中自定义值是以小驼峰的形式书写的，但是在父组件传的时候要以“-”连接。子组件改变父组件的值这个组件的显示和隐藏都是在父组件决定的，但是因为我这是一个全屏的弹窗，覆盖了整个屏幕，所以想要关闭弹框只能想办法在子组件的点击事件上想办法。 基本逻辑是这样的： 操作流程：打开页面- 点击弹框（弹出子组件）- 点击关闭（点击子组件关闭弹窗） 数据流程：打开页面-点击弹框（传入弹窗标题、点赞成功结果、其他参数）-点击关闭（在父组件上自定义组件，然后子组件关闭按钮监听onTap事件，点击子组件关闭按钮时，会通知父组件去改变状态）逻辑：在子组件中给要触发的元素加 bindtap = 'onTap'然后通过在method中设置onTap函数在onTap中的triggerEvent中设置要触发父组件事件的函数名称父组件接收到字组件的消息，然后触发事件具体参考：\t小程序-组件通信子组件： wxml<view class=\"hide-btn\" bindtap=\"onTap\">×</view>\r\n复制代码jsmethods: { //放自定义的方法\r\n    onTap: function () {\r\n      var myEventDetail = {} // detail对象，提供给事件监听函数\r\n      var myEventOption = {} // 触发事件的选项\r\n      console.log(`子组件：'向父组件发送通知，我要关闭弹窗'`)\r\n      this.triggerEvent('hidepopop', myEventDetail, myEventOption)\r\n    }\r\n  },\r\n复制代码父组件 wxml<popup \r\nbindhidepopop=\"hidePopop\" \r\nis-show-popup=\"{{isShowPopup}}\" \r\npopup-title=\"{{popupTitle}}\" \r\npopup-content=\"{{popupContent}}\"\r\n/>\r\n复制代码jshidePopop: function(e) {\r\n    console.log(e.detail) // 自定义组件触发事件时提供的detail对象\r\n    console.log('父组件：我接受到了子组件的关闭弹窗的通知！');\r\n    this.setData({\r\n      isShowPopup: true\r\n    })\r\n  }\r\n复制代码参考小程序-自定义组件 代码地址：\tgithub.com/AnsonZnl/wx…" } { "title": "微信小程序使用echarts，实现左右双Y轴，动态获取数据，生成折线图 ... ", "author": "Rolan", "pub_time": "2019-11-8 00:52", "content": "微信小程序使用echarts，实现左右双Y轴，动态获取数据，生成折线图 本来使用的是wxcharts，但发现实现不了左右双y轴的效果，就换成echarts效果图展示 要实现这样的效果，需要以下几步： （1）去github下载插件，放进自己的项目里 呐，链接 ===>点击这里 只需要将名称是ec-canvas的文件夹放进自己项目里。 像这样： 图片发自简书App（2）分别写小程序的四个文件 ①//echart.json{  \"usingComponents\": {    \"ec-canvas\": \"../../ec-canvas/ec-canvas\"  }}②<!--echart.wxml--><view class=\"container\">     <ec-canvas id=\"myechart\" canvas-id=\"graph\" ec=\"{{ ec }}\"></ec-canvas></view>③/* echart.wxss*/.container{  margin: 0;  padding: 0}④ echart.js 这里分步写： 第一步：导入 echarts 插件import * as echarts from '../../ec-canvas/echarts';第二步：写在Page外的方法function echart(chart, leftData, rightData) {//leftData是坐标系左边y轴，rightData是右边y轴  var option = {    //网格    grid: {      bottom: 80,      show: true,      // containLabel: true    },    //图例    legend: {      data: [{          name: 'leftData',          textStyle: { //设置颜色            color: '#6076FF',            fontSize: '14',          }        },        {          name: 'rightData',          textStyle: {            color: '#FFC560',            fontSize: '14',          }        }      ],      x: 'left',      bottom: 15,      left: 30    },    //x轴    xAxis: {      type: 'category',      boundaryGap: false,      disableGrid: true, //绘制X网格      data: ['', '', '', '', '', '', '', '', ''],      splitLine: {        show: true,        //  改变轴线颜色        lineStyle: {          // 使用深浅的间隔色          color: ['#DDDDDD']        }      },      //去掉刻度      axisTick: {        show: false      },      //去掉x轴线      axisLine: {        show: false      },    },    //y轴    yAxis: [{        name: 'mph',        type: 'value',        min: 0,        // max: 40,        //y标轴名称的文字样式        nameTextStyle: {          color: '#FFC560'        },        //网格线        splitLine: {          show: true,          lineStyle: {            color: ['#DDDDDD']          }        },        //去掉刻度        axisTick: {          show: false        },        //去掉y轴线        axisLine: {          show: false        },      },      {        name: 'g',        type: 'value',        // max: 4,        min: 0,        nameTextStyle: {          color: '#6076FF'        },        //去掉刻度        axisTick: {          show: false        },        //去掉y轴线        axisLine: {          show: false        },      }    ],    series: [{        name: 'leftData',        type: 'line',        animation: true, //动画效果        symbol: 'none',        //折线区域        areaStyle: {          //渐变颜色          color: {            type: 'linear',            x: 0,            y: 0,            x2: 0,            y2: 1,            colorStops: [{              offset: 0,              color: '#6076FF' // 0% 处的颜色            }, {              offset: 1,              color: 'rgba(96,118,255,0.1)' // 100% 处的颜色            }],            global: false, // 缺省为 false          },        },        //折线宽度        lineStyle: {          width: 2        },        color: '#6076FF',        data: leftData // 后台传过来的动态数据        //设置固定的数据        // data: [        //   23, 30, 20, 23, 30, 26, 20, 25, 25        // ]       },      {        name: 'rightData',        type: 'line',        yAxisIndex: 1,        animation: true,        symbol: 'none',        areaStyle: {          color: {            type: 'linear',            x: 0,            y: 0,            x2: 0,            y2: 1,            colorStops: [{              offset: 0,              color: '#FFC560' // 0% 处的颜色            }, {              offset: 1,              color: 'rgba(255, 197, 96,0.3)' // 100% 处的颜色            }],            global: false, // 缺省为 false          },        },        lineStyle: {          width: 2        },        color: '#FFC560',        data: rightData,//后台传过来的动态数据        //设置固定的数据        // data: [        //   2, 1, 0.5, 0.9, 2, 1.0, 0.6, 2, 0.5        // ]      }]  }}第三步：写在Page里的方法，（包括onLoad(),初始化）/** * 页面的初始数据 */data: {  ec: {    lazyLoad: true //初始化加载  }},onLoad: function (options) {  let that = this;  this.oneComponent = this.selectComponent('#mychart');  let url = \"xxxxx\";  let params = {    \"openId\": options.id,  };wx.request({    url: \"xxxx\",    method: 'POST'    data: params,    header: header,    success: (res) => {     that.setData({       leftData: xxx,//从后台获取的数据       rightData: xxxx //从后台获取的数据   });    },  //给图表加上数据  that.initGraph(that.data.leftData, that.data.rightData)  })}初始化图表initGraph: function (leftData, rightData) {  this.oneComponent.init((canvas, width, height) => {    const chart = echarts.init(canvas, null, {      width: width,      height: height    });    initChart(chart, leftData, rightData);    this.chart = chart;    return chart;  });}到这就搞定啦" } { "title": "微信小程序工程化之路 ", "author": "Rolan", "pub_time": "2019-11-11 00:30", "content": "最近很长一段时间都在和前端项目构建“纠缠”在一起，处理了web项目、app项目紧接着便是微信小程序，之所以把微信单独拎出来做一篇分享，主要是因为小程序的工程化在很多细节上是区别于传统意义上的web项目，请往下看准备工作配置一台打包机，建议弄一台mini（具体配置根据大家的实际情况来定，ps一下我们公司用的16G+128的，目前来说资源已经明显不够用了）其次要去搭建一个jenkins服务，做任务的集中管理。搭建一个服务，主要提供和微信的对接为后期代码上传，提审等功能做基础，关于微信的对接方式大家可以看官网文档 第三方平台如果有可能的话对接一下各自公司的办公管理工具比如企业微信、钉钉等用来做消息的通知、审核等。最后一点就是微信常用的开发套件了，就不做过多阐述。创建和执行工作流首先在Jenkins中创建任务，建议同时创建两个，一个作为开发预览（DevelopTask），另外一个作为代码上传（ReleaseTask）。Jenkins任务中的配置注意下面这几点。处理微信开发者工具登录过期，我们可以通过开发辅助中提供的命令行登录方式来获取到授权二维码，提供给管理者去处理。DevelopTask要定时执行，因为小程序预览二维码会有过期的问题，所以我这里每20分钟会重新生成一张，我们可以在Jenkins的构建触发器中设置DevelopTask的脚本配置主要是上传预览、生成二维码资源（Base64）、通知开发者获取新的二维码。ReleaseTask中区别与DevelopTask的是不需要定时执行，另外我们需要将脚本中的 cli -p /Users/username/demo --preview-qr-output base64@/Users/username/code.txt 命令替换成 cli -u 1.0.0@/Users/username/demo --upload-desc 'initial release' --upload-info-output /Users/username/info.json开发预览，上面说到DevelopTask会生成预览二维码的base64文件，如何将这个信息通知给测试或者开发者呢？这里我以企业微信的方式为例，首先看下效果通过企业微信中的接受消息功能我们可以将消息做一次中转，另外通过消息推送将新的消息推送给指定的用户，我们可以在中转服务中将二维码信息推送给用户，这里有一张企业微信消息推送的流程，大家可以借鉴一下，另外企业微信支持配置菜单类似于微信公众号中的菜单。版本发布，ReleaseTask执行外之后我们会将代码推送到小程序的草稿库中，这里距离真正的提审还有三步骤，第一添加草稿到代码模版库，第二通过模版ID上传小程序代码，第三提交审核。这里的三个步骤由于微信限制，我们没办法在Jenkins中去操作，我们可以搭建中转服务去管理。总结整体流程创建Jenkins任务，处理预览或者上传问题测试：生成预览二维码模版发布：上传草稿利用微信三方服务接口实现模版提交，提审等功能如有不足，还望指出。愿大家在前端的道路上少走弯路" } { "title": "uni-app中picker组件“确定”和“取消”文字的修改 ", "author": "Rolan", "pub_time": "2019-11-11 00:45", "content": "本文为uniapp中picker组件“确定”和“取消”文字的修改的教程，包括颜色和文字，需要清楚的是，颜色在H5和微信小程序下非常容易修改，但是“确定”和“取消”文字是无法修改的，因为在uniapp中这些都是写死在uniapp源码中的，目前没有找到更好的方式去修改！前言首先需要确定的几点* 在uniapp中picker组件是webview（无论是小程序还是APP，h5是dom）* 需要清楚自己需要修改的是什么版本的，H5和APP以及小程序不一样* 是需要修改文字还是颜色* 没有源码阅读能力者请谨慎操作H5修改颜色非常方面，但是修改文字目前只能改uniapp源码* 修改文字，找到你安装HBuilderX的目录D:\\Program Files\\HBuilderX\\plugins\\uniapp-cli\\node_modules\\@dcloudio\\uni-h5\\src\\platforms\\h5\\view\\components\\picker\\index.vue\r\n// D:\\Program Files为你安装的HBuilderX目录\r\n// 在index.vue中16-25行代码中\r\n\r\n        <div\r\n          class=\"uni-picker-header\"\r\n          @click.stop>\r\n          <div\r\n            class=\"uni-picker-action uni-picker-action-cancel\"\r\n            @click=\"_cancel\">取消</div>\r\n          <div\r\n            class=\"uni-picker-action uni-picker-action-confirm\"\r\n            @click=\"_change\">确定</div>\r\n        </div>修改颜色，可以直接在上面的index.vue里面修改，但是这样做会带来一个问题，就是每次升级HBuilderX的时候就需要修改这个文件// 在index.vue中550-558行代码中\r\n.uni-picker-container .uni-picker-action.uni-picker-action-cancel {\r\n  float: left;\r\n  color: #888;\r\n}\r\n\r\n.uni-picker-container .uni-picker-action.uni-picker-action-confirm {\r\n  float: right;\r\n  color: #007aff;\r\n}在App.vue中修改颜色uni-picker .uni-picker-action.uni-picker-action-confirm{color: #FF725C;}App和小程序在app和小程序中 H5版本的修改方法全部失效修改文字// 在D:\\Program Files\\HBuilderX\\plugins\\weapp-tools\\template\\common\\__uniapppicker.html\r\n// 第 5562-5577是“取消”和“确定”的文字\r\n}, [t._v('取消')]), e(\"div\", {\r\n    staticClass: \"uni-picker-action uni-picker-action-confirm\",\r\n    on: {\r\n    click: t._change\r\n    }\r\n}, [t._v('确定')])]), t.visible ? e(\"picker-view\", {\r\n    staticClass: \"uni-picker-content\",\r\n    attrs: {\r\n    value: t.valueArray\r\n},\r\n    on: {\r\n    \"update:value\": function(i) {\r\n        t.valueArray = i\r\n    }\r\n}\r\n},修改样式// 第14行css代码中\r\n.uni-picker-action.uni-picker-action-cancel[data-v-1c1d4578]{float:left;color:#888} // 取消\r\n.uni-picker-action.uni-picker-action-confirm[data-v-1c1d4578]{float:right;color:#57DBD0} //确定注意事项此方法在升级更新HBuilderX里面的文件就会重置，请注意再次修改，最好把自己项目需要修改的文件修改后备份" } { "title": "微信小程序实现去抖音视频水印 ", "author": "Rolan", "pub_time": "2019-11-11 00:52", "content": "先放效果图可以扫码或者微信搜索 “ 和水印说拜拜 ” 小程序体验一下。有效再继续往下看吧。实现原理抖音视频上传后，是有2个视频地址，（长视频还会多一个），一个是无水印的，一个是有水印的，万能的网友经过爬虫后，拿到了这个链接，那就可以实现保存无水印的视频了（去水印）。先上代码1、里面是一个PHP文件，把你输入的抖音链接，转为无水印的链接输出。不建议把这个转换算法写死在本地，因为这个转换算法随时会变，所以用PHP实现，然后客户端或者微信小程序调用。<?phpheader('Content-type: application/json');$_u = $_GET['_u'];function _g($_u, $_n = 0) {    $_h = curl_init();    curl_setopt($_h, CURLOPT_URL, $_u);    curl_setopt($_h, CURLOPT_RETURNTRANSFER, 1);    curl_setopt($_h, CURLOPT_HEADER, false);    curl_setopt($_h, CURLOPT_HTTPHEADER, array(        'user-agent:Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Mobile Safari/537.36'    ));    if ($_n == 1) {        curl_setopt($_h, CURLOPT_NOBODY, 1);        curl_setopt($_h, CURLOPT_FOLLOWLOCATION, 1);        curl_exec($_h);        $_r = curl_getinfo($_h, CURLINFO_EFFECTIVE_URL);    } else {        $_r = curl_exec($_h);    }    curl_close($_h);    return $_r;}if (strpos($_u, 'com') !== false) {    $_u = _g(_g($_u, 1));    preg_match('/class=\\\"video-player\\\" src=\\\"(.*?)\\\" preload/is', $_u, $_m);    $_m = str_replace(\"line=0\", \"line=1\", str_replace(\"playwm\", \"play\", $_m[1]));    $_v = _g($_m, 1);    if ($_v == '') {        $_c = 0701.1;        $_s = 'error';    } else {        $_c = 0;        $_s = 'success';    }} else {    $_c = 0701.2;    $_s = 'url does not match';}echo json_encode(array(    \"code\" => $_c,    \"errMsg\" => $_s,    \"videoUrl\" => $_v,    \"tmp\" => time()) , JSON_UNESCAPED_SLASHES);?> 把这个PHP文件丢到你的服务器，然后访问https://xxxx.com/douyin.php?_u=https://sss抖音链接 然后就会返回对应的信息，例如：{    \"code\": 0,    \"errMsg\": \"success\",    \"videoUrl\": \"https://aweme.snssdk.com/aweme/v1/play/?s_vid=93f1b41336a8b7a442dbf1c29c6bbc56827bba338da58fff9d414d5e0e891260a1c391d356de42072e5c7b4c15e93325052710f7923662532737d5c3f25a856e&amp;line=1\",    \"tmp\": 1568018629}这个videoUrl就是无水印的视频地址，可以直接在小程序 标签里面播放，但是在小程序里面，这个是保存不了的，很奇怪，我试了很多次，都是提示类型无效。所以，我是直接让用户复制这个链接，然后在QQ浏览器打开，就能下载视频。（如果有人知道小程序怎样能保存这个视频，请联系我，我做了一个微信小程序的代码片段，你们可以拿去试下。地址：https://developers.weixin.qq.com/s/f5e4RbmR7kbH）如果是客户端使用的话，是可以直接保存的，后缀名为mp4，能直接下载保存。核心代码    $_u = _g(_g($_u, 1));    preg_match('/class=\\\"video-player\\\" src=\\\"(.*?)\\\" preload/is', $_u, $_m);    $_m = str_replace(\"line=0\", \"line=1\", str_replace(\"playwm\", \"play\", $_m[1]));    $_v = _g($_m, 1);上面的PHP，其实主要就是这里，把接收的抖音链接，进行一个正则转换替换字符，然后再输出链接。最后说几句这个转换的算法，应该是抖音随时更换的，不保证永远有效，但截至发帖，都是有效的，建议大家去扫一下小程序，看看能不能转换，能的话，即表明还能用。" } { "title": "微信小程序swiper组件非居中对称滑动解决方案 ", "author": "Rolan", "pub_time": "2019-11-12 00:02", "content": "一、前言在公司的项目中遇到了非居中对称的类banner滑动需求，如下图：每次滑动的距离并非一屏的宽度，而是要根据实际情况来控制。二、解决方案一开始看文档，由于swiper组件的配置项并不多，我估计能解决这个需求的大概只有previous-margin，next-margin和display-multiple-items三个参数。在经过一系列尝试之后，放弃了display-multiple-items这个参数，如果使用这个参数，很多时候基本上触发不了bindchange事件，并不符合预期也不合理。于是开始研究previous-margin和next-margin，previous-margin可以露出前一项的一小部分，next-margin可以露出后一项的一小部分。于是在初始化时，我把previous-margin设置为28，next-margin设置为400，就可以完美展现图banner1的效果。（slide宽度为300rpx）<swiper\r\n  class=\"swiper-container\"\r\n  previous-margin=\"{{swiperDis.previous}}rpx\"\r\n  next-margin=\"{{swiperDis.next}}rpx\"\r\n  bindchange=\"handleSwiperChange\"\r\n>\r\n  <block wx:for=\"{{ImgList}}\" wx:key=\"{{index}}\">\r\n    <swiper-item class=\"slide-item\">\r\n      <navigator>\r\n        <view class=\"slide-content\">\r\n          <image class=\"slide-bg\" src=\"{{item.bg}}\" />\r\n        </view>\r\n      </navigator>\r\n    </swiper-item>\r\n  </block>\r\n</swiper>swiperDis设置为：swiperDis: {\r\n  previous: 28,\r\n  next: 400\r\n}这时候如果滑动的话，会发现后面两个slier并不如我们所想，而是每次都会滑到最前面，所以我就想如果我在每次bindchange的时候改变previous-margin和next-margin呢？于是我加入了这种傻瓜式的代码：handleSwiperChange(e) {\r\n  const currentIndex = e.detail.current\r\n  if(currentIndex == 0) {\r\n    this.setData({\r\n      swiperDis: {\r\n        previous: 28,\r\n        next: 400\r\n      }\r\n    })\r\n  }else if(currentIndex == 1) {\r\n    this.setData({\r\n      swiperDis: {\r\n        previous: 214,\r\n        next: 214\r\n      }\r\n    })\r\n  }else if(currentIndex == 2) {\r\n    this.setData({\r\n      swiperDis: {\r\n        previous: 400,\r\n        next: 28\r\n      }\r\n    })\r\n  }\r\n}得到的效果如我所想。唯一不够完美的就是这样设置不如swiper自适应滑动的效果那么自然，稍微有那么一点点的卡顿，但我觉得在没有更好的解决办法前这是个又快速又好的方法。" } { "title": "微信小程序实现A-Z导航的Slidebar ", "author": "Rolan", "pub_time": "2019-11-12 00:41", "content": "微信小程序实现A-Z导航的Slidebar效果代码slidebar.wxml<view id=\"s-bar\" class=\"slidebar\" bindtouchstart=\"_onTouchStart\" bindtouchmove=\"_onTouchMove\" bindtouchend=\"_onTouchEnd\">  <view wx:for=\"{{data}}\" class=\"slide-item\" id=\"item-{{index}}\" wx:key=\"{{index}}\">    <text class=\"t {{item.selected ? 'slide-item-selected' : ''}}\">{{item.key}}</text>  </view></view><view class=\"dialog\" hidden=\"{{currentKey == '' || closeKeyDialog}}\" animation=\"{{animationData}}\" bindtransitionend=\"_onAnimationend\">  {{currentKey}}</view>slidebar.wxss  /* components/slidebar/slidebar.wxss */.slidebar{  position: absolute;  right: 0rpx;  height: 98vh;  width: 60rpx;  border-radius: 30rpx;}.slide-item{  display: flex;  justify-content: center;  justify-items: center;  height: 3.9vh;  width: 60rpx;  font-size: 24rpx;  color: #222222;  text-align: center;  line-height: 3.9vh;  font-weight: 400;}.slide-item .t{  width: 40rpx;  height: 40rpx;  display: inline-block;}.slide-item-selected{  font-weight: 500;  color: #ffffff;  background: #07C160;  border-radius: 50%;}.dialog{  position: absolute;  top: 50%;  margin-top: -180rpx;  left: 50%;  margin-left: -125rpx;  width: 250rpx;  height: 250rpx;  text-align: center;  font-size: 72rpx;  line-height: 250rpx;  color: #ffffff;  background: grey;  border-radius: 15%;}slidebar.js  // components/slidebar/slidebar.jsComponent({  /**   * 组件的属性列表   */  properties: {    data: {      type: Array,      value: [        { key: \"A\" },        { key: \"B\" },        { key: \"C\" },        { key: \"D\" },        { key: \"E\" },        { key: \"F\" },        { key: \"G\" },        { key: \"H\" },        { key: \"I\" },        { key: \"J\" },        { key: \"L\" },        { key: \"M\" },        { key: \"N\" },        { key: \"O\" },        { key: \"P\" },        { key: \"Q\" },        { key: \"R\" },        { key: \"S\" },        { key: \"T\" },        { key: \"U\" },        { key: \"V\" },        { key: \"W\" },        { key: \"X\" },        { key: \"Y\" },        { key: \"Z\" }      ]    }  },  /**   * 组件的初始数据   */  data: {    selectedIndex: -1,    currentKey: \"\",    closeKeyDialog: false,    animationData: {},  },  lifetimes: {    attached: function () {      // 在组件实例进入页面节点树时执行      this.isTouch = false;    },    ready: function(){      this.data.data.forEach((d,i)=>{        this._wxQueryElementInfo(\"#item-\" + i).then(res => {          d.top = res[0].top;          d.left = res[0].left;          d.height = res[0].height;          d.width = res[0].width;        });      });      this.animation = wx.createAnimation({        duration: 1000,        timingFunction: 'ease',      });    },    detached: function () {      // 在组件实例被从页面节点树移除时执行    },  },  /**   * 组件的方法列表   */  methods: {    _onTouchStart: function(e){      this.isTouch = true;      this.setData({        closeKeyDialog: false,        animationData: this.animation.opacity(1).step().export()      });      this._markSlideItemSeleted(e.touches[0].clientY);    },    _onTouchMove: function(e){      this._markSlideItemSeleted(e.touches[0].clientY);    },    _onTouchEnd: function(e){      this.isTouch = false;      this.setData({        animationData: this.animation.opacity(0).step().export()      })    },    /**     * 通过selector查询元素信息     */    _wxQueryElementInfo: function(selector){      return new Promise((resolve, reject)=>{        var query = wx.createSelectorQuery().in(this);        query.select(selector).boundingClientRect();        query.selectViewport().scrollOffset();        query.exec(function (res) {          resolve(res);        });      });    },    /**     * 根据y的位置标记SlideItem的selected状态     */    _markSlideItemSeleted: function(y){      for(var i=0; i<this.data.data.length; i++){        var d = this.data.data[i];        if (y >= d.top && y <= d.top + d.height) {          if(this.data.selectedIndex == i){            return;          }          this._setSlideItemSelectStatus(d,i);          console.log(\"当前选中=>\" + d.key);          this.triggerEvent(\"selected\",d);          return;        }      }    },    _setSlideItemSelectStatus(d,i){      d.selected = true;      if (this.data.selectedIndex != -1) {        this.data.data[this.data.selectedIndex].selected = false;      }      this.setData({        data: this.data.data,        currentKey: d.key,        selectedIndex: i      });    },    _onAnimationend: function(e){      if (this.isTouch){        return;      }      console.log(\"动画结束\")      this.setData({        closeKeyDialog: true      });    },    /**     * 通过key更新slidebar选择的item     */    updateItemSelectedByKey: function(key){      this.data.data.forEach((d,i)=>{        if(d.key == key){          this._setSlideItemSelectStatus(d,i);          return;        }      });    },    /**     * 通过index更新slidebar选择的item     */    updateItemSelectedByIndex: function(index){      if(index > 0 && index < this.data.data.length){        this._setSlideItemSelectStatus(this.data.data[index], index);      }    }  }})" }